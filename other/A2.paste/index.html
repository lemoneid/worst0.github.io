<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Wiki Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Wiki Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">A2.paste | My Wiki</title><meta data-react-helmet="true" property="og:url" content="https://worst0.github.io/other/A2.paste"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="A2.paste | My Wiki"><meta data-react-helmet="true" name="description" content="后台开发：核心技术与应用实践"><meta data-react-helmet="true" property="og:description" content="后台开发：核心技术与应用实践"><meta data-react-helmet="true" property="og:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://worst0.github.io/other/A2.paste"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/other/A2.paste" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/other/A2.paste" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.060912d8.css">
<link rel="preload" href="/assets/js/runtime~main.f891d386.js" as="script">
<link rel="preload" href="/assets/js/main.56ecaf81.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a><a class="navbar__item navbar__link" href="/intro">Document💻</a><a class="navbar__item navbar__link" href="/blog">Blog🤓</a><a class="navbar__item navbar__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a><a class="navbar__item navbar__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">本站源码</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">🌙</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/intro">Document💻</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog🤓</a></li><li class="menu__list-item"><a class="menu__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a></li><li class="menu__list-item"><a class="menu__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></li><li class="menu__list-item"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="menu__link">本站源码</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><main class="docMainContainer_3ufF docMainContainerEnhanced_3NYZ"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">A2.paste</h1></header><div class="markdown"><p>后台开发：核心技术与应用实践
徐晓鑫</p><p>◆ 1.2 函数</p><blockquote><blockquote><p>形参与实参的区别是：形参只有被调用时才分配内存单元，在调用结束时，立即释放所分配的内存单元。</p></blockquote></blockquote><p>◆ 1.6.2 结构体、共用体在内存单元占用字节数的计算</p><blockquote><blockquote><p>共用体内变量的默认内存对齐方式，必须以最长的double（8Byte）对齐</p></blockquote></blockquote><blockquote><blockquote><p>结构中占用最大空间的类型所占用的字节数sizeof（double）=8）的倍数，</p></blockquote></blockquote><p>◆ 1.7 预处理</p><blockquote><blockquote><p>__cplusplus是C++的预定义宏，表示当前开发环境是C++。在C++语言中，为了支持重载机制，在编译生成的汇编代码中，会对函数名字进行一些处理（通常称为函数名字改编），如加入函数的参数类型或返回类型等</p></blockquote></blockquote><blockquote><blockquote><p>在C/C++混合编程的环境下，extern&quot;C&quot;块的作用就是告诉C++编译器这段代码要按C标准编译，以尽可能地保持C++与C的兼容性。</p></blockquote></blockquote><p>◆ 2.1 类与对象</p><blockquote><blockquote><p>为了实现类对象的封装性（数据隐藏和提供访问接口），类类型定义为类成员提供了私有、公有和受保护的3种基本访问权限供用户选择</p></blockquote></blockquote><blockquote><blockquote><p>调用构造函数时不必给出实参的构造函数，称为默认构造函数。无参的构造函数属于默认构造函数。一个类只能有一个默认构造函数。即使一个类中有多个构造函数，但建立对象时，都只执行其中一个构造函数。</p></blockquote></blockquote><blockquote><blockquote><p>一个类中如果定义了全是默认参数的构造函数后，就不能再定义重载构造函数了。</p></blockquote></blockquote><blockquote><blockquote><p>定义必须出现在类的外部而且只能定义一次</p></blockquote></blockquote><blockquote><blockquote><p>如果只声明了类而未定义对象，类的一般数据成员是不占内存空间的，只有在定义对象时才会为对象的数据成员分配空间。但是静态数据成员不属于某一个对象，所以在为对象所分配的空间中不包括静态数据成员所占的空间，静态数据成员是在所有对象之外单独开辟一段空间来存放。</p></blockquote></blockquote><blockquote><blockquote><p>静态成员函数的作用不是为了对象之间的沟通，而是为了能处理静态数据成员。</p></blockquote></blockquote><blockquote><blockquote><p>当调用一个对象的成员函数（非静态成员函数）时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数并不属于某一对象，它与任何对象都无关，因此静态成员函数没有this指针。既然它没有指向某一对象，也就无法对一个对象中的非静态成员进行默认访问（即在引用数据成员时不指定对象名）</p></blockquote></blockquote><blockquote><blockquote><p>非静态成员变量总和加上编译器为了CPU计算做出的数据对齐处理和支持虚函数所产生的负担的总和。</p></blockquote></blockquote><blockquote><blockquote><p>空类型对象中不包含任何信息，应该大小为0。但是当声明该类型的对象的时候，它必须在内存中占有一定的空间，否则无法使用这些对象。至于占用多少内存，由编译器决定。C++中每个空类型的实例占1Byte空间</p></blockquote></blockquote><blockquote><blockquote><p>成员函数是不占空间的。</p></blockquote></blockquote><blockquote><blockquote><p>但是虚继承涉及虚表（虚指针），所以sizeof（d）=8</p></blockquote></blockquote><blockquote><blockquote><p>每个对象所占用的存储空间只是该对象的非静态数据成员的总和，其他都不占用存储空间，包括成员函数和静态数据成员。函数代码是存储在对象空间之外的，而且，函数代码段是公用的，即如果对同一个类定义了10个对象，这些对象的成员函数对应的是同一个函数代码段，而不是10个不同的函数代码段。</p></blockquote></blockquote><blockquote><blockquote><p>声明一个类模板的对象时，要用实际类型名去取代虚拟的类型，这样才能使它变成一个实际的对象，如：<code>Operation &lt;int&gt; opobj(1,2)</code>;在类模板名之后的尖括号里指定实际的类型名，这样在编译时，编译系统就用int取代类模板中的类型参数T，这样就把类模板具体化了，</p></blockquote></blockquote><blockquote><blockquote><p>先构造的后析构，后构造的先析构，它相当于一个栈，先进后出</p></blockquote></blockquote><blockquote><blockquote><p>在全局范围中定义的对象（即在所有函数之外定义的对象），它的构造函数在文件中的所有函数（包括main函数）执行之前调用</p></blockquote></blockquote><p>◆ 2.2 继承与派生</p><blockquote><blockquote><p>不同的继承方式决定了基类成员在派生类中的访问属性</p></blockquote></blockquote><blockquote><blockquote><p>派生类的构造函数必须要以合适的初值作为参数，隐含调用基类和新增对象成员的构造函数，来初始化它们各自的数据成员，然后再加入新的语句对新增普通数据成员进行初始化。</p></blockquote></blockquote><blockquote><blockquote><p>对基类成员和子对象成员的初始化必须在成员初始化列表中进行，新增成员的初始化既可以在成员初始化列表中进行，也可以在构造函数体中进行。</p></blockquote></blockquote><blockquote><blockquote><p>执行顺序是这样的：①先调用基类构造函数；②再调用子对象的构造函数；③最后调用派生类的构造函数体。</p></blockquote></blockquote><p>◆ 2.3 类的多态</p><blockquote><blockquote><p>。在C++程序设计中，多态性是指具有不同功能的函数可以用同一个函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性的：向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为（即方法）；也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p></blockquote></blockquote><blockquote><blockquote><p>不仅函数名相同，而且函数类型和参数个数都相同，但两个同名函数不在同一个类中，而是分别在基类和派生类中，属于同名覆盖</p></blockquote></blockquote><blockquote><blockquote><p>重载函数，二者的参数个数和参数类型必须至少有一者不同，否则系统无法确定调用哪一个函数。</p></blockquote></blockquote><blockquote><blockquote><p>虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。</p></blockquote></blockquote><blockquote><blockquote><p>如果不声明为虚函数，企图通过基类指针调用派生</p></blockquote></blockquote><blockquote><blockquote><p>类的非虚函数则是不行的</p></blockquote></blockquote><blockquote><blockquote><p>①有时在基类中定义的非虚函数会在派生类中被重新定义，如果用基类指针调用该成员函数，则系统会调用对象中基类部分的成员函数；②如果用派生类指针调用该成员函数，则系统会调用派生类对象中的成员函数，这并不是多态性行为（使用的是不同类型的指针），没有用到虚函数的功能。</p></blockquote></blockquote><blockquote><blockquote><p>因为虚函数的作用是允许在派生类中对基类的虚函数重新定义。</p></blockquote></blockquote><blockquote><blockquote><p>在C++中，构造函数不能声明时为虚函数，这是因为编译器在构造对象时，必须知道确切类型，才能正确地生成对象；其次，在构造函数执行之前，对象并不存在，无法使用指向此对象的指针来调用构造函数。然而，析构函数可以声明为虚函数；C++明确指出，当derived class对象经由一个base class指针被删除、而该base class带着一个non-virtual析构函数，会导致对象的derived成分没被销毁掉</p></blockquote></blockquote><blockquote><blockquote><p>虚函数是多态的基础，在C++中没有虚函数就无法实现多态特性；因为不声明为虚函数就不能实现“动态联编”，就不能实现多态。</p></blockquote></blockquote><blockquote><blockquote><p>《设计模式》一书中给出了一种很不错的实现，定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法来获取该实例。单例模式的作用就是保证在整个应用程序的生命周期中的任何一个时刻，单例类的实例都只存在一个（当然也可以不存在）。</p></blockquote></blockquote><blockquote><blockquote><p>单例类CSingleton有以下特征：①有一个指向唯一实例的静态指针m_pInstance，并且是私有的；②有一个公有的函数，可以获取这个唯一的实例，并且在需要的时候创建该实例；③其构造函数是私有的，这样就不能从别处创建该类的实例。</p></blockquote></blockquote><p>◆ 3.2 string</p><blockquote><blockquote><p>1.string类的实现</p></blockquote></blockquote><p>◆ 3.3 vector</p><blockquote><blockquote><p>容器的大小和容器的容量是有区别的，大小是指元素的个数，容量是分配的内存大小，</p></blockquote></blockquote><blockquote><blockquote><p>每次重新分配内存都会很影响程序的性能，所以一般分配的容量都大于容器的大小，</p></blockquote></blockquote><p>◆ 3.3.2 vector的查增删</p><blockquote><blockquote><p>　　vector的初始化和遍历</p></blockquote></blockquote><blockquote><blockquote><p>vector的删除</p></blockquote></blockquote><p>◆ 3.3.3 vector的内存管理与效率</p><blockquote><blockquote><p>如果需要更多空间，就会以类似realloc的思想来增长大小。vector容器支持随机访问，因此为了提高效率，它内部是使用动态数组的方式实现的。</p></blockquote></blockquote><blockquote><blockquote><p>size（）可以获得容器中有多少元素，但不能获得容器为它容纳的元素分配的内存大小。</p></blockquote></blockquote><p>◆ 3.3.4 Vector类的简单实现</p><blockquote><blockquote><p>Vector类的简单实现</p></blockquote></blockquote><p>◆ 3.4 map</p><blockquote><blockquote><p>map内部数据的组织，map内部自建一棵红黑树（一种非严格意义上的平衡二叉树），这棵树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的。</p></blockquote></blockquote><p>◆ 3.4.2 map的查增删</p><blockquote><blockquote><p>用insert函数插入pair数据</p></blockquote></blockquote><blockquote><blockquote><p>map中用数组方式插入数据。</p></blockquote></blockquote><blockquote><blockquote><p>当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值。</p></blockquote></blockquote><blockquote><blockquote><p>pair判断insert到map的数据是否插入成功。</p></blockquote></blockquote><blockquote><blockquote><p>mapStudent.erase（iter++）；中的iter++，不是erase（iter），然后iter++。因为iter指针被erase之后就失效了，不能再用iter++；也不是erase（++iter），这样就不是删iter原来指向的元素了。</p></blockquote></blockquote><blockquote><blockquote><p>其实质是对operator（）操作符的重载。</p></blockquote></blockquote><p>◆ 3.4.3 map的原理</p><blockquote><blockquote><p>①每个结点要么是红的要么是黑的；②根结点是黑的；③每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的；④如果一个结点是红的，那么它的两个儿子都是黑的；⑤对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。</p></blockquote></blockquote><p>◆ 3.5 set</p><blockquote><blockquote><p>因为对于关联容器来说，不需要做内存拷贝和内存移动</p></blockquote></blockquote><p>◆ 4.1 编译与链接</p><blockquote><blockquote><p>链接过程主要包括了地址和空间分配、符号决议和重定位等这些步骤。</p></blockquote></blockquote><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><blockquote><blockquote><p>静态链接库、动态链接库各自的特点。</p></blockquote></blockquote><blockquote><blockquote><p>使用extern&quot;C&quot;编译程序</p></blockquote></blockquote><p>◆ 5.1 strace</p><blockquote><blockquote><p>一般称Linux系统上的这些函数为“系统调用”（system call）。这些函数代表了用户空间到内核空间的一种转换，例如，在用户空间调用open函数，在内核空间则会调用sys_open。系统调用的错误码：系统调用并不直接返回错误码，而是将错误码放入一个名为errno的全局变量中。如果一个系统调用失败，你可以读出errno的值来确定问题的所在。errno不同数值所代表的错误消息定义在errno.h中，你也可以通过命令&quot;man 3 errno&quot;来查看它们。需要注意的是，errno的值只在函数发生错误时设置，如果函数不发生错误，errno的值就无定义，并不会被置为0。另外，在处理errno前最好先把它的值存入另一个变量，因为在错误处理过程中，即使像printf（）这样的函数出错时也会改变errno的值。</p></blockquote></blockquote><p>◆ 5.2 gdb</p><blockquote><blockquote><p>l：列出函数代码及其行数。b 16：在代码16行处设置断点。b func：在函数func处设置断点。r：运行程序。n：单条执行语句。p i：打印i变量的值。bt：查看函数的堆栈。finish：退出函数。q：结束调试。</p></blockquote></blockquote><blockquote><blockquote><p>但如果程序中调用了chdir函数，则有可能改变了当前工作目录</p></blockquote></blockquote><p>◆ 5.3 top</p><blockquote><blockquote><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况</p></blockquote></blockquote><p>◆ 5.4 ps</p><blockquote><blockquote><p>Linux中的ps（process status）命令列出的是当前在运行的进程的快照，就是执行ps命令的那个时刻的那些进程，</p></blockquote></blockquote><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><p>◆ 5.5.2 Linux程序内存空间布局</p><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><blockquote><blockquote><p>栈：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的</p></blockquote></blockquote><blockquote><blockquote><p>用ulimit-a命令可以看到栈大小的限制</p></blockquote></blockquote><blockquote><blockquote><p>堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存</p></blockquote></blockquote><p>◆ 6.1 TCP协议</p><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><p>◆ 6.1.2 TCP头部</p><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><blockquote><blockquote><p>1）TCP的包是没有IP地址的，那是IP层上的事，但是有源端口和目的端口。2）一个TCP连接需要4个元组（src_ip、src_port、dst_ip、dst_port）来表示是同一个连接。准确说是五元组，还有一个是协议。但因为这里只是强调TCP协议，所以，只说四元组。</p></blockquote></blockquote><blockquote><blockquote><p>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。4）Acknowledgement Number就是ACK，用于确认收到，用来解决不丢包的问题。5）Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控问题。6）TCP Flag，也就是包的类型，主要是用于操控TCP的状态机的。</p></blockquote></blockquote><p>◆ 6.1.3 TCP状态流转</p><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><p>◆ 6.1.4 TCP超时重传</p><blockquote><blockquote><p>当出现这些异常情况时，TCP就会超时重传。TCP每发送一个报文段，就对这个报文段设置一次计时器。只要计时器设置的重传时间到了，但还没有收到确认，就要重传这一报文段，这个就叫作“超时重传”</p></blockquote></blockquote><blockquote><blockquote><p>其中，telnet ip port是查看某一个机器上的某一个端口是否可以访问。tcpdump-ieth1&#x27;port 1055&#x27;是用来抓取网卡eth1上</p></blockquote></blockquote><p>◆ 6.1.5 TCP滑动窗口</p><blockquote><blockquote><p>TCP的滑动窗口主要有两个作用：一是提供TCP的可靠性；二是提供TCP的流控特性</p></blockquote></blockquote><p>◆ 6.1.6 TCP拥塞控制</p><blockquote><blockquote><p>TCP的拥塞控制由4个核心算法组成：慢开始（Slow Start）、拥塞避免（Congestion Voidance）、快速重传（Fast Retransmit）和快速恢复</p></blockquote></blockquote><blockquote><blockquote><p>。为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。ssthresh的用法如下：</p></blockquote></blockquote><blockquote><blockquote><p>拥塞控制具体过程如下所述。（1）TCP连接初始化，将拥塞窗口设置为1。（2）执行慢开始算法，cwind按指数规律增长，直到cwind=ssthress时，开始执行拥塞避免算法，cwnd按线性规律增长。（3）当网络发生拥塞，把ssthresh值更新为拥塞前ssthresh值的一半，cwnd重新设置为1，按照步骤（2）执行。</p></blockquote></blockquote><blockquote><blockquote><p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方），而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到3个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期，</p></blockquote></blockquote><blockquote><blockquote><p>快重传配合使用的还有快恢复算法，有以下两个要点。（1）当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。（2）考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法</p></blockquote></blockquote><p>◆ 6.2 TCP网络编程API</p><blockquote><blockquote><p>网络层的IP地址可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）</p></blockquote></blockquote><blockquote><blockquote><p>UNIX/Linux基本哲学之一就是“一切皆文件”，</p></blockquote></blockquote><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><blockquote><blockquote><p>当调用socket创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它赋予一个地址，就必须调用bind（）函数，否则系统就在调用connect（）、listen（）时自动随机分配一个端口</p></blockquote></blockquote><blockquote><blockquote><p>（1）sockfd：即socket描述字，它是通过socket（）函数创建来唯一标识一个socket的。bind（）函数就是将给这个描述字绑定一个名字。（2）addr：一个const struct sockaddr*指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同</p></blockquote></blockquote><blockquote><blockquote><p>close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求</p></blockquote></blockquote><p>◆ 6.3 实现一个TCP server</p><blockquote><blockquote><p>实现一个TCP server</p></blockquote></blockquote><p>◆ 6.5 网络字节序与主机序</p><blockquote><blockquote><p>所有网络协议也都是采用Big Endian的方式来传输数据的。所以有时也会把Big Endian方式称之为网络字节序。</p></blockquote></blockquote><p>◆ 6.6 封包和解包</p><blockquote><blockquote><p>封包和解包</p></blockquote></blockquote><blockquote><blockquote><p>由于TCP“流”的特性以及网络状况，在进行数据传输时假设我们连续调用两次send分别发送两段数据data1和data2，</p></blockquote></blockquote><blockquote><blockquote><p>对于UDP来说就不存在拆包的问题，因为UDP是个&quot;数据包&quot;协议，也就是两段数据间是有界限的，在接收端要么接收不到数据要么就是接收一段完整的数据，不会少接收也不会多接收。</p></blockquote></blockquote><p>◆ 第7章 网络IO模型</p><blockquote><blockquote><p>同步IO指的是，必须等待IO操作完成后，控制权才返回给用户进程。异步IO指的是，无须等待IO操作完成，就将控制权返回给用户进程。</p></blockquote></blockquote><blockquote><blockquote><p>网络中的IO，由于不同的IO设备有着不同的特点，网络通信中往往需要等待。常见的有以下4种情况。（1）输入操作：等待数据到达套接字接收缓冲区。（2）输出操作：等待套接字发送缓冲区有足够的空间容纳将要发送的数据。（3）服务器接收连接请求：等待新的客户端连接请求的到来。（4）客户端发送连接请求：等待服务器回送客户的发起的SYN所对应的ACK。</p></blockquote></blockquote><blockquote><blockquote><p>当一个网络IO（假设是read）发生时，它会涉及两个系统对象，一个是调用这个IO的进程，另一个是系统内核。当一个read操作发生时，它会经历两个阶段：①等待数据准备；②将数据从内核拷贝到进程中</p></blockquote></blockquote><p>◆ 7.1 4种网络IO模型</p><blockquote><blockquote><p>阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式：阻塞是指IO操作需要彻底完成后才返回到用户空间；而非阻塞是指IO操作被调用后立即返回给用户一个状态值，不需要等到IO操作彻底完成。</p></blockquote></blockquote><blockquote><blockquote><p>包），系统内核就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当系统内核一直等到数据准备好了，它就会将数据从系统内核中拷贝到用户内存中，然后系统内核返回结果，用户进程才解除阻塞的状态，重新运行起来。</p></blockquote></blockquote><blockquote><blockquote><p>“线程池”旨在降低创建和销毁线程的频率，使其维持一定合理数量的线程，并让空闲的线程重新承担新的执行任务。</p></blockquote></blockquote><p>◆ 7.2 select</p><blockquote><blockquote><p>使用select就可以完成非阻塞方式工作的程序，它能够监视需要被监视的文件描述符的变化情况——读、写或异常</p></blockquote></blockquote><p>◆ 7.3 poll</p><blockquote><blockquote><p>使用poll（）和select（）不一样，不需要显式地请求异常情况报告</p></blockquote></blockquote><p>◆ 7.4 epoll</p><blockquote><blockquote><p>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间之间的数据拷贝只需一次。</p></blockquote></blockquote><blockquote><blockquote><p>select、poll和epoll本质上都是同步IO，因为它们都需要在读写事件就绪后自己负责进行读写，即是阻塞的，而异步IO则无须自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p></blockquote></blockquote><p>◆ 8.1 ping</p><blockquote><blockquote><p>ping发送一个ICMP（Internet Control Messages Protocol，因特网信报控制协议），请求消息给目的地并报告是否收到所希望的ICMP echo（ICMP回声应答），它是用来检查网络是否通畅或者网络连接速度的命令。</p></blockquote></blockquote><blockquote><blockquote><p>利用网络上机器IP地址的唯一性，给目标IP地址发送一个数据包，再要求对方返回一个同样大小的数据包来确定两台网络机器是否连接相通以及时延是多少</p></blockquote></blockquote><p>◆ 8.2 tcpdump</p><blockquote><blockquote><p>tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。</p></blockquote></blockquote><p>◆ 8.3 netstat</p><blockquote><blockquote><p>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p></blockquote></blockquote><p>◆ 第9章 多线程</p><blockquote><blockquote><p>程是包含程序指令和相关资源的集合，每个进程和其他进程一起参与调度，竞争CPU、内存等系统资源。每次进程切换，都存在进程资源的保存和恢复动作，这称为上下文切换</p></blockquote></blockquote><blockquote><blockquote><p>同一个进程内部的多个线程，共享的是同一个进程的所有资源。比如，与每个进程独有自己的内存空间不同，同属一个进程的多个线程共享该进程的内存空间。</p></blockquote></blockquote><p>◆ 9.1 多线程是什么</p><blockquote><blockquote><p>对于多线程来说，由于同一个进程空间中存在多个栈，任何一个空白区域被填满都会导致栈溢出。这就是多线程，与栈密切相关。</p></blockquote></blockquote><p>◆ 9.2 多线程的创建与结束</p><blockquote><blockquote><p>pthread_join函数用来等待一个线程的结束，其函数原型为：int pthread_join (pthread_t thread, void **retval);</p></blockquote></blockquote><blockquote><blockquote><p>pthread_join和pthread_exit的区别如下所述。（1）pthread_join一般是主线程来调用，用来等待子线程退出，因为是等待，所以是阻塞的，一般主线程会依次添加所有它创建的子线程。（2）pthread_exit一般是子线程调用，用来结束当前线程。（3）子线程可以通过pthread_exit传递一个返回值，而主线程通过pthread_join获得该返回值，从而判断该子线程的退出是正常还是异常。</p></blockquote></blockquote><p>◆ 9.4 多线程同步</p><blockquote><blockquote><p>可以通过互斥锁（mutex）、条件变量（condition variable）、读写锁（reader-writer lock）和信号量（semphore）来同步资源。</p></blockquote></blockquote><blockquote><blockquote><p>互斥锁是一个特殊的变量，它有锁上（lock）和打开（unlock）两个状态。</p></blockquote></blockquote><blockquote><blockquote><p>pthread_mutex_t mutex_x= PTHREAD_MUTEX_INITIALIZER;另外锁可以用pthread_mutex_init函数动态地创建，函数原型如下：int pthread_mutex_init(pthread_mutex_t <em>mutex, const pthread_mutexattr_t </em> attr);对锁的操作主要包括加锁pthread_mutex_lock（）、解锁pthread_mutex_unlock（）和测试加锁pthread_mutex_trylock（）3个，代码如下：int pthread_mutex_lock(pthread_mutex_t <em>mutex)int pthread_mutex_unlock(pthread_mutex_t </em>mutex)int pthread_mutex_trylock(pthread_mutex_t *mutex)pthread_mutex_trylock（）语义与pthread_mutex_lock（）类似，不同的是在锁已经被占据时返回EBUSY，而不是挂起等待。</p></blockquote></blockquote><blockquote><blockquote><p>如果线程正在等待共享数据内某个条件出现，那会发生什么呢？它可能重复对互斥对象锁定和解锁，每次都会检查共享数据结构，以查找某个值。但这是在浪费时间和资源，而且这种繁忙查询的效率非常低</p></blockquote></blockquote><blockquote><blockquote><p>当线程在等待满足某些条件时使线程进入睡眠状态，一旦条件满足，就唤醒因等待满足特定条件而睡眠的线程</p></blockquote></blockquote><blockquote><blockquote><p>条件变量的相关函数</p></blockquote></blockquote><blockquote><blockquote><p>激发：激发条件有两种形式：pthread_cond_signal（）激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而pthread_cond_broadcast（）则激活所有等待线程。</p></blockquote></blockquote><blockquote><blockquote><p>条件变量特别适用于多个线程等待某个条件的发生。如果不使用条件变量，那么每个线程就需要不断尝试获得互斥锁并检查条件是否发生，这样大大浪费了系统的资源。</p></blockquote></blockquote><blockquote><blockquote><p>在一些程序中存在读者写者问题，也就是说，对某些资源的访问会存在两种可能的情况，一种是访问必须是排他性的，就是独占的意思，这称作写操作；另一种情况就是访问方式可以是共享的，就是说可以有多个线程同时去访问某个资源，这种就称作读操作。这个问题模型是从对文件的读写操作中引申出来的</p></blockquote></blockquote><blockquote><blockquote><p>互斥锁只允许一个线程进入临界区，而信号量允许多个线程同时进入临界区</p></blockquote></blockquote><p>◆ 10.1 程序与进程</p><blockquote><blockquote><p>。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB是进程存在的唯一标识，系统通过PCB的存在而感知进程的存在。系统通过PCB对进程进行管理和调度。PCB包括创建进程、执行程序、退出进程以及改变进程的优先级</p></blockquote></blockquote><blockquote><blockquote><p>每个进程在系统中都有唯一的一个ID标识它，这个ID就是进程标识符（PID）</p></blockquote></blockquote><p>◆ 10.2 进程的创建与结束</p><blockquote><blockquote><p>1号进程调用execve（）运行可执行程序init，并演变成用户态1号进程，即init进程</p></blockquote></blockquote><blockquote><blockquote><p>fork（）函数不需要参数，返回值是一个进程标识符（PID）。对于返回值，有以下3种情况。（1）对于父进程，fork（）函数返回新创建的子进程的ID。（2）对于子进程，fork（）函数返回0。（3）如果创建出错，则fork（）函数返回-1。</p></blockquote></blockquote><blockquote><blockquote><p>事实上，子进程完全复制了父进程的地址空间的内容，包括堆栈段和数据段的内容。但是，子进程并没有复制代码段，而是和父进程共用代码段。这样做是合理的，因为子进程可能执行不同的流程来改变数据段和堆栈段，因此需要分开存储父子进程各自的数据段和堆栈段。但是代码段是只读的，不存在被修改的问题，因此代码段可以让父子进程共享，以节省存储空间</p></blockquote></blockquote><blockquote><blockquote><p>现在的Linux内核在实现fork（）函数时往往在创建子进程时并不立即复制父进程的数据段和堆栈段，而是当子进程修改这些数据内容时复制操作才会发生，内核才会给子进程分配进程空间，将父进程的内容复制过来，然后继续后面的操作。这样的实现更加合理，对于一些只是为了复制自身完成一些工作的进程来说，这样做的效率会更高。这也是现代操作系统中一个重要的概念——“写时复制”的一个重要体现</p></blockquote></blockquote><p>◆ 10.3 僵尸进程</p><blockquote><blockquote><p>孤儿进程，是指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对它们完成状态收集工作。僵尸进程，是指一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称为僵尸进程。当一个进程完成它的工作终止之后，它的父进程需要调用wait（）或者waitpid（）系统调用取得子进程的终止状态。</p></blockquote></blockquote><blockquote><blockquote><p>进程一旦调用了wait函数，就立即阻塞自己</p></blockquote></blockquote><p>◆ 11.1 管道</p><blockquote><blockquote><p>（1）数据只能由一个进程流向另一个进程（其中一个读管道，一个写管道）；如果要进行双工通信，则需要建立两个管道。</p></blockquote></blockquote><blockquote><blockquote><p>2）管道只能用于父子进程或者兄弟进程间通信，也就是说管道只能用于具有亲缘关系的进程间通信。</p></blockquote></blockquote><blockquote><blockquote><p>还有一种管道叫有名管道（named pipe或FIFO），它不同于无名管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据</p></blockquote></blockquote><blockquote><blockquote><p>[插图]</p></blockquote></blockquote><p>◆ 11.2 消息队列</p><blockquote><blockquote><p>它在系统内核中是以消息链表的形式出现</p></blockquote></blockquote><blockquote><blockquote><p>①key可以认为是一个端口号，也可以由函数ftok生成。②msgflg如果等于IPC_CREAT，若没有该队列，则创建一个并返回新标识符，若已存在则返回原标识符；msgflg如果等于IPC_EXCL，若没有该队列，则返回-1；若已存在，则返回0</p></blockquote></blockquote><blockquote><blockquote><p>消息队列跟有名管道有不少的相同之处，消息队列进行通信的进程可以是不相关的进程，同时它们都是通过发送和接收的方式来传递数据的。在命名管道中，发送数据用write函数，接收数据用read函数，则在消息队列中，发送数据用msgsnd函数，接收数据用msgrcv函数。而且它们对每个数据都有一个最大长度的限制。与命名管道相比，消息队列的优势在于：①消息队列也可以独立于发送和接收进程而存在，从而消除了在同步命名管道的打开和关闭时可能产生的困难；②可以同时通过发送消息以避免命名管道的同步和阻塞问题，而不需要由进程自己来提供同步方法；③接收程序可以通过消息类型有选择地接收数据，而不是像命名管道中那样，只能默认地接收。事实上，它是一种正逐渐被淘汰的通信方式，完全可以用流管道或者套接口的方式来取代它，所以，建议读者忽略这种方式。</p></blockquote></blockquote><p>◆ 11.3 共享内存</p><blockquote><blockquote><p>共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种非常有效的方式。不同进程之间共享的内存通常安排在同一段物理内存中。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地</p></blockquote></blockquote><p>◆ 11.4 信号量</p><blockquote><blockquote><p>于多线程同步的方式中已经提及信号量，但用于多线程同步的信号量是POSIX信号量，而本节即将要展开的是SYSTEM V信号量，本质上说这两种都是用户态进程可以使用的信号量。SYSTEM V信号量，下面简称为信号量</p></blockquote></blockquote><p>◆ 11.5 ipcs命令</p><blockquote><blockquote><p>ipcs是一个UINX/Linux的命令，用于报告系统的消息队列、信号量、共享内存等。下面列举一些常用命令</p></blockquote></blockquote><p>◆ 12.1 HTTP协议工作流程</p><blockquote><blockquote><p>[插图]</p></blockquote></blockquote></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/worst0/wiki_note/edit/main/docs/99.other/A2.paste.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.f891d386.js"></script>
<script src="/assets/js/main.56ecaf81.js"></script>
</body>
</html>