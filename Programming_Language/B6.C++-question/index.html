<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Wiki Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Wiki Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">B6.C++-question | My Wiki</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://worst0.github.io/Programming_Language/B6.C++-question"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="B6.C++-question | My Wiki"><meta data-react-helmet="true" name="description" content="为什么两个不同对象的地址应该不同？"><meta data-react-helmet="true" property="og:description" content="为什么两个不同对象的地址应该不同？"><meta data-react-helmet="true" property="og:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://worst0.github.io/Programming_Language/B6.C++-question"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Programming_Language/B6.C++-question" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Programming_Language/B6.C++-question" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.fcc94c76.css">
<link rel="preload" href="/assets/js/runtime~main.76d09beb.js" as="script">
<link rel="preload" href="/assets/js/main.12911a5b.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">My Wiki</b></a><a class="navbar__item navbar__link navbar__link--active" href="/intro">Document💻</a><a class="navbar__item navbar__link" href="/blog">Blog🤓</a><a class="navbar__item navbar__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a><a class="navbar__item navbar__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>本站源码<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">🌙</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">My Wiki</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/intro">Document💻</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog🤓</a></li><li class="menu__list-item"><a class="menu__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a></li><li class="menu__list-item"><a class="menu__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></li><li class="menu__list-item"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="menu__list-item"><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="menu__link"><span>本站源码<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">intro</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/intro">intro</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">1.Linux</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Linux命令</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A1.linux基础">A1.linux基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A2.Linux命令">A2.Linux命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A3.编译环境">A3.编译环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A4.数据提取">A4.数据提取</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A5.Linux命令补充">A5.Linux命令补充</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">调试相关</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/D1.网络相关">D1.网络相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/D2.C-C++调试工具">D2.C-C++调试工具</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">shell脚本</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/B1.shell脚本语法">B1.shell脚本语法</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">ubuntu</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C1.ubuntu相关">C1.ubuntu相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C2.ubuntu常用软件">C2.ubuntu常用软件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C3.语言环境">C3.语言环境</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">2.Algorithm</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">数据结构</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A1.DataStructure">A1.DataStructure</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A2.数组和链表">A2.数组和链表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A3.栈和队列">栈,队列</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A4.堆和优先队列">A4.堆和优先队列</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A5.哈夫曼树">A5.哈夫曼树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A6.哈希表">A6.哈希表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.排序">A7.排序</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.树">A7.树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A8.字符串匹配">A8.字符串匹配</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.字典树">A10.字典树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.树状数组和线段树">A10.树状数组和线段树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.平衡树">A11.平衡树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.并查集">A11.并查集</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A12.图论">A12.图论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A15.位图和跳表">A15.位图和跳表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A99.实现ADT">A99.实现ADT</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">算法设计</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B1.算法分析">B1.算法分析</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B10.数论">B10.数论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B11.位运算">B11.位运算</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B12.计算几何">B12.计算几何</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B13.网络流">B13.网络流</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B2.贪心">B2.贪心</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B3.递推到递归">B3.递推到递归</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B4.动态规划">B4.动态规划</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B5.分治">B5.分治</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B6.减治和双指针">B6.减治和双指针</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B7.回溯">B7.回溯</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B8.搜索">B8.搜索</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B9.数学">B9.数学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B98.字符串">B98.字符串</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B99.专题">B99.专题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.Algorithm">C1.Algorithm</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.算法技巧">C1.算法技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C2.编程珠玑">C2.编程珠玑</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Think</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/D1.ACM模板">D1.ACM模板</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E1.concrete">E1.concrete</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E2.Combinatorics">E2.Combinatorics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/G1.逻辑思考">G1.逻辑思考</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/H1.算法谜题">H1.算法谜题</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">3.Online_Judge</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/A1.Leetcode">A1.Leetcode</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/B1.HZOJ">B1.HZOJ</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/C1.nowcoder">C1.nowcoder</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/D1.EP">D1.EP</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/E1.编程技巧">E1.编程技巧</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">4.Programming_Language</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">C</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A1.CBasic">A1.CBasic</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A2.Cimprove">A2.Cimprove</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A3.C语言技巧">A3.C语言技巧</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">C++</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Programming_Language/B1.C++-basic">B1.C++-basic</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Programming_Language/B2.C++-improve">B2.C++-improve</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Programming_Language/B3.C++-exercise">B3.C++-exercise</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Programming_Language/B4.C++-others">B4.C++-others</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Programming_Language/B5.C++编译">B5.C++编译</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/Programming_Language/B6.C++-question">B6.C++-question</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">STL</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C1.STL">C1.STL</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C2.STL-question">C2.STL-question</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="0">python</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/D1.python">D1.python</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/E1.conda">E1.conda</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">5.Programming_Stardard</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/A1.C编程规范">A1.C编程规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.编码英文缩写">B1.编码英文缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.计算机哲学">B1.计算机哲学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B2.英文标准缩写">B2.英文标准缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/C1.重构">C1.重构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/D1.Design_Pattern">D1.Design_Pattern</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">6.Operating_system</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A1.os">A1.os</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A2.OS概述">A2.OS概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A2.操作系统">A2.操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A3.进程与线程">A3.进程与线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A4.死锁">A4.死锁</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A5.存储管理">A5.存储管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A6.设备管理">A6.设备管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A7.文件系统">A7.文件系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A8.输入输出">A8.输入输出</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A9.编译系统">A9.编译系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/C1.计算机原理">C1.计算机原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/D1.CSAPP">D1.CSAPP</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">系统编程</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A1.os">A1.os</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">7.Network</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A2.网络概论">A2.网络概论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A3.物理层">A3.物理层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A4.链路层">A4.链路层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A5.网络层">A5.网络层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A6.传输层">A6.传输层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A7.应用层">A7.应用层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A9.疑问">A9.疑问</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/B1.HTTP">B1.HTTP</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">8.Server</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/A1.Linux高性能服务器">A1.Linux高性能服务器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/A2.概述">A2.概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.Linux多线程muduo">B1.Linux多线程muduo</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.系统编程">B1.系统编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B2.文件IO">B2.文件IO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B3.文件和目录">B3.文件和目录</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B4.标准IO库">B4.标准IO库</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B9.命令">B9.命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络API">C1.网络API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络编程">C1.网络编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C2.高级IO函数">C2.高级IO函数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C3.程序规范">C3.程序规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C4.IO复用">C4.IO复用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C5.信号">C5.信号</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C6.定时器">C6.定时器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C7.高性能服务器框架">C7.高性能服务器框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C8.socket">C8.socket</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C9.实现">C9.实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D1.多进程编程">D1.多进程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D2.进程">D2.进程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D3.进程控制">D3.进程控制</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D4.进程间通信">D4.进程间通信</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E1.多线程编程">E1.多线程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E2.线程">E2.线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/H1.网络工具">H1.网络工具</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">9.Database</a><ul class="menu__list"></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">10.Skill</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/A1.Latex数学公式">A1.Latex数学公式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/B1.Markdown语法">B1.Markdown语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C1.git">C1.git</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C2.github">C2.github</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/D1.计算机英语">D1.计算机英语</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/E1.绘图">E1.绘图</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">11.Interview</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/A1.面试">A1.面试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/A2.interview">A2.interview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/C1.简历">C1.简历</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">13.Project</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A1.Gtest测试框架">A1.Gtest测试框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A2.udp-football">A2.udp-football</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A3.Hython">A3.Hython</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/B1.项目面试">B1.项目面试</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">14.Science</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/E3.数学认识">E3.数学认识</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/F1.物理认识">F1.物理认识</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">99.other</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/A1.临时">A1.临时</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/B1.临时笔记">B1.临时笔记</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/C1.task">C1.task</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/D1.软件需求">D1.软件需求</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/E1.software">E1.software</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">C++-question</h1></header><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="为什么两个不同对象的地址应该不同"></a>为什么两个不同对象的地址应该不同？<a class="hash-link" href="#为什么两个不同对象的地址应该不同" title="Direct link to heading">#</a></h2><blockquote><p> 在同一地址具有两个对象将意味着在使用指针引用它们时将无法区分这两个对象</p></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">class</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">Empty</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">public</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">print</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">cout</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;&lt;</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;I am Empty class&quot;</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;&lt;</span><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">endl</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">template</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">typename</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">T</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">bool</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">isSame</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain"> T </span><span class="token keyword" style="font-style:italic">const</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&amp;</span><span class="token plain"> t1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> T </span><span class="token keyword" style="font-style:italic">const</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&amp;</span><span class="token plain"> t2 </span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&amp;</span><span class="token plain">t1 </span><span class="token operator" style="color:rgb(137, 221, 255)">==</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">&amp;</span><span class="token plain">t2</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">main</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Empty a</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain">b</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 在同一地址具有两个对象将意味着在使用指针引用它们时将无法区分这两个对象。</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">assert</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token function" style="color:rgb(130, 170, 255)">isSame</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">a</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain">b</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 编译通过，a与b的地址不同</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Empty </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">p</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> Empty</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Empty </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">q</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> Empty</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">assert</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">!</span><span class="token function" style="color:rgb(130, 170, 255)">isSame</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">p</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain">q</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 编译通过，a与b的地址不同</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ebo空基类优化"></a>EBO(空基类优化)<a class="hash-link" href="#ebo空基类优化" title="Direct link to heading">#</a></h2><blockquote><p>空基类优化,EBO简称Empty Base Optimization。
通过继承方式来获得基类的功能，并没有产生额外大小的优化称之为EBO(空基类优化)。</p></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//包含一个类作为成员</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">class</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">notEbo</span><span class="token plain">  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> i</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Empty e</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// do other things</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//直接采用继承</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">class</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">ebo</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token base-clause class-name" style="color:rgb(255, 203, 107)">public</span><span class="token base-clause"> </span><span class="token base-clause class-name" style="color:rgb(255, 203, 107)">Empty</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> i</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// do other things</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">cout</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;&lt;</span><span class="token keyword" style="font-style:italic">sizeof</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">notEbo</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;&lt;</span><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">endl</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">cout</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;&lt;</span><span class="token keyword" style="font-style:italic">sizeof</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">ebo</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;&lt;</span><span class="token plain">std</span><span class="token operator" style="color:rgb(137, 221, 255)">::</span><span class="token plain">endl</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">output </span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"> </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">8</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//第一种，会因为字节对齐，将其原来只占1字节，进行扩充到4的倍数，最后就是8字节。</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">4</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//第二种通过继承方式来获得基类的功能，并没有产生额外大小的优化称之为EBO(空基类优化)。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="extern-c的结果和cpp编译的区别"></a>extern-C的结果和CPP编译的区别<a class="hash-link" href="#extern-c的结果和cpp编译的区别" title="Direct link to heading">#</a></h2><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//p.c</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">include</span><span class="token macro property"> </span><span class="token macro property string" style="color:rgb(195, 232, 141)">&lt;stdio.h&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">print</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> a</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> b</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">       </span><span class="token function" style="color:rgb(130, 170, 255)">printf</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;这里调用的是C语言的函数:%d,%d\n&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain">a</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain">b</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//p.h</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">ifndef</span><span class="token macro property"> </span><span class="token macro property expression">_P_H</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">define</span><span class="token macro property"> </span><span class="token macro property macro-name">_P_H</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">print</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> a</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> b</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">endif</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//main</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">include</span><span class="token macro property"> </span><span class="token macro property string" style="color:rgb(195, 232, 141)">&lt;iostream&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">using</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">namespace</span><span class="token plain"> std</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">include</span><span class="token macro property"> </span><span class="token macro property string" style="color:rgb(195, 232, 141)">&quot;p.h&quot;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">main</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">       cout</span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;&lt;</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;现在调用C语言函数\n&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">       </span><span class="token function" style="color:rgb(130, 170, 255)">print</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">3</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token number" style="color:rgb(247, 140, 108)">4</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">       </span><span class="token keyword" style="font-style:italic">return</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><p>编译后链接出错：main.cpp对print(int, int)未定义的引用。</p></li><li><p>原因分析</p><ul><li>p.c我们使用的是C语言的编译器gcc进行编译的，其中的函数print编译之后，在符号表中的名字为 <code>_print</code></li><li>我们链接的时候采用的是g++进行链接，也就是C++链接方式，程序在运行到调用print函数的代码时，会在符号表中寻找<code>_print_int_int</code>（是按照C++的链接方法来寻找的，所以是找<code>_print_int_int</code>而不是找<code>_print</code>）的名字，发现找不到，所以会t提示“未定义的引用”</li><li>此时如果我们在对print的声明中加入 extern “C” ，这个时候，g++编译器就会按照C语言的链接方式进行寻找，也就是在符号表中寻找<code>_print</code>，这个时候是可以找到的，是不会报错的。</li></ul></li><li><p>总结</p><ul><li>编译后底层解析的符号不同，C语言是<code>_print</code>，C++是<code>_print_int_int</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="重载的底层原理"></a>重载的底层原理<a class="hash-link" href="#重载的底层原理" title="Direct link to heading">#</a></h2><p>只有C++才有函数重载，因为函数重载通过参数列表的不同来实现。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token string" style="color:rgb(195, 232, 141)">&quot;int __cdecl Add(int,int)&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">?</span><span class="token plain">Add@@YAHHH@Z</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token string" style="color:rgb(195, 232, 141)">&quot;double __cdecl Add(double,double)&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">?</span><span class="token plain">Add@@YANNN@Z）</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token string" style="color:rgb(195, 232, 141)">&quot;long __cdecl Add(long,long)&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">?</span><span class="token plain">Add@@YAJJJ@Z</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在C语言中被解析为_Add，三个一样，所以不能进行区分，因此C语言不支持函数重载</p><ul><li><p>C++重载
底层的重命名机制将Add函数根据参数的个数，参数的类型，返回值的类型都做了重新命名。那么借助函数重载，一个函数就有多种命名机制。 <code>_Add_int_int</code>，<code>_Add_long_long</code>，<code>_Add_double_double</code></p></li><li><p>C++中可以通过在函数声明前加 extern &quot;C&quot; 将一个函数按照 C 语言的风格来进行编译。</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="编译性语言和解释性语言的本质区别和优缺点"></a>编译性语言和解释性语言的本质区别和优缺点<a class="hash-link" href="#编译性语言和解释性语言的本质区别和优缺点" title="Direct link to heading">#</a></h2><ul><li><p>根本区别</p><ul><li>计算机不能直接的理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言的编写的程序。翻译的方式有两种，一个是编译，一个是解释。<strong>两种方式只是翻译的时间不同</strong>。</li><li>解释性语言不用编译，在运行时翻译</li><li>编译性语言是编译的时候直接编译成机器可以执行的语言，编译和运行是分开的，但是不能跨平台。比如exe文件，以后要运行的话就不用重新编译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行的时不要翻译，所以编译型语言的程序执行效率高</li></ul></li><li><p>编译性语言的优缺点</p><ul><li>优点<ul><li>运行速度快，代码效率高，编译后程序不可以修改，保密性好</li></ul></li><li>缺点<ul><li>代码需要经过编译方可运行，可移植性差，只能在兼容的操作系统上运行。</li></ul></li></ul></li><li><p>解释性语言的优缺点</p><ul><li>优点<ul><li>可移植性好，只要有解释环境，可以在不同的操作系统上运行。</li></ul></li><li>缺点<ul><li>运行需要解释环境，运行起来比编译的要慢，占用的资源也要多一些，代码效率低，代码修改后就可以运行，不需要编译过程</li></ul></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="c中class和struct的区别"></a>C++中class和struct的区别<a class="hash-link" href="#c中class和struct的区别" title="Direct link to heading">#</a></h2><p>C中的strcut不能有函数，但C++中可以。C++中的struct对C中的struct进行了扩充，它已经不再只是一个包含不同数据类型的数据结构了，它已经获取了太多的功能。struct能包含成员函数吗？ 能！struct能继承吗？ 能！！struct能实现多态吗？ 能！！！</p><blockquote><ul><li><strong>默认的继承访问权限.</strong> struct是public的，class是private的
class B : public A就是为了指明是public继承，而不是用默认的private继承，若class B : A则是private继承</li><li><strong>定义模板参数.</strong> class这个关键字还用于定义模板参数，就像typename。但关键字struct不用于定义模板参数。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="newdelete和mallocfree区别"></a>new/delete和malloc/free区别<a class="hash-link" href="#newdelete和mallocfree区别" title="Direct link to heading">#</a></h2><p>malloc和calloc间的主要区别在于后者在返回指向内存的指针之前把它初始化为0。另一个区别是calloc的参数包括所需的元素的数量和每个元素的字节数</p><ul><li><p><strong>属性不同.</strong> new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c</p></li><li><p><strong>申请的内存所在位置.</strong> new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存.</p></li><li><p><strong>返回类型安全性.</strong> new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。
而malloc内存分配成功则是返回void*类型，需要通过强制类型转换将空类型指针转换成我们需要的类型。</p></li><li><p><strong>内存分配失败时的返回值.</strong> new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p></li><li><p><strong>是否需要指定内存大小.</strong> 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的大小</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">pi</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//在自由存储区中分配创建了一个整形对象，并返回一个指向该对象的地址来初始化指针pi。</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">pi</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//对指针pi指向的地址的值进行了初始化为0</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">pi</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">1024</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//初始化为1024。</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">p</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token function" style="color:rgb(130, 170, 255)">malloc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">100</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//指向整型的指针p指向一个大小为100字节的内存的地址</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">p</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token function" style="color:rgb(130, 170, 255)">malloc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">25</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token keyword" style="font-style:italic">sizeof</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">int</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//指向整型的指针p指向一个25个int整型空间的地址</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ul><ul><li><p><strong>数组分配内存（与前一个特点类似）.</strong> new中分配内存对于变量和数组不同，malloc分配内存则相同</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">pi</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//指针pi所指向的数组未初始化</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">pi</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">n</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//指针pi指向长度为n的数组，未初始化</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">pi</span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token keyword" style="font-style:italic">new</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain">  </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//指针pi所指向的地址初始化为0</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div></li></ul><ul><li><p><strong>是否调用构造函数/析构函数.</strong>   new会先调用operator<em> new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator</em> delete函数释放内存（通常底层使用free实现）。malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。 </p></li><li><p><strong>能否重载.</strong> opeartor_new/operator_delete允许重载,malloc/free不允许重载</p></li><li><p><strong>已分配内存的扩充.</strong> malloc/free可以通过realloc函数扩充，new/free无法直观地处理</p></li><li><p><strong>能否相互调用.</strong> operator_new /operator _delete的实现可以基于malloc/free，而malloc的实现不可以去调用new。</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="new运算符的原理"></a>new运算符的原理<a class="hash-link" href="#new运算符的原理" title="Direct link to heading">#</a></h2><ul><li><p>内存分配</p><ul><li>调用相应的  operator new(size_t) 函数，动态分配内存。如果 operator new(size_t) 不能成功获得内存，则调用 new_handler()函数用于处理new失败问题。如果没有设置 new_handler() 函数或者 new_handler() 未能分配足够内存，则抛出 std::bad_alloc 异常</li></ul></li><li><p>构造函数</p><ul><li>在分配到的动态内存块上 初始化相应类型的对象（构造函数）并返回其首地址。如果调用构造函数初始化对象时抛出异常，则自动调用 operator delete(void<em>, void</em>) 函数释放已经分配到的内存。</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="malloc的内存分配机制"></a>malloc的内存分配机制<a class="hash-link" href="#malloc的内存分配机制" title="Direct link to heading">#</a></h2><p>malloc内存分配机制是怎么样的,在哪里分配内存，最大可以申请多大的内存？</p><blockquote><ul><li>首先会扫描之前由free()所释放的空闲内存块列表，以求找到尺寸大于或等于要求的一块空闲内存。如果这一内存块的尺寸正好与要求相当，就将它返回给调用者，如果是一块较大的内存，那么将对其进行分割，在将一块大小相当的内存返回给调用者的同时，把较小的那块空闲内存块保留在空闲列表中</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="栈和堆的区别"></a>栈和堆的区别<a class="hash-link" href="#栈和堆的区别" title="Direct link to heading">#</a></h2><ul><li><p>管理方式不同</p><ul><li>对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</li></ul></li><li><p>空间大小不同</p><ul><li>一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M</li></ul></li><li><p>能否产生碎片不同</p><ul><li>对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出</li></ul></li><li><p>生长方向不同</p><ul><li>对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长</li></ul></li><li><p>栈是连续的存储空间，堆内存空间不连续</p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="面向对象和面向过程的区别"></a>面向对象和面向过程的区别<a class="hash-link" href="#面向对象和面向过程的区别" title="Direct link to heading">#</a></h2><p>面向对象就是高度实物抽象化、面向过程就是自顶向下的编程</p><ul><li>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用</li><li>面向对象是把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li><li>面向过程的优缺点<ol><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ol></li><li>面向对象的优缺点<ol><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 </li><li>缺点：性能比面向过程低</li></ol></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="const关键字不可修改"></a>const关键字(不可修改)<a class="hash-link" href="#const关键字不可修改" title="Direct link to heading">#</a></h2><ul><li>修饰变量，说明该变量不可以被改变；全局变量，类成员变量就地初始化，mutable修改</li><li>修饰指针，分为指向常量的指针和指针常量；int <em>const p和const int </em>p</li><li>常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；</li><li>修饰成员函数，说明该成员函数内不能修改成员变量，本质是const this指针。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="static关键字对外不可见"></a>static关键字(对外不可见)<a class="hash-link" href="#static关键字对外不可见" title="Direct link to heading">#</a></h2><ul><li><strong>修饰普通变量，</strong> 修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，在整个程序运行期间一直存在，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它，自动初始化为0。
全局变量作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
局部变量作用域：仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变； </li><li><strong>修饰普通函数，</strong> 其只能在定义它的源文件中使用，不能在其他源文件中被引用</li><li><strong>修饰类成员变量和成员函数，</strong> 它们是属于类的，而不是某个对象，所有对象共享一个静态成员。静态成员通过&lt;类名&gt;::&lt;静态成员&gt;来使用。在 static 函数内不能访问非静态成员</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="extern关键字"></a>extern关键字<a class="hash-link" href="#extern关键字" title="Direct link to heading">#</a></h2><p>extern关键字主要修饰变量或函数，表示该函数可以跨文件访问，或者表明该变量在其他文件定义，在此处引用.</p><blockquote><ul><li><strong>修饰变量或函数.</strong>被 extern 限定的函数或变量是 extern 类型的</li><li><strong>extern &quot;C&quot;.</strong> extern &quot;C&quot; 的作用是让 C++ 编译器将 extern &quot;C&quot; 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。</li></ul><ol><li>在c头文件中通过#ifdef __cplusplus  extern &quot;C&quot;  { #endif来定义</li><li>在对应的c文件中实现</li><li>在cpp文件中通过“extern &quot;C&quot; 函数名”调用，或者包含c头文件
<strong>注意：</strong> extern的引用方式比包含头文件要简洁得多！extern的使用方法是直接了当的，想引用哪个函数就用extern声明哪个函数。这样做的一个明显的好处是，会加速程序的编译（确切的说是预处理）的过程，节省时间，但若需要调用的函数太多，还是直接包含头文件吧.</li></ol></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="volatile关键字"></a>volatile关键字<a class="hash-link" href="#volatile关键字" title="Direct link to heading">#</a></h2><blockquote><ul><li><strong>不可优化性.</strong> volatile 关键字是一种类型修饰符，用它声明的类型变量表示不可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。</li><li><strong>易变性.</strong> volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="explicit关键字"></a>explicit关键字<a class="hash-link" href="#explicit关键字" title="Direct link to heading">#</a></h2><p>explicit关键字的作用就是防止对象间实现=赋值，防止类构造函数的隐式自动转换,类构造函数默认情况下即声明为implicit(隐式)，另外explicit只用于单参数的构造函数，或者除了第一个参数以外的其他参数都有默认值.</p><blockquote><ul><li>explicit 修饰构造函数时，可以防止隐式转换和复制初始化</li><li>explicit 修饰转换函数时，可以防止隐式转换</li></ul></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><pre tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token keyword" style="font-style:italic">class</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">Person</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">public</span><span class="token operator" style="color:rgb(137, 221, 255)">:</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token function" style="color:rgb(130, 170, 255)">Person</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//有参构造初始化数据</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">explicit</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">Person</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">const</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">char</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">str_</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        str </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">char</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token function" style="color:rgb(130, 170, 255)">malloc</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">sizeof</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">char</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token number" style="color:rgb(247, 140, 108)">100</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><span class="token function" style="color:rgb(130, 170, 255)">strcpy</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">str</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain">str_</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token operator" style="color:rgb(137, 221, 255)">~</span><span class="token function" style="color:rgb(130, 170, 255)">Person</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><span class="token keyword" style="font-style:italic">if</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">str </span><span class="token operator" style="color:rgb(137, 221, 255)">!=</span><span class="token plain"> </span><span class="token constant" style="color:rgb(130, 170, 255)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            </span><span class="token function" style="color:rgb(130, 170, 255)">free</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">str</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">            str </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token constant" style="color:rgb(130, 170, 255)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token keyword" style="font-style:italic">char</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">str</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">test05</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//Person p = &quot;abc&quot;; 隐式调用</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Person </span><span class="token function" style="color:rgb(130, 170, 255)">p</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token string" style="color:rgb(195, 232, 141)">&quot;abc&quot;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"> </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//显式调用</span><span class="token plain"></span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="类成员属性"></a>类成员属性<a class="hash-link" href="#类成员属性" title="Direct link to heading">#</a></h2><p>类的成员有三个权限：公有权限（public），私有权限（private），保护权限（protected）。</p><blockquote><ul><li><strong>私有权限.</strong> 私有成员在类内部可以访问，类外不可访问，一般推荐将成员变量设置为私有成员；</li><li><strong>公有权限.</strong> 类内类外都可以进行访问；</li><li><strong>保护权限.</strong> 类内和当前类的子类可以访问，类外不可访问。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="大小端序的定义和代码判断"></a>大小端序的定义和代码判断<a class="hash-link" href="#大小端序的定义和代码判断" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="定义"></a>定义<a class="hash-link" href="#定义" title="Direct link to heading">#</a></h3><p>一个16进制的地址，存放在内存中从低地址开始存储，如16进制的地址为0x1234，对于地址而言，从右往左是从低到高</p><ul><li>大端<ul><li>若16进制的高地址存放在内存的低地址，则为大端字节序，34存储在高位，12存储在低位</li></ul></li><li>小端<ul><li>若16进制的低地址存放在内存的低地址，则为小端字节序，12存储在高位，34存储在高位</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="代码判断"></a>代码判断<a class="hash-link" href="#代码判断" title="Direct link to heading">#</a></h3><p>可以通过联合体来判断，联合体是同一块内存被联合体中的所有成员公用，如果后续成员对内存重新赋值，会覆盖内存中原有数据</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">union U{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int a;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    char b;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    U u;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    u.a = 0x01020304;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    if (u.b == 0x04){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; u.b &lt;&lt; endl; //输出char字符</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;little&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    else if (u.b == 0x01){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; u.b &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;big&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    system(&quot;pause&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="代码判断32位和64位系统"></a>代码判断32位和64位系统<a class="hash-link" href="#代码判断32位和64位系统" title="Direct link to heading">#</a></h2><p>写一个指针，输出指针所占的字节大小</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="内存字节对齐"></a>内存字节对齐<a class="hash-link" href="#内存字节对齐" title="Direct link to heading">#</a></h2><p><strong>不要以为只有C/C++才会有内存对齐，只要可以跨平台的编程语言都需要做内存对齐，Java、Python都是一样的</strong>。</p><blockquote><ul><li><code>#pragma pack(n)</code> 表示的是设置n字节对齐,windows默认是8，linux是4</li></ul></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">struct A{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    char a;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int b;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    short c;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><blockquote><ul><li>char占一个字节，起始偏移为零，int占四个字节，min(8,4)=4；所以应该偏移量为4，所以应该在char后面加上三个字节，不存放任何东西，short占两个字节，min(8,2)=2;所以偏移量是2的倍数，而short偏移量是8，是2的倍数，所以无需添加任何字节，所以第一个规则对齐之后内存状态为0xxx|0000|00    </li><li>此时一共占了10个字节，但是还有结构体本身的对齐，min(8,4)=4；所以总体应该是4的倍数，所以还需要添加两个字节在最后面，所以内存存储状态变为了 0xxx|0000|00xx，一共占据了12个字节</li></ul></blockquote><ul><li><p>内存对齐规则</p><ul><li>对于结构的各个成员，第一个成员位于偏移为0的位置，以后的每个数据成员的偏移量必须是  min(#pragma pack()指定的数,这个数据成员的自身长度)的倍数</li><li>在所有的数据成员完成各自对齐之后，结构或联合体本身也要进行对齐，对齐将按照 #pragam pack指定的数值和结构或者联合体最大数据成员长度中比较小的那个，也就是  min(#pragram pack() , 长度最长的数据成员)</li></ul></li><li><p>需要对齐的原因</p><ul><li>平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常</li><li>硬件原因：经过内存对齐之后，CPU的内存访问速度大大提升。访问未对齐的内存，处理器要访问两次（数据先读高位，再读低位），访问对齐的内存，处理器只要访问一次，为了提高处理器读取数据的效率，我们使用内存对齐</li></ul></li></ul><p>CPU读取内存不是一次读取单个字节，而是一块一块的来读取内存，块的大小可以是2，4，8，16个字节，具体取多少个字节取决于硬件。</p><p>设CPU把内存划分为4字节大小的块，要读取一个4字节大小的int型数据，</p><p>第一种就是内存对齐的情况，如图：</p><p><img alt="内存对齐" src="/assets/images/20200804193307347-590d0a031f49bc0a09a3e6caaac6e045.png"></p><p>一字节的char占用了四个字节，空了三个字节的内存地址，int数据从地址4开始。</p><p>此时，直接将地址4，5，6，7处的四个字节数据读取到即可。</p><p>第二种是没有内存对齐的情况如图：</p><p><img alt="非内存对齐" src="/assets/images/20200804193353926-ba97551c593c84065d5f9f63eedbca14.png"></p><p>char型的数据和int型的数据挨在一起，该int数据从地址1开始，那么CPU想要读这个数据的话来看看需要几步操作：</p><ol><li>因为CPU是四个字节四个字节来寻址，首先CPU读取0，1，2，3处的四个字节数据</li><li>CPU读取4，5，6，7处的四个字节数据</li><li>合并地址1，2，3，4处四个字节的数据才是本次操作需要的int数据</li></ol><p>此时一共需要两次寻址，一次合并的操作。</p><p><strong>编译器一般都会做内存对齐的优化操作，也就是说当考虑程序真正占用的内存大小的时候，也需要认识到内存对齐的影响</strong>。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="面向对象三大特性"></a>面向对象三大特性<a class="hash-link" href="#面向对象三大特性" title="Direct link to heading">#</a></h2><p>通过类创建一个对象的过程叫实例化，实例化后使用对象可以调用类成员函数和成员变量，其中类成员函数称为行为，类成员变量称为属性。类和对象的关系：类是对象的抽象，对象是类的实例</p><ul><li>封装<ul><li>把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</li><li>public，private，protected</li></ul></li><li>继承<ul><li>基类（父类）——&gt; 派生类（子类）</li></ul></li><li>多态</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="双冒号using和namespace"></a>双冒号、using和namespace<a class="hash-link" href="#双冒号using和namespace" title="Direct link to heading">#</a></h2><ul><li><p>namespace主要用来解决命名冲突的问题</p><ul><li>必须在全局作用域下声明</li><li>命名空间下可以放函数，变量、结构体和类</li><li>命名空间可以嵌套命名空间</li><li>命名空间是开放的，可以随时加入新成员（添加时只需要再次声明namespace，然后添加新成员即可</li></ul></li><li><p>双冒号::作用域运算符</p><ul><li>全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间</li><li>类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的</li><li>命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的</li></ul></li><li><p>using分为using声明和using编译指令</p><ul><li><code>using std::cout; //声明</code></li><li><code>using namespace std; //编译指令</code></li><li>尽量使用声明而不是编译指令，不同命名空间中可能会有相同的变量名，编译指令执行两个命名空间后，会产生二义性</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="内联函数和函数重载"></a>内联函数和函数重载<a class="hash-link" href="#内联函数和函数重载" title="Direct link to heading">#</a></h2><ul><li><p>内联函数</p><ul><li>相当于把内联函数里面的内容写在调用内联函数处；</li><li>相当于不用执行进入函数的步骤，直接执行函数体；</li><li>相当于宏，却比宏多了类型检查，真正具有函数特性；</li><li>不能包含循环、递归、switch 等复杂操作；</li><li>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数，内联函数对于编译器而言只是一个建议，编译器不一定会接受这种建议，即使没有声明内联函数，编译器可能也会内联一些小的简单的函数。</li></ul></li><li><p>C++的函数名称可以重复，称为函数重载。</p><ul><li>其中必须在同一作用域下的函数名称相同，不能是一个在全局，一个局部，或者不同的代码块中</li><li>可以根据函数参数的个数、类型（const也可以作为重载条件）、顺序不同进行函数重载，但<strong>不能用函数返回值进行重载</strong></li><li>当函数重载遇到函数默认参数时，要注意二义性。</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚函数可以是内联函数吗"></a>虚函数可以是内联函数吗<a class="hash-link" href="#虚函数可以是内联函数吗" title="Direct link to heading">#</a></h2><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="拷贝构造函数与深浅拷贝"></a>拷贝构造函数与深浅拷贝<a class="hash-link" href="#拷贝构造函数与深浅拷贝" title="Direct link to heading">#</a></h2><p>拷贝构造函数的参数必须加const，因为防止修改，本来就是用现有的对象初始化新的对象。</p><ul><li>拷贝构造函数的使用时机<ul><li>使用已经创建好的对象初始化新对象 <code>A a; A b = a; A c(a); b = c;//b = c不是初始化，调用赋值运算符 </code></li><li>以值传递的方式来给函数参数传值</li><li>以值方式返回局部对象（不常用，一般不返回局部对象） </li></ul></li></ul><ul><li>深拷贝和浅拷贝
只有当对象的成员属性在堆区开辟空间内存时，才会涉及深浅拷贝，如果仅仅是在栈区开辟内存，则默认的拷贝构造函数和析构函数就可以满足要求。<ul><li><strong>浅拷贝</strong>：使用默认拷贝构造函数，拷贝过程中是按字节复制的，对于指针型成员变量只复制指针本身，而不复制指针所指向的目标，因此涉及堆区开辟内存时，会将两个成员属性指向相同的内存空间，从而在释放时导致内存空间被多次释放，使得程序down掉。</li><li><strong>浅拷贝的问题</strong>：当出现类的等号赋值时，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的。但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次free函数，指向的内存空间已经被释放掉，再次free会报错；另外，一片空间被两个不同的子对象共享了，只要其中的一个子对象改变了其中的值，那另一个对象的值也跟着改变了所以，这时，必须采用深拷贝 </li><li><strong>深拷贝</strong>：自定义拷贝构造函数，在堆内存中另外申请空间来储存数据，从而解决指针悬挂的问题。<strong>需要注意自定义析构函数中应该释放掉申请的内存</strong> </li></ul></li></ul><p>我们在定义类或者结构体，这些结构的时候，最后都重写拷贝函数，避免浅拷贝这类不易发现但后果严重的错误产生</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="只在堆上栈上创建对象"></a>只在堆上/栈上创建对象<a class="hash-link" href="#只在堆上栈上创建对象" title="Direct link to heading">#</a></h2><blockquote><ul><li><strong>只能在堆上生成对象：将析构函数设置为私有。</strong>
原因：C++是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</li><li><strong>只能在栈上生成对象：将new 和 delete 重载为私有。</strong>
原因：在堆上生成对象，使用new关键词操作，其过程分为两阶段：第一阶段，使用new在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。
将new操作设置为私有，那么第一阶段就无法完成，就不能够再堆上生成对象。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="this指针"></a>this指针<a class="hash-link" href="#this指针" title="Direct link to heading">#</a></h2><ul><li><strong>为什么会有this指针</strong>
在类实例化对象时，只有非静态成员变量属于对象本身，剩余的静态成员变量，静态函数，非静态函数都不属于对象本身，因此非静态成员函数只会实例一份，多个同类型对象会共用一块代码，由于类中每个实例后的对象都有独一无二的地址，因此不同的实例对象调用成员函数时，函数需要知道是谁在调用它，因此引入了this指针。</li><li><strong>this指针的作用</strong>
this指针是隐含在对象成员函数内的一种指针。当一个对象被创建后，它的每一个成员函数都会含有一个系统自动生成的隐含指针this。this指针指向被调用的成员函数所属的对象（谁调用成员函数，this指向谁），*this表示对象本身，<strong>非静态成员函数中才有this，静态成员函数内部没有</strong>。<ul><li>this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 &amp;this）。</li><li>对非静态成员函数默认添加了this指针，类型为classname *const this</li></ul></li><li><strong>this指针使用</strong><ul><li>当形参与成员变量名相同时，用this指针来区分</li><li>为实现对象的链式引用，在类的非静态成员函数中返回对象本身，可以用return <em>this，this指向对象，/</em>this表示对象本身。 </li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="常函数和常对象"></a>常函数和常对象<a class="hash-link" href="#常函数和常对象" title="Direct link to heading">#</a></h2><p><code> void func() const //常函数，此处func为类成员函数</code>
<code> const Person p2; //常对象</code></p><ul><li>常函数修饰的是this指针，不允许修改this指针指向的值，如果执意要修改常函数，可以在成员属性前加<strong>mutable</strong>。</li><li>常对象不允许修改属性，不可以调用普通成员函数，可以调用常函数。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="delete-this合法吗"></a>delete this合法吗<a class="hash-link" href="#delete-this合法吗" title="Direct link to heading">#</a></h2><p>合法，但有前提：</p><ul><li>必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的</li><li>必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 delete this 后面没有调用 this 了</li><li>必须保证 delete this 后没有人使用了</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="为什么空类大小不为0"></a>为什么空类大小不为0<a class="hash-link" href="#为什么空类大小不为0" title="Direct link to heading">#</a></h2><p>sizeof(空class) = 1，为了确保两个不同对象的地址不同。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="静态成员变量与静态成员函数"></a>静态成员变量与静态成员函数<a class="hash-link" href="#静态成员变量与静态成员函数" title="Direct link to heading">#</a></h2><p>若将成员变量声明为static，则为静态成员变量，与一般的成员变量不同，无论建立多少对象，都只有一个静态成员变量的拷贝，静态成员变量属于一个类，所有对象共享。静态变量在编译阶段就分配了空间，对象还没创建时就已经分配了空间，放到全局静态区。</p><ul><li>静态成员变量<ul><li>最好是类内声明，类外初始化（以免类名访问静态成员访问不到）</li><li>无论公有，私有，静态成员都可以在类外定义，但私有成员仍有访问权限</li><li>非静态成员类外不能初始化</li><li>静态成员数据是共享的。 </li></ul></li><li>静态成员函数<ul><li>静态成员函数可以直接访问静态成员变量，不能直接访问普通成员变量，但可以通过参数传递的方式访问</li><li>普通成员函数可以访问普通成员变量，也可以访问静态成员变量</li><li>静态成员函数没有this指针。非静态数据成员为对象单独维护，但静态成员函数为共享函数，无法区分是哪个对象，因此不能直接访问普通变量成员，也没有this指针。</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="初始化列表的好处和使用条件"></a>初始化列表的好处和使用条件<a class="hash-link" href="#初始化列表的好处和使用条件" title="Direct link to heading">#</a></h2><ul><li>初始化列表的使用条件<ul><li>const类型的数据</li><li>引用类型的数据</li></ul></li><li>好处<ul><li>初始化是直接初始化成员</li><li>赋值是初始化再赋值</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="能否通过初始化列表初始化静态成员变量"></a>能否通过初始化列表初始化静态成员变量<a class="hash-link" href="#能否通过初始化列表初始化静态成员变量" title="Direct link to heading">#</a></h2><p>不能，静态成员变量最好类内声明，类外初始化.静态成员是单独存储的，并不是对象的组成部分。如果在类的内部进行定义，在建立多个对象时会多次声明和定义该变量的存储位置。在名字空间和作用域相同的情况下会导致重名的问题。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="友元全局函数友元类友元成员函数"></a>友元全局函数、友元类、友元成员函数<a class="hash-link" href="#友元全局函数友元类友元成员函数" title="Direct link to heading">#</a></h2><p>友元主要是为了访问类中的私有成员（包括属性和方法），会破坏C++的封装性，尽量不使用</p><ul><li><p>友元全局函数</p><ul><li>友元函数声明可以在类中的任何地方，一般放在类定义的开始或结尾</li><li>一个函数可以是多个类的友元函数，只需要在各个类中分别声明</li><li>友元函数在类内声明，类外定义，定义和使用时不需加作用域和类名，与普通函数无异。 </li></ul></li><li><p>友元类</p><ul><li>友元不可继承</li><li>友元是单向的，类A是类B的友元类，但类B不一定是类A的</li><li>友元不具有传递性，类A是类B的友元类，类B是类C的友元类，但类A不一定是类C的友元类。</li></ul></li><li><p>友元成员函数</p><ul><li>使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="运算符重载及重载实现"></a>运算符重载及++重载实现<a class="hash-link" href="#运算符重载及重载实现" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="运算符重载基本属性"></a>运算符重载基本属性<a class="hash-link" href="#运算符重载基本属性" title="Direct link to heading">#</a></h3><ul><li>运算符重载的目的是扩展C++中提供的运算符的适用范围，使之能作用于对象，或自定义的数据类型</li><li>运算符重载的实质是函数重载，可以重载为普通成员函数，也可以重载为成员函数</li><li>运算符重载也是多态的一种，和函数重载称为静态多态，表示函数地址早绑定，在编译阶段就确定好了地址</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="运算符重载总结"></a>运算符重载总结<a class="hash-link" href="#运算符重载总结" title="Direct link to heading">#</a></h3><ul><li>重载运算符()，[] ，-&gt;， =的时候，运算符重载函数必须声明为类的成员函数</li><li>重载运算符&lt;&lt;，&gt;&gt;的时候，运算符只能通过全局函数配合友元函数进行重载</li><li>不要重载&amp;&amp;和||运算符，因为无法实现短路原则。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="i和i实现"></a>i++和++i实现<a class="hash-link" href="#i和i实现" title="Direct link to heading">#</a></h3><p>C++内置类型的后置++返回的是变量的拷贝，也就是不可修改的值；前置++返回的是变量的引用，因此可以作为修改的左值。即++（++a）或（++a）++都可以，但++（a++）不可以，（C++默认必须修改a的值，如果不修改则报错）。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">//++i</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int&amp;  int::operator++()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    *this +=1；</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return *this；</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//i++，注意后置++有占位参数以区分跟前置++不同</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const int  int::operator++(int)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int oldValue = *this；</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ++（*this）；</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return oldValue；</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="继承方式对象模型同名处理"></a>继承方式、对象模型、同名处理<a class="hash-link" href="#继承方式对象模型同名处理" title="Direct link to heading">#</a></h2><p>继承主要是为了减少代码的重复内容，解决代码复用问题。通过抽象出一个基类（父类），将重复代码写到基类中，在派生类（子类）中实现不同的方法。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="继承方式"></a>继承方式<a class="hash-link" href="#继承方式" title="Direct link to heading">#</a></h3><ul><li>公有继承：保持父类中的访问属性</li><li>私有继承：将父类中的所有访问属性改为private</li><li>保护继承：除父类中的私有属性，其他改为保护属性</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="继承的对象模型"></a>继承的对象模型<a class="hash-link" href="#继承的对象模型" title="Direct link to heading">#</a></h3><ul><li>子类中会继承父类的私有成员，只是被编译器隐藏起来了，无法访问到，通过sizeof(子类class)可以检查出。</li><li>子类创建对象时，先调用父类的构造函数，然后再调用自身的构造，析构顺序与构造顺序相反<ul><li>由于继承中父类和子类的构造、析构顺序原因，当父类中只提供了有参构造（默认构造等函数会被隐藏），而子类仅仅调用默认构造时，会因为子类创建对象时无法调用父类构造函数而报错，这里可以让子类利用初始化列表来显式调用父类有参构造函数来进行父类构造，然后进行子类构造。 </li></ul></li><li>子类会继承父类的成员属性和成员函数，但子类不会继承父类构造函数和析构函数</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="继承中的同名处理"></a>继承中的同名处理<a class="hash-link" href="#继承中的同名处理" title="Direct link to heading">#</a></h3><ul><li>父类和子类<strong>成员属性</strong>同名，用子类声明对象调用子类属性，若想调用父类成员，则加上父类的作用域</li><li>父类和子类<strong>成员函数</strong>同名，子类函数不会覆盖父类的成员，只是隐藏起来，用子类声明对象调用子类成员函数，若想调用父类函数（包括重载），则加上父类的作用域</li><li>若子类中没有与父类同名的成员函数，子类声明对象后，可以直接调用父类成员函数。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多继承和菱形继承"></a>多继承和菱形继承<a class="hash-link" href="#多继承和菱形继承" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多继承"></a>多继承<a class="hash-link" href="#多继承" title="Direct link to heading">#</a></h3><p>多继承会产生二义性的问题。如果继承的多个父类中有同名的成员属性和成员函数，在子类调用时，需要指定作用域从而确定父类。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="菱形继承"></a>菱形继承<a class="hash-link" href="#菱形继承" title="Direct link to heading">#</a></h3><p>两个子类继承于同一个父类，同时又有另外一个类多继承于两个子类，这种继承称为菱形继承。比如羊和驼继承于动物类，同时羊驼继承于羊和驼。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="菱形继承会产生问题"></a>菱形继承会产生问题<a class="hash-link" href="#菱形继承会产生问题" title="Direct link to heading">#</a></h4><ul><li><p><strong>浪费空间。</strong>羊驼继承了两份动物类中的某些数据和函数，但只需要一份即可</p></li><li><p><strong>二义性。从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题。</strong> 羊驼调用数据和函数时，会出现二义性，通过sheep类得到一个age，通过carmel类得到一个age，两个数据不会相互影响，相互修改，导致同一份数据不一致。</p></li><li><p>所谓的虚继承，产生的是一种地址拷贝，而不是空间拷贝
来源于父母的空间，只有一份，这份是从祖先基类继承下来的，
自然没有父母空间，也就无法访问；</p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="解决菱形继承的问题"></a>解决菱形继承的问题<a class="hash-link" href="#解决菱形继承的问题" title="Direct link to heading">#</a></h4><p>使用虚继承，在<strong>继承方式前加virtual</strong>，这样的话羊驼可以直接访问m_Age，不用添加作用域，且这样操作的是共享的一份数据</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_Age;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Sheep:virtual public Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_sheep;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Camel :virtual public Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_camel;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Son :public Sheep, public Camel{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_son</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void test01(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Son son;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    son.m_Age = 10;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; //m_Age</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  //sheep-Vbptr,m_sheep,m_Age</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  //camel-Vbptr,m_camel,m_Age</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    //sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,m_son,m_Age</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img src="https://github.com/twomonkeyclub/BackEnd/blob/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/utils/%E5%A4%9A%E8%99%9A%E7%BB%A7%E6%89%BF.png"></p><blockquote><ul><li><strong>特别注意：</strong>此时son没有自己的虚基类表和虚基类指针，只是继承了sheep和camel的虚基类指针和虚基类表，只是修改了两个虚基类表中的值，修改为当前类中，如何通过继承的虚基类指针查找虚基类数据</li><li>Son继承Sheep父类，父类中有虚基类指针vbptr(virtual base pointer)，对象结构类似结构体，首元素是虚基类指针，其余为自身数据（不包括静态成员和成员函数）</li><li>Sheep的虚指针指向下面Sheep的虚基类表vbtale@Sheep(virtual base table)，虚基类表是一个整型数组，数组第二个元素值为20，即Sheep的虚指针地址偏移20指向Animal的m_Age地址。Camel父类同理，因此，类中只有一个m_Age元素。</li><li>Son中包含了两个指针和四个int类型，所以大小为24。</li></ul></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_Age;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Sheep:virtual public Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_sheep;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Camel :virtual public Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_camel;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Son :virtual public Sheep, virtual public Camel{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_son</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void test01(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Son son;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    son.m_Age = 10;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Animal) &lt;&lt; endl; //m_Age</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Sheep) &lt;&lt; endl;  //sheep-Vbptr,m_sheep,m_Age</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Camel) &lt;&lt; endl;  //camel-Vbptr,m_camel,m_Age</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; sizeof(Son) &lt;&lt; endl;    //son-vbptr,m_son,m_Age,sheep-Vbptr,m_sheep,camel-Vbptr,m_camel,</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img src="https://github.com/twomonkeyclub/BackEnd/blob/master/%E5%9F%BA%E7%A1%80%E8%AF%AD%E8%A8%80/utils/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF.png"></p><blockquote><ul><li>注意跟上面的区别，一个是son类中的元素顺序，一个是son类有了自己的虚基类指针和虚基类表</li></ul></blockquote><ul><li>虚继承<ul><li>一般通过虚基类指针和虚基类表实现，将共同基类设置为虚基类</li><li><strong>每个虚继承的子类（虚基类本身没有）</strong>都有一个虚基类指针（占用一个指针的存储空间）和虚基类表（不占用类对象的存储空间），<strong>虚基类指针属于对象，虚基类表属于类</strong></li><li>当虚继承的子类被当做父类继承时，虚基类指针也会被继承。</li><li>虚表中只记录了虚基类数据在派生类对象中与派生类对象首地址(虚基类指针)之间的偏移量,以此来访问虚基类数据</li><li>虚继承不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。</li><li>虚基类表本质是一个<strong>整型数组</strong></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="静态函数可以是虚函数吗"></a>静态函数可以是虚函数吗<a class="hash-link" href="#静态函数可以是虚函数吗" title="Direct link to heading">#</a></h2><p>不可以，因为虚函数属于对象，不属于类，静态函数属于类</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="类型兼容性原则-为什么会有多态"></a>类型兼容性原则 为什么会有多态<a class="hash-link" href="#类型兼容性原则-为什么会有多态" title="Direct link to heading">#</a></h2><p>类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代,如使用子类对象可以直接赋值给父类对象或子类对象可以直接初始化父类对象时，<strong>对于同样的一条语句，不管传入子类还是父类对象，都是调用的父类函数，但我们想实现的是同样的一条语句，传入不同的对象，调用不同的函数</strong>.</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    void speak(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;Animal speak&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Sheep :public Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    void speak(){ //重定义，子类重新定义父类中有相同名称的非虚函数 </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;Sheep speak&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void doSpeak(Animal &amp;animal){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    animal.speak();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//想通过父类引用指向子类对象</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void test01(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Sheep sheep;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    doSpeak(sheep); //Animal speak;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    sheep.speak();  //sheep speak</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    sheep.Animal::speak();  //Animal speak; //继承中的重定义可以通过作用域</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>但我们想<strong>传入子类对象调用子类函数，传入父类对象调用父类函数</strong>，即同样的调用语句有多种不同的表现形态，这样就出现了<strong>多态</strong></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="重载覆盖重写"></a>重载、覆盖、重写<a class="hash-link" href="#重载覆盖重写" title="Direct link to heading">#</a></h2><ul><li>重载(overload)：是函数名相同，参数列表不同。重载只是在同一个类的内部存在，但是不能靠返回类型来判断</li><li>覆盖(override)：子类重新定义父类中有相同名称和参数的虚函数。两者的函数特征相同。<ul><li>被重写的函数不能是static的。必须是virtual的</li><li>重写函数必须有相同的类型，名称和参数列表</li><li>重写函数的访问权限可以不同。尽管virtual是private的，子类中重写改写为public,protected也是可以的。 </li></ul></li><li>重写(overwrite)：也叫做隐藏。子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) 。如果一个类，存在和父类相同的函数，那么，这个类将会隐藏其父类的方法，除非你在调用的时候，强制转换为父类类型或加上父类作用域</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多态实现的基础"></a>多态实现的基础<a class="hash-link" href="#多态实现的基础" title="Direct link to heading">#</a></h2><blockquote><ul><li>继承</li><li>虚函数覆盖</li><li>父类指针或引用指向子类对象访问虚函数</li></ul></blockquote><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    virtual  void speak(){ //在父类中声明虚函数，可以实现多态，动态联编</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;Animal speak&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_age = 0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Sheep :public Animal{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    void speak(){ //发生多态时，子类对父类中的成员函数进行重写，virtual可写可不写</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;Sheep speak&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    int m_age = 1;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void doSpeak(Animal &amp;animal){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    animal.speak();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void test01(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //传入子类对象调用子类成员函数</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Sheep sheep;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    doSpeak(sheep); //sheep speak;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //子类对象直接调用子类成员函数</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    sheep.speak();  //sheep speak;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //子类对象通过作用域调用父类成员函数</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    sheep.Animal::speak();  //animal speak;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //基类成员不能转换为子类成员，即不能向下转换</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Animal *animal0 = new Animal();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Sheep * sheep0 = animal0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //sheep0-&gt;speak();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //同样不能向下转换</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Animal animal0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //Sheep sheep0 = animal0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //父类指针指向子类对象</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Sheep *sheep1 = new Sheep();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Animal *animal1 = sheep1;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    animal1-&gt;speak(); //sheep speak;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //父类引用指向子类对象</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Sheep sheep2;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Animal &amp;animal2 = sheep2;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    animal2.speak();    //sheep speak;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    </span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    //子类对象直接赋值给父类对象，不符合多态条件，符合类型兼容性原则</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Sheep sheep0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Animal animal0 = sheep0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    animal0.speak();    //animal speak;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="静态多态和动态多态"></a>静态多态和动态多态<a class="hash-link" href="#静态多态和动态多态" title="Direct link to heading">#</a></h2><blockquote><ul><li>静态多态（运算符重载、函数重载）</li><li>动态多态（继承、虚函数）</li></ul></blockquote><p>两者主要的区别：函数地址是早绑定（静态联编）还是晚绑定（动态联编）。即，在编译阶段确定好地址还是在运行时才确定地址。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚函数指针和虚函数表"></a>虚函数指针和虚函数表<a class="hash-link" href="#虚函数指针和虚函数表" title="Direct link to heading">#</a></h2><blockquote><ul><li>前提发生了多态，每个类中都有虚函数表，最开始的父类创建虚函数表，后面的子类继承父类的虚函数表，然后对虚函数重写</li><li>虚函数重写（覆盖）的实质就是重写父类虚函数表中的父类虚函数地址；</li><li>实现多态的流程：虚函数指针-&gt;虚函数表-&gt;函数指针-&gt;入口地址，<strong>虚函数表（vftable）属于类</strong>，或者说这个类的所有对象共享一个虚函数表；<strong>虚函数指针（vfptr）属于单个对象</strong>。</li><li>在程序调用时，先创建对象，编译器在对象的内存结构头部添加一个虚函数指针，进行动态绑定，虚函数指针指向对象所属类的虚函数表。</li><li>虚函数表是一个指针数组，其元素是虚函数的指针，每个元素对应一个函数的指针。如果子类对父类中的一个或多个虚函数进行重写，子类的虚函数表中的元素顺序，会按照父类中的虚函数顺序存储，之后才是自己类的函数顺序。</li><li>编译器根本不会去区分，传进来的是子类对象还是父类对象，而是关心调用的函数是否为虚函数。如果是虚函数，就根据不同对象的vptr指针找属于自己的函数。父类对象和子类对象都有vfptr指针，传入对象不同，编译器会根据vfptr指针，到属于自己虚函数表中找自己的函数。即：vptr---&gt;虚函数表------&gt;函数的入口地址，从而实现了迟绑定(在运行的时候，才会去判断)。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="函数指针与指针函数"></a>函数指针与指针函数<a class="hash-link" href="#函数指针与指针函数" title="Direct link to heading">#</a></h2><ul><li><p>指针函数<code>int* f(int x, int y)</code>本质是函数，返回值为指针，函数指针<code>int (*f)(int x)</code>本质是指针，指向函数的指针</p></li><li><p>通常我们可以将指针指向某类型的变量，称为类型指针（如，整型指针）。若将一个指针指向函数，则称为函数指针。</p></li><li><p>函数名代表函数的入口地址，同样的，我们可以通过根据该地址进行函数调用，而非直接调用函数名。</p></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">void test001(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    printf(&quot;hello, world&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main(){</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    void(*myfunc)() = test001;//将函数写成函数指针</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    myfunc(); //调用函数指针 hello world</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>test001的函数名与myfunc函数指针都是一样的，即都是函数指针。test001函数名是一个函数指针常量，而myfunc是一个函数指针变量，这是它们的关系。</p><ul><li>函数指针多用于回调函数，回调函数最大的优势在于灵活操作，可以实现用户定制的函数，降低耦合性，实现多样性，如STL中</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="怎么理解多态和虚函数"></a>怎么理解多态和虚函数<a class="hash-link" href="#怎么理解多态和虚函数" title="Direct link to heading">#</a></h2><ul><li><p>多态的实现主要分为静态多态和动态多态，静态多态主要是重载，在编译的时候就已经确定；动态多态是用虚函数机制实现的，在运行期间动态绑定。</p></li><li><p>举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数</p></li></ul><p>虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="构造函数能否实现多态虚函数指针什么时候初始化"></a>构造函数能否实现多态/虚函数指针什么时候初始化<a class="hash-link" href="#构造函数能否实现多态虚函数指针什么时候初始化" title="Direct link to heading">#</a></h2><p>两个问题本质是一样的，构造函数不能实现多态</p><ul><li><p>对象在创建时,由编译器对VPTR指针进行初始化，只有当对象的构造完全结束后VPTR的指向才最终确定。</p></li><li><p>子类中虚函数指针的初始化过程
当定义一个子类对象的时候比较麻烦，因为构造子类对象的时候会首先调用父类的构造函数然后再调用子类的构造函数。当调用父类的构造函数的时候，此时会创建Vptr指针，该指针会指向父类的虚函数表；然后再调用子类的构造函数，子类继承父类的虚函数指针，此时Vptr又被赋值指向子类的虚函数表。 </p></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="构造函数能否是虚函数"></a>构造函数能否是虚函数<a class="hash-link" href="#构造函数能否是虚函数" title="Direct link to heading">#</a></h2><p>不能，因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="抽象类和纯虚函数"></a>抽象类和纯虚函数<a class="hash-link" href="#抽象类和纯虚函数" title="Direct link to heading">#</a></h2><p>在程序设计中，如果仅仅为了设计一些虚函数接口，打算在子类中对其进行重写，那么不需要在父类中对虚函数的函数体提供无意义的代码，可以通过纯虚函数满足需求。</p><ul><li><p>纯虚函数的语法格式：<code>virtual 返回值类型 函数名 () = 0; </code>只需要将函数体完全替换为 =0即可，<strong>纯虚函数必须在子类中进行实现</strong>，在子类外实现是无效的。</p></li><li><p>注意</p><ul><li>如果父类中出现了一个纯虚函数，则这个类变为了抽象类，抽象类不可实例对象</li><li>如果父类为抽象类，子类继承父类后，必须实现父类所有的纯虚函数，否则子类也为抽象类，也无法实例对象<strong>但纯虚析构函数例外，因为子类不会继承父类的析构函数</strong></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚析构和纯虚析构"></a>虚析构和纯虚析构<a class="hash-link" href="#虚析构和纯虚析构" title="Direct link to heading">#</a></h2><blockquote><ul><li>仅仅发生继承时，创建子类对象后销毁，函数调用流程为：父类构造函数-&gt;子类构造函数-&gt;子类析构函数-&gt;父类析构函数；</li><li>当发生多态时（父类指针或引用指向子类对象），通过父类指针在堆上创建子类对象，然后销毁，调用流程为：父类构造函数-&gt;子类构造函数-&gt;父类析构函数，不会调用子类析构函数，因此子类中会出现内存泄漏问题。</li></ul></blockquote><p>解决方法：将父类中的析构函数设置为虚函数，设置后会先调用子类析构函数，再调用父类析构函数</p><ul><li>纯虚析构<ul><li>纯虚析构需要类内声明，类外实现</li><li>纯虚析构也是虚函数，该类也为抽象类</li><li>子类不会继承父类的析构函数，当父类纯虚析构没有实现时，子类不是抽象类，可以创建创建对象。</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="为什么析构函数必须是虚函数"></a>为什么析构函数必须是虚函数<a class="hash-link" href="#为什么析构函数必须是虚函数" title="Direct link to heading">#</a></h2><p>因为当发生多态时，父类指针在堆上创建子类对象，销毁时会内存泄漏</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="为什么c默认的析构函数不是虚函数"></a>为什么C++默认的析构函数不是虚函数<a class="hash-link" href="#为什么c默认的析构函数不是虚函数" title="Direct link to heading">#</a></h2><p>因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存 </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="类模板和函数模板"></a>类模板和函数模板<a class="hash-link" href="#类模板和函数模板" title="Direct link to heading">#</a></h2><p>通过<code>template&lt;class T&gt;</code>或<code>template&lt;typename T&gt;</code>实现，主要用于数据的类型参数化，简化代码，有类模板和函数模板，函数模板是用于生成函数的，类模板则是用于生成类的</p><ul><li>类模板和函数模板定义</li></ul><blockquote><ul><li>template声明下面是函数定义，则为函数模板，否则为类模板。</li><li>注意：每个函数模板前必须有且仅有一个template声明，不允许多个template声明后只有一个函数模板，也不允许一个template声明后有多个函数模板(类模板同理)。</li></ul></blockquote><ul><li>类模板与函数模板的区别<ul><li>类模板不支持自动类型推导</li><li>数据类型可以有默认参数.</li></ul></li></ul><header><h1 class="h1Heading_27L5">C++补充</h1></header><blockquote><ul><li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">构造函数可以抛出异常吗，有什么问题？</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E6%80%8E%E4%B9%88%E6%8D%95%E8%8E%B7">初始化列表的异常怎么捕获？</a></li><li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E5%90%97%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98">析构函数可以抛出异常吗，有什么问题？</a></li><li><a href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8">析构函数如何处理异常</a></li><li><a href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">智能指针</a></li><li><a href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存泄漏</a></li><li><a href="#%E9%87%8E%E6%8C%87%E9%92%88">野指针</a></li><li><a href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">强制转换</a></li><li><a href="#RTTI">RTTI</a></li><li><a href="#RAII">RAII</a></li><li><a href="#CPP11%E6%96%B0%E7%89%B9%E6%80%A7">CPP11新特性</a></li><li><a href="#%E4%BB%BF%E5%87%BD%E6%95%B0">仿函数</a></li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="构造函数可以抛出异常吗有什么问题"></a><a href="https://www.cnblogs.com/qinguoyi/p/10304882.html" target="_blank" rel="noopener noreferrer">构造函数可以抛出异常吗，有什么问题？</a><a class="hash-link" href="#构造函数可以抛出异常吗有什么问题" title="Direct link to heading">#</a></h2><p>构造函数中应该避免抛出异常。</p><blockquote><ul><li>构造函数中抛出异常后，对象的析构函数将不会被执行</li><li>构造函数抛出异常时，本应该在析构函数中被delete的对象没有被delete，会导致内存泄露</li><li>当对象发生部分构造时，已经构造完毕的子对象（非动态分配）将会逆序地被析构。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="初始化列表的异常怎么捕获"></a>初始化列表的异常怎么捕获？<a class="hash-link" href="#初始化列表的异常怎么捕获" title="Direct link to heading">#</a></h2><blockquote><ul><li>初始化列表构造，当初始化列表出现异常时，程序还未进入函数体，因此函数体中的try-catch不能执行，catch也无法处理异常。可以通过函数try块解决该问题。</li><li>函数try块中的try出现在表示构造函数初始值列表的冒号以及表示构造函数体的花括号之前，与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="析构函数可以抛出异常吗有什么问题"></a>析构函数可以抛出异常吗，有什么问题？<a class="hash-link" href="#析构函数可以抛出异常吗有什么问题" title="Direct link to heading">#</a></h2><p>析构函数不应该抛出异常</p><blockquote><ul><li><strong>其他正常，仅析构函数异常</strong>。 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。</li><li><strong>其他异常，且析构函数异常</strong>。 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="析构函数如何处理异常"></a>析构函数如何处理异常？<a class="hash-link" href="#析构函数如何处理异常" title="Direct link to heading">#</a></h2><blockquote><ul><li>若析构函数抛出异常，调用std::abort()来终止程序</li><li>在析构函数中catch捕获异常并作处理，吞下异常；</li><li>如果客户需要对某个操作函数运次期间抛出的异常做出反应，class应该提供普通函数执行该操作，而非在析构函数中。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="智能指针"></a><a href="https://www.cnblogs.com/TianFang/archive/2008/09/20/1294590.html" target="_blank" rel="noopener noreferrer">智能指针</a><a class="hash-link" href="#智能指针" title="Direct link to heading">#</a></h2><p>智能指针有shared_ptr,weak_ptr,unique_ptr，<a href="https://www.cnblogs.com/wxquare/p/4759020.html" target="_blank" rel="noopener noreferrer">参考</a>，使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p><ul><li><p>shared_ptr核心要理解引用计数，什么时候销毁底层指针，还有赋值，拷贝构造时候的引用计数的变化，析构的时候要判断底层指针的引用计数为0了才能真正释放底层指针的内存</p><ul><li>不能将指针直接赋值给一个智能指针，一个是类，一个是指针。例如<code>std::shared_ptr&lt;int&gt; p4 = new int(1);</code></li><li>可以<code>std::shared_ptr&lt;int&gt;p4(new int(1));</code></li><li>拷贝使得对象的引用计数增加1，赋值使得原对象引用计数减1，当计数为0时，自动释放内存。后来指向的对象引用计数加1，指向后来的对象</li><li>赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数</li></ul></li><li><p>shared_ptr创建后是栈上的对象，当出作用域后，每个对象会自动调用析构函数，如上所述，new int(1)会生成一个指针，此时将其传参数给shared_ptr,由shared_ptr对其进行管理，shared_ptr虽然是对象，但其有指针的特性，通过重载运算符*和-&gt;实现指针的特性来访问被管理的指针。</p></li><li><p>shared_ptr是可以共享所有权的智能指针</p><ul><li>shared_ptr的管理机制其实并不复杂，就是对所管理的对象（这里的对象本质是被管理的指针new int(1)，并不是类和对象中的对象）进行了引用计数，当新增一个shared_ptr对该对象进行管理时，就将该对象的引用计数加一；减少一个shared_ptr对该对象进行管理时，就将该对象的引用计数减一，如果该对象的引用计数为0的时候，说明没有任何指针对其管理，才调用delete释放其所占的内存。   </li><li>对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类，可以通过make_shared函数或者通过构造函数传入普通指针</li><li>不要把一个原生指针给多个shared_ptr，不要把this指针交给智能指针管理，这样会重复释放</li><li>shared_ptr之间的资源共享是通过shared_ptr智能指针拷贝、赋值实现的，因为这样可以引起计数器的更新；而如果直接通过原生指针来初始化，就会导致m_sp和p都根本不知道对方的存在，然而却两者都管理同一块地方</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">int* ptr = new int;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">shared_ptr&lt;int&gt; p1(ptr);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">shared_ptr&lt;int&gt; p2(ptr); //这样不会导致更新，两者不知对方存在</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">shared_ptr&lt;int&gt; p3(p1);//这样才会导致计数器更新</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>shared_ptr循环引用导致内存泄漏，引出weak_ptr<ul><li>循环引用是两个强引用（shared_ptr）互相引用，使得两者的引用计数无法为0，进而无法释放，此时将循环引用的一方变为weak_ptr即可。</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">template &lt;typename T&gt;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">class Node</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">public:</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Node(const T&amp; value)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        :_pPre(NULL)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        , _pNext(NULL)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        , _value(value)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;Node()&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    ~Node()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;~Node()&quot; &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">        cout &lt;&lt; &quot;this:&quot; &lt;&lt; this &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    T _value;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">};</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">void Funtest()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    shared_ptr&lt;Node&lt;int&gt;&gt; sp1(new Node&lt;int&gt;(1));</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    shared_ptr&lt;Node&lt;int&gt;&gt; sp2(new Node&lt;int&gt;(2));</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    sp1-&gt;_pNext = sp2;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    sp2-&gt;_pPre = sp1;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;sp1.use_count:&quot; &lt;&lt; sp1.use_count() &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; &quot;sp2.use_count:&quot; &lt;&lt; sp2.use_count() &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">int main()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">{</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    Funtest();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    system(&quot;pause&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    return 0;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>上述情况造成了一个僵局，那就是析构对象时先析构sp2,可是由于sp2的空间sp1还在使用中，所以sp2.use_count减减之后为1，不释放，sp1也是相同的道理，由于sp1的空间sp2还在使用中，所以sp1.use_count减减之后为1，也不释放。sp1等着sp2先释放，sp2等着sp1先释放,二者互不相让，导致最终都没能释放，内存泄漏。</p><ul><li><strong>弱引用（weak_ptr）并不修改该对象的引用计数</strong>，weak_ptr必须从一个share_ptr或另一个weak_ptr转换而来，这也说明，进行该对象的内存管理的是那个强引用的share_ptr,weak_ptr只是提供了对管理对象的一个访问手段这意味这弱引用它并不对对象的内存进行管理。在功能上类似于普通指针，然而一个比较大的区别是，弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">weak_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">weak_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>expired()用于检测所管理的对象是否已经释放；lock()用于获取所管理的对象的强引用指针，不能直接访问弱引用，需要将其先通过lock转换为强引用再访问</p><ul><li>unique_ptr
unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="内存泄漏"></a>内存泄漏<a class="hash-link" href="#内存泄漏" title="Direct link to heading">#</a></h2><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="野指针"></a>野指针<a class="hash-link" href="#野指针" title="Direct link to heading">#</a></h2><p>野指针指向一个已删除的对象或 申请访问受限内存区域的指针。</p><ul><li>原因<ul><li>指针变量未初始化</li><li>指针释放未置空</li><li>指针操作超出作用域。返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="强制转换"></a>强制转换<a class="hash-link" href="#强制转换" title="Direct link to heading">#</a></h2><p>C++中强制转换为static_cast, dynamic_cast,const_cast, reinterpret_cast</p><ul><li>static_cast<ul><li>完成基础数据类型；同一个继承体系中类型的转换；任意类型与空指针类型void* 之间的转换，不能用于普通指针的转换（void空指针除外）</li></ul></li><li>dynamic_cast<ul><li>动态类型转换，用于实现RTTI。只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常bad_cast</li></ul></li><li>const_cast<ul><li>用于删除 const、volatile特性</li></ul></li><li>reinterpret_cast<ul><li>几乎什么都可以转,不能丢掉 const、volatile特性</li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="rtti"></a>RTTI<a class="hash-link" href="#rtti" title="Direct link to heading">#</a></h2><p>运行时类型检查，在C++层面主要体现在dynamic_cast和typeid</p><blockquote><ul><li>dynamic_cast
动态类型转换</li><li>typeid
typeid 运算符允许在运行时确定对象的类型，获取对象的实际类型</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="raii"></a>RAII<a class="hash-link" href="#raii" title="Direct link to heading">#</a></h2><p>RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.</p><ul><li>在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。</li><li>RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,智能指针是RAII最好的例子</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cpp11新特性"></a>CPP11新特性<a class="hash-link" href="#cpp11新特性" title="Direct link to heading">#</a></h2><ul><li>nullptr常量<ul><li>C++中NULL仅仅是<code>define NULL 0</code>的一个宏定义，因此，有时候会产生歧义<ul><li>比如f（char*）和f（int），参数传NULL的话到底该调用哪个？</li><li>事实上，在VS下测试这样的函数重载会优先调用f（int），但是f（char *）也是正确的，因此C++引入nullptr来避免这个问题</li></ul></li><li>nullptr是一个空指针，可以被转换成其他任意指针的类型</li></ul></li><li>auto类型指示符<ul><li>让编译器替我们去分析表达式所属的类型，直接推导</li><li>尤其是STL中map的迭代器这种很长的类型，适合用auto</li></ul></li><li>decltype类型指示符<ul><li>从表达式的类型推断出要定义的变量的类型，跟表达式的类型也就是参数类型紧密相关</li><li><code>delctype (f()) sum = x;</code> 并不实际调用函数f()，只是使用f()的返回值当做sum的类型</li><li><code>delctype (i) sum = x;</code>和<code>delctype ((i)) sum = x;</code> 其中i为int类型，前面的为int类型，后面的为int&amp;引用</li></ul></li><li>范围for语句<ul><li>多与auto配合使用</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">string str(&quot;somthing&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">for(auto i:str) //对于str中的每个字符，i类型为char</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; c &lt;&lt; endl;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">for(auto &amp;i:str) //对于若要改变每个字符的值，需要加引用</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    cout &lt;&lt; c &lt;&lt; endl;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>定义双层vector<ul><li><code>vector&lt;vector&lt;int&gt;&gt;(m, vector&lt;int&gt;(n, 0))</code> 创建m行n列的二维数组，全部初始化为0</li></ul></li><li><a href="https://blog.csdn.net/qq_43265890/article/details/83218413" target="_blank" rel="noopener noreferrer">lambda表达式</a><ul><li>用于实现匿名函数，匿名函数只有函数体，没有函数名</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">[capture list] (params list) mutable exception-&gt; return type {function body};  //1</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[capture list] (params list) -&gt; return type {function body};  //1 省略mutable，表示const不可修改</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[capture list] (params list) {function body};       //2 省略返回类型，按照函数体返回值决定返回类型</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">[capture list] {function body};     //3 省略参数列表，无参函数</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>参数<ul><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ul></li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C++"><pre tabindex="0" class="prism-code language-C++ codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">//示例</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">sort(vec.begin(), vec.end(), [](int a, int b)-&gt;bool{return a &lt; b})</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li><p>参数捕获方式</p><ul><li>值捕获(传参)、引用捕获（传引用）、隐式捕获（传=，函数体直接使用变量））。 </li></ul></li><li><p>智能指针</p><ul><li>shared_ptr</li><li>weak_ptr</li><li>unique_ptr</li></ul></li><li><p>右值引用</p><ul><li>左值引用，必须引用左值 <code>int a = 0; int &amp;b = a;</code></li><li>右值引用可以引用结果 <code>int &amp;&amp; i = 0</code></li></ul></li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="仿函数"></a>仿函数<a class="hash-link" href="#仿函数" title="Direct link to heading">#</a></h2><ul><li>定义<ul><li>仿函数(functor)又称之为函数对象（function object），其实就是重载了operator()操作符的struct或class，是一个能行使函数功能的类</li><li>它使一个类的使用看上去像一个函数，这个类就有了类似函数的行为，就是一个仿函数类。</li></ul></li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/worst0/wiki_note/edit/main/docs/4.Programming_Language/B6.C++-question.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF">Last updated on <b><time datetime="2021-10-10T12:44:25.000Z">10/10/2021</time></b></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Programming_Language/B5.C++编译"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« B5.C++编译</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Programming_Language/C1.STL"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">C1.STL »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#为什么两个不同对象的地址应该不同" class="table-of-contents__link">为什么两个不同对象的地址应该不同？</a></li><li><a href="#ebo空基类优化" class="table-of-contents__link">EBO(空基类优化)</a></li><li><a href="#extern-c的结果和cpp编译的区别" class="table-of-contents__link">extern-C的结果和CPP编译的区别</a></li><li><a href="#重载的底层原理" class="table-of-contents__link">重载的底层原理</a></li><li><a href="#编译性语言和解释性语言的本质区别和优缺点" class="table-of-contents__link">编译性语言和解释性语言的本质区别和优缺点</a></li><li><a href="#c中class和struct的区别" class="table-of-contents__link">C++中class和struct的区别</a></li><li><a href="#newdelete和mallocfree区别" class="table-of-contents__link">new/delete和malloc/free区别</a></li><li><a href="#new运算符的原理" class="table-of-contents__link">new运算符的原理</a></li><li><a href="#malloc的内存分配机制" class="table-of-contents__link">malloc的内存分配机制</a></li><li><a href="#栈和堆的区别" class="table-of-contents__link">栈和堆的区别</a></li><li><a href="#面向对象和面向过程的区别" class="table-of-contents__link">面向对象和面向过程的区别</a></li><li><a href="#const关键字不可修改" class="table-of-contents__link">const关键字(不可修改)</a></li><li><a href="#static关键字对外不可见" class="table-of-contents__link">static关键字(对外不可见)</a></li><li><a href="#extern关键字" class="table-of-contents__link">extern关键字</a></li><li><a href="#volatile关键字" class="table-of-contents__link">volatile关键字</a></li><li><a href="#explicit关键字" class="table-of-contents__link">explicit关键字</a></li><li><a href="#类成员属性" class="table-of-contents__link">类成员属性</a></li><li><a href="#大小端序的定义和代码判断" class="table-of-contents__link">大小端序的定义和代码判断</a><ul><li><a href="#定义" class="table-of-contents__link">定义</a></li><li><a href="#代码判断" class="table-of-contents__link">代码判断</a></li></ul></li><li><a href="#代码判断32位和64位系统" class="table-of-contents__link">代码判断32位和64位系统</a></li><li><a href="#内存字节对齐" class="table-of-contents__link">内存字节对齐</a></li><li><a href="#面向对象三大特性" class="table-of-contents__link">面向对象三大特性</a></li><li><a href="#双冒号using和namespace" class="table-of-contents__link">双冒号、using和namespace</a></li><li><a href="#内联函数和函数重载" class="table-of-contents__link">内联函数和函数重载</a></li><li><a href="#虚函数可以是内联函数吗" class="table-of-contents__link">虚函数可以是内联函数吗</a></li><li><a href="#拷贝构造函数与深浅拷贝" class="table-of-contents__link">拷贝构造函数与深浅拷贝</a></li><li><a href="#只在堆上栈上创建对象" class="table-of-contents__link">只在堆上/栈上创建对象</a></li><li><a href="#this指针" class="table-of-contents__link">this指针</a></li><li><a href="#常函数和常对象" class="table-of-contents__link">常函数和常对象</a></li><li><a href="#delete-this合法吗" class="table-of-contents__link">delete this合法吗</a></li><li><a href="#为什么空类大小不为0" class="table-of-contents__link">为什么空类大小不为0</a></li><li><a href="#静态成员变量与静态成员函数" class="table-of-contents__link">静态成员变量与静态成员函数</a></li><li><a href="#初始化列表的好处和使用条件" class="table-of-contents__link">初始化列表的好处和使用条件</a></li><li><a href="#能否通过初始化列表初始化静态成员变量" class="table-of-contents__link">能否通过初始化列表初始化静态成员变量</a></li><li><a href="#友元全局函数友元类友元成员函数" class="table-of-contents__link">友元全局函数、友元类、友元成员函数</a></li><li><a href="#运算符重载及重载实现" class="table-of-contents__link">运算符重载及++重载实现</a><ul><li><a href="#运算符重载基本属性" class="table-of-contents__link">运算符重载基本属性</a></li><li><a href="#运算符重载总结" class="table-of-contents__link">运算符重载总结</a></li><li><a href="#i和i实现" class="table-of-contents__link">i++和++i实现</a></li></ul></li><li><a href="#继承方式对象模型同名处理" class="table-of-contents__link">继承方式、对象模型、同名处理</a><ul><li><a href="#继承方式" class="table-of-contents__link">继承方式</a></li><li><a href="#继承的对象模型" class="table-of-contents__link">继承的对象模型</a></li><li><a href="#继承中的同名处理" class="table-of-contents__link">继承中的同名处理</a></li></ul></li><li><a href="#多继承和菱形继承" class="table-of-contents__link">多继承和菱形继承</a><ul><li><a href="#多继承" class="table-of-contents__link">多继承</a></li><li><a href="#菱形继承" class="table-of-contents__link">菱形继承</a></li></ul></li><li><a href="#静态函数可以是虚函数吗" class="table-of-contents__link">静态函数可以是虚函数吗</a></li><li><a href="#类型兼容性原则-为什么会有多态" class="table-of-contents__link">类型兼容性原则 为什么会有多态</a></li><li><a href="#重载覆盖重写" class="table-of-contents__link">重载、覆盖、重写</a></li><li><a href="#多态实现的基础" class="table-of-contents__link">多态实现的基础</a></li><li><a href="#静态多态和动态多态" class="table-of-contents__link">静态多态和动态多态</a></li><li><a href="#虚函数指针和虚函数表" class="table-of-contents__link">虚函数指针和虚函数表</a></li><li><a href="#函数指针与指针函数" class="table-of-contents__link">函数指针与指针函数</a></li><li><a href="#怎么理解多态和虚函数" class="table-of-contents__link">怎么理解多态和虚函数</a></li><li><a href="#构造函数能否实现多态虚函数指针什么时候初始化" class="table-of-contents__link">构造函数能否实现多态/虚函数指针什么时候初始化</a></li><li><a href="#构造函数能否是虚函数" class="table-of-contents__link">构造函数能否是虚函数</a></li><li><a href="#抽象类和纯虚函数" class="table-of-contents__link">抽象类和纯虚函数</a></li><li><a href="#虚析构和纯虚析构" class="table-of-contents__link">虚析构和纯虚析构</a></li><li><a href="#为什么析构函数必须是虚函数" class="table-of-contents__link">为什么析构函数必须是虚函数</a></li><li><a href="#为什么c默认的析构函数不是虚函数" class="table-of-contents__link">为什么C++默认的析构函数不是虚函数</a></li><li><a href="#类模板和函数模板" class="table-of-contents__link">类模板和函数模板</a></li><li><a href="#构造函数可以抛出异常吗有什么问题" class="table-of-contents__link">构造函数可以抛出异常吗，有什么问题？</a></li><li><a href="#初始化列表的异常怎么捕获" class="table-of-contents__link">初始化列表的异常怎么捕获？</a></li><li><a href="#析构函数可以抛出异常吗有什么问题" class="table-of-contents__link">析构函数可以抛出异常吗，有什么问题？</a></li><li><a href="#析构函数如何处理异常" class="table-of-contents__link">析构函数如何处理异常？</a></li><li><a href="#智能指针" class="table-of-contents__link">智能指针</a></li><li><a href="#内存泄漏" class="table-of-contents__link">内存泄漏</a></li><li><a href="#野指针" class="table-of-contents__link">野指针</a></li><li><a href="#强制转换" class="table-of-contents__link">强制转换</a></li><li><a href="#rtti" class="table-of-contents__link">RTTI</a></li><li><a href="#raii" class="table-of-contents__link">RAII</a></li><li><a href="#cpp11新特性" class="table-of-contents__link">CPP11新特性</a></li><li><a href="#仿函数" class="table-of-contents__link">仿函数</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.76d09beb.js"></script>
<script src="/assets/js/main.12911a5b.js"></script>
</body>
</html>