<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Wiki Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Wiki Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">A5.存储管理 | My Wiki</title><meta data-react-helmet="true" property="og:url" content="https://worst0.github.io/Operating_system/A5.存储管理"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="A5.存储管理 | My Wiki"><meta data-react-helmet="true" name="description" content="存储器层次结构"><meta data-react-helmet="true" property="og:description" content="存储器层次结构"><meta data-react-helmet="true" property="og:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://worst0.github.io/Operating_system/A5.存储管理"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Operating_system/A5.存储管理" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Operating_system/A5.存储管理" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.060912d8.css">
<link rel="preload" href="/assets/js/runtime~main.6833ce06.js" as="script">
<link rel="preload" href="/assets/js/main.56997320.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/intro">Document💻</a><a class="navbar__item navbar__link" href="/blog">Blog🤓</a><a class="navbar__item navbar__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a><a class="navbar__item navbar__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">本站源码</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">🌙</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/intro">Document💻</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog🤓</a></li><li class="menu__list-item"><a class="menu__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a></li><li class="menu__list-item"><a class="menu__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></li><li class="menu__list-item"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="menu__link">本站源码</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">intro</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/intro">Readme</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">1.Linux</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Linux 命令</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A1.linux基础">A1.linux基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A2.Linux命令">A2.Linux命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A3.编译环境">A3.编译环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A4.数据提取">数据提取</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A5.Linux命令补充">Linux命令</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">shell脚本</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/B1.shell脚本语法">shell脚本语法</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">ubuntu</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C1.ubuntu相关">C1.ubuntu相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C2.ubuntu常用软件">ubuntu常用软件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C3.语言环境">语言环境</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">2.Algorithm</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">数据结构</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A1.DataStructure">数据结构和算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A2.数组和链表">A2.数组和链表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A3.栈和队列">栈,队列</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A4.堆和优先队列">==优先队列-堆==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A5.哈夫曼树">==哈弗曼树与哈弗曼编码==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A6.哈希表">==HashTable==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.排序">==sort==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.树">树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A8.字符串匹配">==字符串匹配算法==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.字典树">==字典树==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.树状数组和线段树">A10.树状数组和线段树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.平衡树">==二叉排序树==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.并查集">==并查集==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A12.图论">图</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A15.位图和跳表">A15.位图和跳表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A99.实现ADT">[LRU](https://leetcode-cn.com/problems/lru-cache/)</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">算法设计</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B1.算法分析">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B10.数论">B10.数论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B11.位运算">位运算</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B12.计算几何">B12.计算几何</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B13.网络流">B13.网络流</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B2.贪心">贪心</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B3.递推到递归">递推</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B4.动态规划">==动态规划==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B5.分治">分而治之（divide-and-conquer）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B6.减治和双指针">B6.减治和双指针</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B7.回溯">B7.回溯</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B8.搜索">B8.搜索</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B9.数学">数学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B98.字符串">B98.字符串</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B99.专题">回文</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.Algorithm">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.算法技巧">C1.算法技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C2.编程珠玑">C2.编程珠玑</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Think</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/D1.ACM模板">ACM模板</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E1.concrete">E1.concrete</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E2.Combinatorics">组合数学（Combinatorics）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/G1.逻辑思考">G1.逻辑思考</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/H1.算法谜题">H1.算法谜题</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">3.Online_Judge</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/A1.Leetcode">A1.Leetcode</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/B1.HZOJ">HZOJ</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/C1.nowcoder">nowcoder</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/D1.EP">D1.EP</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/E1.编程技巧">E1.编程技巧</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">4.Programming_Language</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">C</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A1.CBasic">A1.CBasic</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A2.Cimprove">A2.Cimprove</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A3.C语言技巧">A3.C语言技巧</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">C++</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B1.C++-basic">C++基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B2.C++-improve">B2.C++-improve</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B3.C++-exercise">C++-exercise</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B4.C++-others">C++ othres</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B5.C++编译">B5.C++编译</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B6.C++-question">B6.C++-question</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">STL</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C1.STL">STL</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C2.STL-question">STL</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">python</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/D1.python">D1.python</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/E1.conda">E1.conda</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">5.Programming_Stardard</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/A1.C编程规范">A1.C编程规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.编码英文缩写">B1.编码英文缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.计算机哲学">B1.计算机哲学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B2.英文标准缩写">B2.英文标准缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/C1.重构">重构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/D1.Design_Pattern">Design Pattern</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">6.Operating_system</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A1.os">OS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A2.OS概述">计算机操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A2.操作系统">A2.操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A3.进程与线程">进程管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A4.死锁">死锁</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/Operating_system/A5.存储管理">A5.存储管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A6.设备管理">设备管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A7.文件系统">A7.文件系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A8.输入输出">A8.输入输出</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A9.编译系统">A9.编译系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/C1.计算机原理">C1.计算机原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/D1.CSAPP">D1.CSAPP</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">系统编程</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A1.os">OS</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">7.Network</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A2.网络概论">A2.网络概论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A3.物理层">物理层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A4.链路层">链路层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A5.网络层">网络层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A6.传输层">传输层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A7.应用层">应用层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A9.疑问">A9.疑问</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/B1.HTTP">HTTP</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">8.Server</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/A1.Linux高性能服务器">Linux高性能服务器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.Linux多线程muduo">C++多线程系统编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.系统编程">B1.系统编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B2.文件IO">文件操作</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B3.文件和目录">B3.文件和目录</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B4.标准IO库">B4.标准IO库</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B9.命令">Linux命令行解析</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络API">C1.网络API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络编程">C1.网络编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C2.高级IO函数">C2.高级IO函数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C3.程序规范">C3.程序规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C4.IO复用">C4.IO复用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C5.信号">C5.信号</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C6.定时器">C6.定时器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C7.高性能服务器框架">C7.高性能服务器框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C8.socket">网络编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C9.实现">C9.实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D1.多进程编程">D1.多进程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D2.进程">进程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D4.进程间通信">IPC：进程间通信</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E1.多线程编程">E1.多线程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E2.线程">线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/H1.网络工具">H1.网络工具</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">9.Database</a><ul class="menu__list"></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">10.Skill</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/A1.Latex数学公式">A1.Latex数学公式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/B1.Markdown语法">B1.Markdown语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C1.git">C1.git</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C2.github">GitHub</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/D1.计算机英语">计算机英语</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/E1.绘图">绘图软件</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">11.Interview</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/A1.面试">面试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/A2.interview">A2.interview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/C1.简历">C1.简历</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">13.Project</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A1.Gtest测试框架">A1.Gtest测试框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A2.udp-football">A2.udp-football</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">14.Science</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/E3.数学认识">认识数学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/F1.物理认识">F1.物理认识</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">99.other</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/A1.临时">临时</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/B1.临时笔记">临时笔记</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/C1.task">task</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/D1.软件需求">软件需求</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/E1.software">E1.software</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">A5.存储管理</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="存储器层次结构"></a>存储器层次结构<a class="hash-link" href="#存储器层次结构" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="层次结构"></a>层次结构<a class="hash-link" href="#层次结构" title="Direct link to heading">#</a></h3><p>本地磁盘 -&gt; 主存(DRAM) -&gt; L3高速缓存(SRAM) -&gt; L2高速缓存(SRAM) -&gt; L1高速缓存(SRAM) -&gt; L0寄存器</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="缓存思想"></a>缓存思想<a class="hash-link" href="#缓存思想" title="Direct link to heading">#</a></h3><blockquote><ul><li>位于K层的更快更小的存储设备作为位于K+1层更大更慢的存储设备的缓存</li><li>K+1层的存储器被划分成连续的数据对象组块，称为块，数据总是以块大小为传送单元在K和K+1层之间来回复制</li></ul></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="缓存命中"></a>缓存命中<a class="hash-link" href="#缓存命中" title="Direct link to heading">#</a></h3><blockquote><ul><li>当程序需要K+1层的某个数据对象d时，首先在当前存储在K层的块中查找d，若d刚好缓存在k层中，则称为缓存命中</li><li>若缓存不命中，则需要将K+1层中包含对象d的块缓存到K层中，若K层中满了，则需要替换现存的一个块</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟内存"></a>虚拟内存<a class="hash-link" href="#虚拟内存" title="Direct link to heading">#</a></h2><p>通过局部性原理：</p><ul><li>在程序装入的过程中，可以将程序很快用到的部分装入内存，暂时用不到的部分驻留在外村，就可以让程序开始执行，</li><li>在程序执行中，当所访问信息不在内存中时，由操作系统负责将所需信息从外村调入内存，然后继续执行程序。</li><li>当内存空间不够，操作系统负责将内存中暂时用不到的信息换出到外村</li></ul><p>因此，使得操作系统可以使用一个比实际物理内存大得多内存，即虚拟内存。这个虚拟内存就解决了“页表”中的问题2，两级页表 + 虚拟内存实现，可以高效查询。</p><p>虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存，防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。</p><p>为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但<strong>不需要映射到连续的物理内存</strong>，也<strong>不需要所有页都必须在物理内存中</strong>。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p><p>从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。</p><p>例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K  大小的程序。</p><p> <a href="https://camo.githubusercontent.com/01251b0ef66ccf744889c26424634aae680922be7d993522b4d831dca3c9511c/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37623238316231652d303539352d343032622d616533352d3863393130383463333363312e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37623238316231652d303539352d343032622d616533352d3863393130383463333363312e706e67-2059502c373ff7374d59d6ba9878a08f.bin"></a> </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟内存的好处"></a><a href="https://www.jianshu.com/p/baf3a13c47db" target="_blank" rel="noopener noreferrer">虚拟内存的好处</a><a class="hash-link" href="#虚拟内存的好处" title="Direct link to heading">#</a></h3><ul><li>可以更加高效的使用物理内存<ul><li>虚拟地址空间一开始并没有真正的对应物理地址，而是在真正使用的时候才去对应。</li><li>通过虚拟内存置换算法在访问后边的地址空间的时候就可以将前边当前没有在访问的物理页释放掉，或者交换到硬盘中。这样这个物理页又可以去对应新的虚拟地址。从而使物理内存可以充分的利用。 </li></ul></li><li>内存管理<ul><li>为每个进程提供了一致的地址空间，简化内存管理</li></ul></li><li>内存保护<ul><li>在使用虚拟地址的时候，暴露给程序员永远都是虚拟地址，而具体的物理地址在哪里，这个只有系统才了解。这样就提高了系统的封装性。</li><li>保护了每个进程的地址空间不被其他进程破坏</li></ul></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟内存三个主要特征："></a>虚拟内存三个主要特征：<a class="hash-link" href="#虚拟内存三个主要特征：" title="Direct link to heading">#</a></h4><p>总结，针对传统的存储技术，虚拟存储有三个主要特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是运行被分成多次调入内存</li><li>对换性：在无作业运行时无需一直常驻内存，而是允许在作业运行过程中将作业换入换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，用户看到的容量，远大于实际的容量。这是虚拟内存的体现</li></ul><p>虚拟内存的最大容量是由于计算机地址结构（CPU寻址范围确定的），虚拟内存的实际容量 = MIN(内存和外存容量之和，CPU寻址范围)。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟内存的实现"></a>虚拟内存的实现<a class="hash-link" href="#虚拟内存的实现" title="Direct link to heading">#</a></h4><p>虚拟内存技术，允许一个作业多次调入内存。如果采用连续分配方式，会不方便实现，因此虚拟内存的实现是建立在离散分配的内存管理方式基础上。</p><ul><li>请求分页存储管理</li><li>请求分段存储管理</li><li>请求段页式管理</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="请求分页存储管理"></a>请求分页存储管理<a class="hash-link" href="#请求分页存储管理" title="Direct link to heading">#</a></h3><p>对于的基本分页的驻留行和一次性缺点，请求分页存储管理的主要区别：</p><ul><li>在程序执行的过程中，当所访问的信息不在内存中时，由操作系统负责将所需信息从外存调入内存，然后执行程序。这是由操作系统提供的请求调页功能，将缺失页面从外存调入内存。</li><li>如果内存空间不够，由操作系统将内存中暂时用不到的信息换出到外存。操作系统提供直面置换的功能，将暂时用不到的页面换出到外村。</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟内存页表寻址"></a>虚拟内存页表寻址<a class="hash-link" href="#虚拟内存页表寻址" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="分页"></a>分页<a class="hash-link" href="#分页" title="Direct link to heading">#</a></h3><p>虚拟内存分割成虚拟页，物理内存被分割成物理页，用来作为磁盘和主存的传输单元。
虚拟页分为三个不相交的子集</p><blockquote><ul><li>未分配的，不占磁盘空间</li><li>缓存的，当前已缓存在物理内存中的已分配页，在页表中标志位为1</li><li>未缓存的，未缓存在物理内存中的已分配页，在页表中标志位为0</li></ul></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="页表"></a>页表<a class="hash-link" href="#页表" title="Direct link to heading">#</a></h3><p>内存管理单元（MMU，属于硬件）管理着地址空间和物理内存的转换，操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表，存储着程序地址空间到物理内存空间的映射表。</p><p>页表存放在物理内存中，物理页存放在物理内存中，虚拟页存放在磁盘上</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="页表寻址"></a>页表寻址<a class="hash-link" href="#页表寻址" title="Direct link to heading">#</a></h3><blockquote><ul><li>一个虚拟地址分为两部分，一部分存储页面号，一部分存储偏移量</li><li>页表分为序号、页基地址、标志位</li><li>访问虚拟地址，先通过页表查询页面号，查看标志位确认虚拟地址是否在物理内存中有缓存，然后由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移虚拟地址中的偏移量就得到最后的物理地址</li><li>一般情况下，这个过程都可以由硬件完成，所以效率还是比较高的。页式内存管理的优点就是比较灵活，内存管理以较小的页为单位，方便内存换入换出和扩充地址空间。 </li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="缺页中断"></a>缺页中断<a class="hash-link" href="#缺页中断" title="Direct link to heading">#</a></h2><p>在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时(缓存不命中)，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。</p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p><blockquote><ul><li>保护CPU现场</li><li>分析中断原因</li><li>转入缺页中断处理程序进行处理</li><li>恢复CPU现场，继续执行</li></ul></blockquote><p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般的中断存在区别：</p><blockquote><ul><li>在指令执行期间产生和处理缺页中断信号</li><li>一条指令在执行期间，可能产生多次缺页中断</li><li>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。 </li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="分页系统地址映射"></a>分页系统地址映射<a class="hash-link" href="#分页系统地址映射" title="Direct link to heading">#</a></h2><p>内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。</p><p>一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。</p><p>下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12  位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。</p><p> <a href="https://camo.githubusercontent.com/1f3a60c6aaac33dd000b9d6a39069d3ddaf2bb04c22b8bcda782eca707eb64fe/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63663433383661312d353863392d346563612d613137662d6531326231653937373065622e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63663433383661312d353863392d346563612d613137662d6531326231653937373065622e706e67-5cbdb170425b3c88a177d409585ffcd3.bin"></a> </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="页面置换算法"></a>页面置换算法<a class="hash-link" href="#页面置换算法" title="Direct link to heading">#</a></h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生<strong>缺页中断</strong>从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。而用来选择淘汰哪一页的规则叫做页面置换算法。</p><p>页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。</p><p>页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="分类"></a>分类<a class="hash-link" href="#分类" title="Direct link to heading">#</a></h4><ul><li>全局置换：在整个内存空间置换</li><li>局部置换：在本进程中进行置换</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="算法"></a>算法<a class="hash-link" href="#算法" title="Direct link to heading">#</a></h4><p>全局：</p><ul><li>工作集算法</li><li>缺页率置换算法</li></ul><p>局部：</p><ul><li>最佳置换算法（OPT）</li><li>先进先出置换算法（FIFO）</li><li>最近最久未使用（LRU）算法</li><li>时钟（Clock）置换算法</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-最佳"></a>1. 最佳<a class="hash-link" href="#1-最佳" title="Direct link to heading">#</a></h3><blockquote><p>OPT, Optimal replacement algorithm</p></blockquote><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p><p>是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p><p>举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-最近最久未使用"></a>2. 最近最久未使用<a class="hash-link" href="#2-最近最久未使用" title="Direct link to heading">#</a></h3><blockquote><p>LRU, Least Recently Used</p><p>置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。</p></blockquote><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p><p>为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。</p><p>因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">4，7，0，7，1，0，1，2，1，2，6</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p> <a href="https://camo.githubusercontent.com/c5cd2c10ae1c8526540a7af00c5390d1a953f147c4c147358953c9e929897cc3/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65623835393232382d633066322d346263652d393130642d6439663736393239333532622e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65623835393232382d633066322d346263652d393130642d6439663736393239333532622e706e67-87c4810f0960a9e3caa6194e195c23b6.bin"></a> </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-最近未使用"></a>3. 最近未使用<a class="hash-link" href="#3-最近未使用" title="Direct link to heading">#</a></h3><blockquote><p>NRU, Not Recently Used</p></blockquote><p>每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：</p><ul><li>R=0，M=0</li><li>R=0，M=1</li><li>R=1，M=0</li><li>R=1，M=1</li></ul><p>当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。</p><p>NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-先进先出"></a>4. 先进先出<a class="hash-link" href="#4-先进先出" title="Direct link to heading">#</a></h3><blockquote><p>FIFO, First In First Out</p><p>置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存的先后次序排列成队列，从队尾进入，从队首删除。</p></blockquote><p>选择换出的页面是最先进入的页面。</p><p>该算法会将那些经常被访问的页面换出，导致缺页率升高。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5-第二次机会算法"></a>5. 第二次机会算法<a class="hash-link" href="#5-第二次机会算法" title="Direct link to heading">#</a></h3><p>FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：</p><p>当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是  0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清  0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。</p><p> <a href="https://camo.githubusercontent.com/579e409ef1551a1dc1c59487bc2fd54e93129ec97573721a3027376aa7f17595/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65636638616435642d353430332d343862392d623665372d6632653230666665386663612e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65636638616435642d353430332d343862392d623665372d6632653230666665386663612e706e67-eda518a4d9999907e64cec147dfedd9a.bin"></a> </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="6-时钟"></a>6. 时钟<a class="hash-link" href="#6-时钟" title="Direct link to heading">#</a></h3><blockquote><p>Clock</p></blockquote><p>第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。</p><p> <a href="https://camo.githubusercontent.com/66bf1e33e909443e7fd77bf1d37c6144162b0545ac0aa6b078928e40a4d64878/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35663565663062362d393865612d343937632d613030372d6636633535323838656162312e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35663565663062362d393865612d343937632d613030372d6636633535323838656162312e706e67-117acca1a023a173192b7b6c240926bd.bin"></a> </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="分段"></a>分段<a class="hash-link" href="#分段" title="Direct link to heading">#</a></h2><p>虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。</p><p>下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。</p><p> <a href="https://camo.githubusercontent.com/bc968c738c37aa7ad6d63d9b95a4803f11fe14aac87f571558024d19af30d399/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326465303533382d376336652d343336352d626433622d3863653363353930303231362e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32326465303533382d376336652d343336352d626433622d3863653363353930303231362e706e67-a0d3a027f38ac87e71797c4fe9aabf13.bin"></a> </p><p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p><p> <a href="https://camo.githubusercontent.com/836f0a92a1f8ff0dee7112c8fc213daa419a42e82cd543d6fd87100fc2624bec/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65303930306262322d323230612d343362372d396161392d3164356364353566663536652e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/836f0a92a1f8ff0dee7112c8fc213daa419a42e82cd543d6fd87100fc2624bec/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65303930306262322d323230612d343362372d396161392d3164356364353566663536652e706e67" alt="img"></a> </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="段页式"></a>段页式<a class="hash-link" href="#段页式" title="Direct link to heading">#</a></h2><p>程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="分页与分段的比较"></a>分页与分段的比较<a class="hash-link" href="#分页与分段的比较" title="Direct link to heading">#</a></h2><ul><li>对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。</li><li>地址空间的维度：分页是一维地址空间，分段是二维的。</li><li>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</li><li>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/worst0/wiki_note/edit/main/docs/6.Operating_system/A5.存储管理.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Operating_system/A4.死锁"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 死锁</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Operating_system/A6.设备管理"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">设备管理 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#存储器层次结构" class="table-of-contents__link">存储器层次结构</a><ul><li><a href="#层次结构" class="table-of-contents__link">层次结构</a></li><li><a href="#缓存思想" class="table-of-contents__link">缓存思想</a></li><li><a href="#缓存命中" class="table-of-contents__link">缓存命中</a></li></ul></li><li><a href="#虚拟内存" class="table-of-contents__link">虚拟内存</a><ul><li><a href="#虚拟内存的好处" class="table-of-contents__link">虚拟内存的好处</a></li><li><a href="#请求分页存储管理" class="table-of-contents__link">请求分页存储管理</a></li></ul></li><li><a href="#虚拟内存页表寻址" class="table-of-contents__link">虚拟内存页表寻址</a><ul><li><a href="#分页" class="table-of-contents__link">分页</a></li><li><a href="#页表" class="table-of-contents__link">页表</a></li><li><a href="#页表寻址" class="table-of-contents__link">页表寻址</a></li></ul></li><li><a href="#缺页中断" class="table-of-contents__link">缺页中断</a></li><li><a href="#分页系统地址映射" class="table-of-contents__link">分页系统地址映射</a></li><li><a href="#页面置换算法" class="table-of-contents__link">页面置换算法</a><ul><li><a href="#1-最佳" class="table-of-contents__link">1. 最佳</a></li><li><a href="#2-最近最久未使用" class="table-of-contents__link">2. 最近最久未使用</a></li><li><a href="#3-最近未使用" class="table-of-contents__link">3. 最近未使用</a></li><li><a href="#4-先进先出" class="table-of-contents__link">4. 先进先出</a></li><li><a href="#5-第二次机会算法" class="table-of-contents__link">5. 第二次机会算法</a></li><li><a href="#6-时钟" class="table-of-contents__link">6. 时钟</a></li></ul></li><li><a href="#分段" class="table-of-contents__link">分段</a></li><li><a href="#段页式" class="table-of-contents__link">段页式</a></li><li><a href="#分页与分段的比较" class="table-of-contents__link">分页与分段的比较</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.6833ce06.js"></script>
<script src="/assets/js/main.56997320.js"></script>
</body>
</html>