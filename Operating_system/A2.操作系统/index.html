<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Wiki Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Wiki Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">A2.操作系统 | My Wiki</title><meta data-react-helmet="true" property="og:url" content="https://worst0.github.io/Operating_system/A2.操作系统"><meta data-react-helmet="true" name="docsearch:language" content="en"><meta data-react-helmet="true" name="docsearch:version" content="current"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="A2.操作系统 | My Wiki"><meta data-react-helmet="true" name="description" content="[TOC]"><meta data-react-helmet="true" property="og:description" content="[TOC]"><meta data-react-helmet="true" property="og:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://worst0.github.io/Operating_system/A2.操作系统"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Operating_system/A2.操作系统" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Operating_system/A2.操作系统" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.060912d8.css">
<link rel="preload" href="/assets/js/runtime~main.27f44f86.js" as="script">
<link rel="preload" href="/assets/js/main.43fd085d.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/intro">Document💻</a><a class="navbar__item navbar__link" href="/blog">Blog🤓</a><a class="navbar__item navbar__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a><a class="navbar__item navbar__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">本站源码</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">🌙</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/intro">Document💻</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog🤓</a></li><li class="menu__list-item"><a class="menu__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a></li><li class="menu__list-item"><a class="menu__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></li><li class="menu__list-item"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="menu__link">本站源码</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">intro</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/intro">Readme</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">1.Linux</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Linux 命令</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A1.linux基础">A1.linux基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A2.Linux命令">A2.Linux命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A3.压缩">压缩</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A4.数据提取">数据提取</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A5.Linux命令补充">Linux命令</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">shell脚本</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/shell脚本语法">shell脚本语法</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">ubuntu</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C1.ubuntu相关">C1.ubuntu相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C2.ubuntu常用软件">ubuntu常用软件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C3.语言环境">语言环境</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">2.Algorithm</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">数据结构</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A1.DataStructure">数据结构和算法</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">算法设计</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B1.算法设计">算法设计</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.Algorithm">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/D1.ACM模板">ACM模板</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">数学</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E1.concrete">E1.concrete</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E2.Combinatorics">组合数学（Combinatorics）</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">3.Online_Judge</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">OJ</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/A1.Leetcode">A1.Leetcode</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/B1.HZOJ">HZOJ</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/C1.nowcoder">nowcoder</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/D1.EP">D1.EP</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">4.Programming_Language</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">C</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A1.CBasic">A1.CBasic</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A2.Cimprove">A2.Cimprove</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A3.C语言技巧">A3.C语言技巧</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">C++</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B1.C++">B1.C++</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B2.STL">STL</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B3.C++-exercise">C++-exercise</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B4.C++-others">C++ othres</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">python</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C1.python">C1.python</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C2.conda">C2.conda</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">5.Operating_system</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!" tabindex="0">操作系统</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/A1.os">OS</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/Operating_system/A2.操作系统">A2.操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/C1.计算机原理">C1.计算机原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Operating_system/D1.CSAPP">D1.CSAPP</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="0">系统编程</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B1.文件操作">文件操作</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B2.Linux命令行解析">Linux命令行解析</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B3.多进程">多进程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B4.多线程">多线程线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B5.IPC">IPC：进程间通信</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B6.IO">B6.IO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B7.mmap">B7.mmap</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B8.socket">B8.socket</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B9.文件传输">B9.文件传输</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B10.IO模型">B10.IO模型</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/B11.sleep和间隔计时器">B11.sleep和间隔计时器</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">6.Network</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A1.计算机网络">A1.计算机网络</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">7.Server</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/A1.Linux高性能服务器">Linux高性能服务器</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">8.Database</a><ul class="menu__list"></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">9.Programming_Stardard</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/A1.C编程规范">A1.C编程规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.编码英文缩写">B1.编码英文缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B2.英文标准缩写">B2.英文标准缩写</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">10.Skill</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/A1.Latex数学公式">A1.Latex数学公式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/B1.Markdown语法">B1.Markdown语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C1.git">C1.git</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C2.github">GitHub</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/D1.计算机英语">计算机英语</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">11.Interview</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/A1.面试">面试</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">99.other</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/A1.临时">临时</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/B1.临时笔记">临时笔记</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/C1.task">task</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">A2.操作系统</h1></header><div class="markdown"><p>[TOC]</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="计算机组成原理"></a>计算机组成原理<a class="hash-link" href="#计算机组成原理" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="研究对象"></a>研究对象<a class="hash-link" href="#研究对象" title="Direct link to heading">#</a></h2><p>计算机系统结构的研究对象是计算机物理系统的抽象和定义,具体包括:</p><ol><li>数据表示:定点数、浮点数编码方式,硬件能直接识别和处理的数据类型和格式等;</li><li>寻址方式:最小寻址单位,寻址方式种类,地址计算等;</li><li>寄存器定义:通用寄存器、专用寄存器等定义,结构,数量和作用等;</li><li>指令系统:指令的操作类型和格式,指令间排序和控制(微指令)等;</li><li>存储结构:最小编址单位,编址方式,主存和辅存容量,最大编址空间等;</li><li>中断系统:中断种类,中断优先级和中断屏蔽,中断响应,中断向量等;</li><li>机器工作状态定义和切换:管态、目态等定义及切换;</li><li>I/O系统:I/O接口访问方式,I/O数据源、目的、传送量.I/O通信方式,I/O操作结束和出错处理等;</li><li>总线结构:总线通信方式,总线仲裁方式,总线标准等;</li><li>系统安全与保密:检错、纠错,可靠性分析,信息保护,系统安全管理等.</li></ol><p>数字IC上1个引脚所能表示的0或者1二进制位</p><p>binary digit</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="基本知识"></a>基本知识<a class="hash-link" href="#基本知识" title="Direct link to heading">#</a></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="分层"></a>分层<a class="hash-link" href="#分层" title="Direct link to heading">#</a></h2><ul><li>高级语言层</li><li>汇编语言层</li><li>操作系统层 :软件</li><li>指令系统 :连接硬件与软件:指令能处理的运算,执行,对存储设备的读写,对外围设备的的输入输出</li><li>微体系结构 :硬件: 裸机:冯诺依曼体系:运算器,控制器,存储器,输入输出设备</li><li>数字逻辑层</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="英文"></a>英文<a class="hash-link" href="#英文" title="Direct link to heading">#</a></h2><p><strong>CPI</strong>:每条指令执行所需的时钟周期</p><p><strong>MIPS</strong>:每条执行多好百万条指令</p><p><strong>ASCII</strong>:美国信息交换标准码</p><p><strong>GB2312</strong>:国标码</p><p><strong>DRAM</strong>:动态随机存储器(内存) :dynamic random access memory</p><p>​			定期刷新,先读再写:保证信息不丢失(某些存储单元(继电器)长期不访问会丢失)</p><p><strong>cache</strong>:缓存. <strong>SRAM</strong>:静态随机存储器</p><p><strong>南桥</strong>:出入输出总线,主要联系USB,硬盘,网卡</p><p><strong>BIOS</strong>:写死到主板的一个内存芯片ROM</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cpu"></a>CPU<a class="hash-link" href="#cpu" title="Direct link to heading">#</a></h3><p>​	CPU(center processing unit:)运算器和控制器合称为中央处理器.外加微指令集</p><p>​	==CPU处理的所有数据来源于内存==</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="功能"></a>功能<a class="hash-link" href="#功能" title="Direct link to heading">#</a></h4><p>​	指令流指的是CPU执行的指令序列</p><p>​	数据流指的是根据指令操作要求依次存取数据的序列.
​	从程序运行的角度来看,CPU的基本功能就是对指令流和数据流在时间与空间上实施正确的控制.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="主要寄存器"></a>主要寄存器<a class="hash-link" href="#主要寄存器" title="Direct link to heading">#</a></h4><ol><li><strong>通用寄存器</strong>可用来存放原始数据和运算结果</li></ol><ul><li><p>有的还可以作为变址寄存器、计数器、地址指针等.</p></li><li><p>累加寄存器Acc也是一个通用寄存器,它用来暂时存放ALU运算的结果信息</p></li></ul><ol start="2"><li><strong>专用寄存器</strong>是专门用来完成某一种特殊功能的寄存器.</li></ol><ul><li><p>CPU中至少要有5个专用的寄存器.</p></li><li><p>程序计数器(PC):又称指令计数器:存放正在执行的指令地址或接着要执行的下条指令地址.</p></li><li><p>指令寄存器(IR):存放从存储器中取出的指令,在执行指令的过程中,指令寄存器的内容不允许发生变化,以保证实现指令的全部功能</p></li><li><p>存储器地址寄存器(MAR):保存当前CPU所访问的主存单元的地址.</p><ul><li>由于主存和CPU之间存在着操作速度上的差别,所以必须使用地址寄存器来保持地址信息,直到主存的读写操作完成为止.</li><li>当CPU和主存进行信息交换,无论是CPU向主存写数据,还是CPU从主存中读出指令时,都要使用存储器地址寄存器和数据寄存器.</li></ul></li><li><p>存储器数据寄存器(MDR):暂时存放由内存读出(或写入内存)的一条指令或一个数据字;</p></li><li><p>状态标志寄存器(PSWR):存放程序状态字(PSW).</p><ul><li><p>程序状态字的各位表征程序和机器运行的状态,是参与控制程序执行的重要依据之一.
它主要包括两部分内容</p></li><li><p>一是状态标志,如进位标志(CF)、辅助进位标志位(AF);溢出标志位(OF);零标志位(ZF);符号标志位(SF);奇偶校验标志位(PF)</p></li><li><p>二是控制标志,如:·方向标志(DF),表示串操作指令中字符串操作的方向;
中断允许标志位(IF),表示CPU是否能够响应外部的可屏蔽中断请求;
陷阱标志位(TF),为了方便程序的调试,使处理器的执行进入单步方式而设置的控制标志位.</p></li></ul></li><li><p>other寄存器</p></li><li><p>堆栈指针寄存器(sp): 寻址内存堆栈内的数据</p></li><li><p>段寄存器:确定逻辑段</p></li></ul><p><strong>控制器</strong>的主要功能有:</p><ol><li><p>从主存中取出一条指令,并指出下一条指令在主存中的位置.</p></li><li><p>对指令进行译码或测试,产生相应的操作控制信号,以便启动规定的动作.</p></li><li><p>指挥并控制CPU、主存和输入输出设备之间的数据流动方向.</p><p><img alt="image-20210422201716279" src="/assets/images/image-20210422201716279-b8716c207e1a6aaa6b6fdb628d69e137.png"></p></li></ol><p><strong>运算器</strong>的主要功能有:</p><ol><li>执行所有的算术运算；</li><li>执行所有的逻辑运算,并进行逻辑测试.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="参数"></a>参数<a class="hash-link" href="#参数" title="Direct link to heading">#</a></h4><p>​	<strong>CPU的字长</strong>是指在单位时间内同时处理的二进制数据的位数.
​	CPU按照其处理信息的字长可以分为:8位CPU、16位CPU、32位CPU以及64位CPU等.</p><p>​	<strong>地址总线宽度</strong>决定了CPU可以访问的最大的物理地址空间,简单地说就是CPU到底能够使用多大容量的主存.
​	例32位地址线,可寻址的最大容量为232=4096MB(4GB)</p><p>​	<strong>数据总线宽度</strong>则决定了CPU与外部Cache、主存以及输入输出设备之间进行一次数据传输的信息量.
​	如果数据总线为32位,每次最多可以读写主存中的32位;
​	如果数据总线为64位,每次最多可以读写主存中的64位.</p><p>如果想要输入输出位数(比特数)大于宽度比特的数据,就要以宽度比特为单位切分这个数据</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="时序系统和控制方式"></a>时序系统和控制方式<a class="hash-link" href="#时序系统和控制方式" title="Direct link to heading">#</a></h4><p><strong>指令部件</strong>指令部件的主要任务是完成取指令并分析指令.
指令部件包括:</p><ol><li>程序计数器</li><li>指令寄存器</li><li>指令译码器指令译码器又称操作码译码器或指令功能分析解释器.
暂存在指令寄存器中的指令只有在其操作码部分经过译码之后才能识别出这是一条什么样的指令,并产生相应的控制信号提供给微操作信号发生器.</li><li>地址形成部件地址形成部件根据指令的不同寻址方式,形成操作数的有效地址.
在微、小型机中,可以不设专门的地址形成部件,而利用运算器来进行有效地址的计算.</li></ol><p><strong>时序部件</strong>时序部件能产生一定的时序信号,以保证机器的各功能部件有节奏地进行信息传送、加工及信息存储.
时序部件包括:</p><ol><li>脉冲源脉冲源用来产生具有一定频率和宽度的时钟脉冲信号,为整个机器提供基准信号.
为使主脉冲的频率稳定,一般都使用石英晶体振荡器做脉冲源.
当计算机的电源一接通,脉冲源立即按规定的频率重复发出具有一定占空比的时钟脉冲序列,直至关闭电源为止.</li><li>启停控制逻辑只有通过启停控制逻辑将计算机启动后,主时钟脉冲才允许进入,并启动节拍信号发生器开始工作.
启停控制逻辑的作用是根据计算机(2)启停控制逻辑只有通过启停控制逻辑将计算机启动后,主时钟脉冲才允许进入,并启动节拍信号发生器开始工作.
启停控制逻辑的作用是根据计算机的需要,可靠地开放或封锁脉冲,控制时序信号的发生或停止,实现对整个机器的正确启动或停止.
启停控制逻辑保证启动时输出的第一个脉冲和停止时输出的最后一个脉冲都是完整的脉冲.</li><li>节拍信号发生器节拍信号发生器又称脉冲分配器.
脉冲源产生的脉冲信号,经过节拍信号发生器后产生出各个机器周期中的节拍信号,用以控制计算机完成每一步</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="时序系统"></a>时序系统<a class="hash-link" href="#时序系统" title="Direct link to heading">#</a></h4><ol><li><p><strong>指令周期</strong>是指从取指令、分析指令到执行完该指令所需的全部时间.</p></li><li><p><strong>机器周期</strong>又称CPU周期:通常把一个指令周期划分为若干个机器周期,每个机器周期完成一个基本操作.
一般机器的CPU周期有取指周期、取数周期、执行周期和中断周期等.</p></li><li><p><strong>节拍</strong>在一个机器周期内,要完成若干个微操作.这些微操作有的可以同时执行,有的需要按先后次序串行执行.
因而应把一个机器周期分为若干个相等的时间段,每一个时间段对应一个电位信号,称为节拍电位信号.
节拍的宽度取决于CPU完成一次微操作的时间,如:ALU一次正确的运算,寄存器间的一次传送等.&#x27;</p></li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cpu控制方式"></a>CPU控制方式<a class="hash-link" href="#cpu控制方式" title="Direct link to heading">#</a></h4><ol><li><p>同步控制方式即固定时序控制方式,各项操作都由统一的时序信号控制,在每个机器周期中产生统一数目的节拍电位和工作脉冲.
由于不同的指令操作时间长短不一致,所以同步控制方式应以最复杂指令的操作时间作为统一的时间间隔标准</p></li><li><p>异步控制方式即可变时序控制方式,各项操作不采用统一的时序信号控制,而根据指令或部件的具体情况决定,需要多少时间,就占用多少时间.
这是一种“应答”方式,各操作之间的衔接是由“结束—起始”信号来实现的.</p></li><li><p>联合控制方式..
实际上现代计算机中大多数是采用联合控制方式.
通常的设计思想是:在功能部件内部采用同步方式或以同步方式为主的控制方式,在功能部件之间采用异步方式.</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="运算"></a>运算<a class="hash-link" href="#运算" title="Direct link to heading">#</a></h3><ol><li>算术运算 :加、减、乘、除运算</li><li>逻辑运算 :逻辑乘、逻辑加、逻辑非和逻辑异或</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="总线"></a>总线<a class="hash-link" href="#总线" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cpu读存储器"></a>CPU读存储器<a class="hash-link" href="#cpu读存储器" title="Direct link to heading">#</a></h4><p>​	CPU首先通过<em>地址线</em>发出想要访问的存储单元的地址,即通过地址线首先找到访问对象;</p><p>​	然后通过<em>控制线</em>发出读信号,即通过控制线决定数据传输方向;
​	最后经过<em>数据线</em>把数据从存储器读到CPU,即通过数据线完成真正的数据传输.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="特性"></a>特性<a class="hash-link" href="#特性" title="Direct link to heading">#</a></h4><ol><li>共享性:所有部件同心共享</li><li>独占性:某一时刻只允许一个部件向总线发信息,而多个部件可同时收信息</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="io接口"></a>I/O接口<a class="hash-link" href="#io接口" title="Direct link to heading">#</a></h3><p>​	 外围设备借助于适配器通过总线和CPU实现了互连,并可进行可靠通信.适配器通常也称为IO接口</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="程序中断"></a>程序中断<a class="hash-link" href="#程序中断" title="Direct link to heading">#</a></h3><p>​	程序中断:如果外设与CPU以中断控制的方式进行通信时,每当外围设备向CPU请求某种动作时,接口模块即发生一个中断请求信号到CPU.例如,如果设备完成了一个操作或设备中存在着一个错误状态,接口即发出中断.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="指令系统"></a>指令系统<a class="hash-link" href="#指令系统" title="Direct link to heading">#</a></h2><p> 机器指令的基本格式一条指令就是机器语言的一个语句，<code>操作码字段OP+地址码字段A</code></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="地址码"></a>地址码<a class="hash-link" href="#地址码" title="Direct link to heading">#</a></h3><ol><li>第一操作数地址，A1</li><li>第二操作数地址，A2</li><li>操作结果存放地址，A3</li><li>下条将要执行指令的地址，A4</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="地址码结构"></a>地址码结构<a class="hash-link" href="#地址码结构" title="Direct link to heading">#</a></h4><ol><li><p>四地址指令: <code>OP A1 A2 A3 A4</code></p><p>(A1)OP(A2)→A3</p><p>A4=下条将要执行指令的地址</p><p>其中:OP表示具体的操作,Ai表示地址,(Ai)表示存放于该地址中的内容.</p><p>最大的缺点是指令的长度太长，如果每个地址为16位，整个地址码字段就要长达64位</p></li><li><p>三地址指令: <code>OP A1 A2 A3 </code></p><p>正常情况下,大多数指令按顺序依次被从主存中取出来,只有在遇到转移指令时,程序的执行顺序才会改变.
因此,可以用一个程序计数器( PC)来存放指令地址.
每当CPU从内存取完一条指令,PC就自动增值(增值量是所取指令在内存存放时所占的字节数),直接得到将要执行的下一条指令的地址.这样,指令中就不必再明显地给出下一条指令的地址了.</p><p>(A1)OP(A2)→A1</p><p>PC完成修改(隐含)</p><p>执行一条三地址的双操作数运算指令,至少需要访问4次主存.
第一次取指令本身,第二次取第一操作数,第三次取第二操作数,第四次保存运算结果</p></li><li><p>二地址指令: <code>OP A1 A2  </code></p><p>让第一操作数地址同时兼作存放结果的地址(目的地址)</p><p>(A1)OP(A2)→A1PC完成修改(隐含)其中:A1为目的操作数地址,A2为源操作数地址.</p><p>指令执行之后,目的操作数地址中原存的内容已被破坏了.
执行一条二地址的双操作数运算指令,同样至少需要访问4次主存 </p></li><li><p>二地址指令: <code>OP A1  </code></p><p>(Acc)OP(A1)→Acc</p><p>PC完成修改(隐含)</p><p>另一个操作数隐含在累加寄存器(Accumulator, Acc):在因为这个寄存器在连续性运算时,保存着多条指令连续操作的累计结果</p><p>指令的含义执行一条一地址的双操作数运算指令,只需要访问两次主存.
第一次取指令本身,第二次取第二操作数.第一操作数和运算结果都放在累加寄存器中,所以读取和存入都不需要访问主存.</p></li><li><p>零地址指令零地址指令格式中只有操作码字段,没有地址码字段,</p><p>OP</p><p>零地址的算术逻辑类指令是用在堆栈计算机中的,堆栈计算机没有一般计算机中必备的通用寄存器,因此堆栈就成为提供操作数和保存运算结果的唯一场所.
通常,参加算术逻辑运算的两个操作数隐含地从堆栈顶部弹出,送到运算器中进行运算,运算的结果再隐含地压入堆栈.</p></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="操作码"></a>操作码<a class="hash-link" href="#操作码" title="Direct link to heading">#</a></h3><p>指令系统中的每一条指令都有一个唯一确定的操作码，指令不同，其操作码的编码也不同</p><p>加法指令ADD:((R0))+(R1)→(R0)</p><p>转移指令JC</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="寻址技术"></a>寻址技术<a class="hash-link" href="#寻址技术" title="Direct link to heading">#</a></h3><p>寻址，指的是寻找操作数的地址或下一条将要执行的指令地址</p><p>寻址技术是计算机设计中硬件对软件最早提供支持的技术之一．</p><p>寻址技术包括编址方式和寻址方式．</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="编址方式"></a>编址方式<a class="hash-link" href="#编址方式" title="Direct link to heading">#</a></h4><p>通常,指令中的地址码字段将指出操作数的来源和去向,而操作数则存放在相应的存储设备中.</p><p>在计算机中,编址方式是指对各种存储设备进行编码的方式.主要有CPU中的通用寄存器、主存储器和输入输出设备</p><p>如果存储设备是CPU中的通用寄存器,在指令字中应给出寄存器编号;
如果是主存的一个存储单元,在指令字中应给出该主存单元的地址;
如果是输入输出设备(接口)中的一个寄存器,指令字中应给出设备编号或设备端口地址或设备映像地址(与主存地址统一编址时)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="寻址方式"></a>寻址方式<a class="hash-link" href="#寻址方式" title="Direct link to heading">#</a></h4><p>寻址可以分为</p><ol><li><p>指令寻址:找下一条将要执行的指令地址</p></li><li><p>数据寻址:寻找操作数的地址</p><p>指令寻址比较简单,它又可以细分为顺序寻址和跳跃寻址.
而数据寻址方式种类较多,其最终目的都是寻找所需要的操作数.
顺序寻址可通过程序计数器的增量修改,自动形成下一条指令的地址;
跳跃寻址则需要通过程序转移类指令实现.
跳跃寻址的转移地址形式方式有3种:直接(绝对)、相对和间接寻址</p></li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="存储器"></a>存储器<a class="hash-link" href="#存储器" title="Direct link to heading">#</a></h2><p>CPU寄存器-&gt;多级缓存(cache)-&gt;内存(main memory)-&gt;外存(secondary)</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="cache"></a>cache<a class="hash-link" href="#cache" title="Direct link to heading">#</a></h3><p>高速缓冲存储器:为了避免CPU与I/O设备争抢访存,可在CPU与主存之间加一级缓存,这样,主存可将CPU要取的信息提前送至缓存,一旦主存在与I/O设备交换时,CPU可直接从缓存中读取所需信息,不必空等而影响效率.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="基本结构"></a>基本结构<a class="hash-link" href="#基本结构" title="Direct link to heading">#</a></h4><ol><li>Cache存储体:以块为单位与主存交换信息,为加速Cache与主存之间的调动,主存大多采用多体结构,且Cache访存的优先级最高.</li><li>地址映射变换机构地址:将CPU送来的主存地址转换为Cache地址.
如果转换后的Cache块已与CPU欲访问的主存块建立了对应关系,即已命中,则CPU可直接访问Cache存储体.
如果转换后的Cache块与CPU欲访问的主存块未建立对应关系,即不命中,此刻CPU在访问主存时,不仅将该字从主存取出,同时将它所在的主存块一并调入Cache,供CPU使用.
当然,此刻能将主存块调入Cache内,也是由于主存块要装入的Cache块未被占用.
否则,已无法将主存块调入Cache内时,就得采用替换策略.</li><li>替换机构当主存块要装入的Cache块被占用,无法接受来自主存块的信息时,就由Cache内的替换机构按一定的替换算法来确定应从Cache内移出哪个块返回主存,而把新的主存块调入Cache.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="地址映射"></a>地址映射<a class="hash-link" href="#地址映射" title="Direct link to heading">#</a></h4><p>Cache-主存地址映射由主存地址映射到Cache地址称为地址映射.</p><ol><li>直接映射(固定的映射关系)</li><li>全相联映射(灵活性大的映射关系)</li><li>组相联映射(上述两种映射的折中).</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟存储器"></a>虚拟存储器<a class="hash-link" href="#虚拟存储器" title="Direct link to heading">#</a></h2><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3个地址空间"></a>3个地址空间<a class="hash-link" href="#3个地址空间" title="Direct link to heading">#</a></h4><ol><li>虚拟地址空间或逻辑地址空间,即程序员编写程序时使用的地址空间;</li><li>主存地址空间或物理地址空间,这个空间用于存放运行的程序和数据;</li><li>辅存地址空间,即磁盘存储器的地址空间,用于存放暂时不能调入主存</li></ol><p>虚拟存储器基本的信息交换单位(粒度)有几种不同的方案,即段、页和段页,这样主存一外存层次的基本信息传送单位可采用3种不同的方案:段、页或段页,这就形成了页式虚拟存储器、段式虚拟存储器、段页式虚拟存储器.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="快表"></a>快表<a class="hash-link" href="#快表" title="Direct link to heading">#</a></h4><ol><li>快表(translation look-aside buffer, TLB,变换旁查缓冲器)是一个专用的高速缓冲器(通常用相联存储器实现),用于存放近期经常使用的页表项</li><li>快表中的内容是页表部分内容的一个副本.</li><li>快表和页表同时查,快表中有,就能很快地找到对应的物理页号送入主存实地址寄存器,从而做到虽然采用虚存,但访问主存的速度几乎没有下降.</li></ol><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="存储保护"></a>存储保护<a class="hash-link" href="#存储保护" title="Direct link to heading">#</a></h4><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><div tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">1.  存储保护与操作系统相关,它包括两个方面,即存储区域保护和访问方式保护.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">2.  存储区域保护当多个用户共享主存时,应防止由于一个用户程序出错而破坏其他用户的程序和系统软件,以及一个用户程序不合法地访问未分配给它的主存区域</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">3.  访问方式保护对主存信息的使用可以有3种方式:读(R)、写(W)、执行(E),相应的访问方式保护就有R、W、E三者的逻辑组合,共8种,对不同用户给予不同的访问权限.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    这些访问方式通常作为程序状态字寄存器的保护位,并且和存储区域保护结合起来实现.</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="输入输出系统"></a>输入输出系统<a class="hash-link" href="#输入输出系统" title="Direct link to heading">#</a></h2><p>I/O设备与主机交换信息的三种控制方式</p><ol><li>程序查询:CPU通过程序不断查询IO设备是否已做好准备</li><li>程序中断:当出现异常情况或特殊情况进行处理,结束后,返回到现行程序的间断出,继续执行</li><li>DMA</li></ol><p>采用DMA方式可实现高速I/O设备与主机之间成组数据的交换</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="程序中断-1"></a>程序中断<a class="hash-link" href="#程序中断-1" title="Direct link to heading">#</a></h3><p>如果在设备准备的同时,CPU不作无谓的等待,而继续执行现行程序,只有当I/O设备准备就绪向CPU提出请求后,再暂时中断CPU现行程序转入I/O服务程序,这便产生了I/O中断.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="中断处理过程"></a>中断处理过程<a class="hash-link" href="#中断处理过程" title="Direct link to heading">#</a></h4><p>当CPU执行完一条现行指令时,如果外设向CPU发出中断请求,那么CPU在满足响应条件的情况下将发出中断响应信号,与此同时关闭中断(“中断屏蔽”触发器置“1”),表示CPU将不再受理另外一个设备的中断.这时,CPU将寻找中断请求源是哪一个设备,保留CPU当前程序计数器(PC)的内容.然后,它将转移到处理该中断源的中断服务程序.进入中断服务程序后首先需要CPU保存原程序的现场信息,然后进入设备服务(如交换数据),最后再恢复原程序的现场信息.在这些动作完成以后,开放中断(“中断屏蔽”触发器置“0”),并返回到原来被中断的主程序的下一条指令.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="基本接口"></a>基本接口<a class="hash-link" href="#基本接口" title="Direct link to heading">#</a></h4><ol><li>中断请求触发器和中断屏蔽触发器</li><li>排队器</li><li>中断向量地址形成<ul><li>CPU一旦响应了I/O中断,就要暂停现行程序,转去执行该设备的中断服务程序.
不同的设备有不同的中断服务程序,每个服务程序都有一个入口地址(中断向量), CPU必须找到这个入口地址.</li><li>中断向量地址就是中断服务程序入口地址(中断向量)的存放地址.
通常有两种方法寻找入口地址:硬件向量法(设置向量地址表存于存储器)和软件查询法.</li></ul></li></ol><p>提出中断请求,本身设备必须已就绪</p><p>CPU任何瞬间只可接受一个中断请求</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="中断服务程序的流程"></a>中断服务程序的流程<a class="hash-link" href="#中断服务程序的流程" title="Direct link to heading">#</a></h4><p>保护现场、中断服务、恢复现场和中断返回.</p><ol><li><p>保护现场</p><p>其一是保存程序断点;其二是保存通用寄存器和状态寄存器的内容.
前者由系统通过硬件自动完成,后者要靠中断服务程序这个软件来完成.
具体而言,可在中断服务程序的起始部分安排若干条存数指令,将寄存器的内容存至存储器中保存,或用进栈指令将各寄存器的内容推入堆栈保存,即将程序中断时的“现场”保存起来.</p></li></ol><ol start="2"><li>中断服务(设备服务)</li><li>恢复现场这是中断服务程序的结尾部分,要求在退出服务程序前,将原程序中断时的“现场”恢复到原来的寄存器中.
通常可用取数指令或出栈指令,将保存在存储器(或堆栈)中的信息回送到原来的寄存器中.</li><li>中断返回中断服务程序的最后一条指令通常是一条中断返回指令,使其返回到原程序的断点处,以便继续执行原程序.</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dma"></a>DMA<a class="hash-link" href="#dma" title="Direct link to heading">#</a></h3><p>直接内存访问(DMA),是一种完全由硬件执行交换的工作方式.
在这种方式中,DMA控制器完全接管CPU对总线的控制,数据交换不经过CPU,而直接在内存和I/O设备之间进行.
DMA方式一般用于高速传送成组数据.
DMA控制器将向内存发出地址和控制信号,修改地址.对传送的字的个数计数,并且以中断方式向CPU报告传送操作的结束.</p><p>DMA与CPU分时访问内存</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="dma与程序中断方式区别"></a>DMA与程序中断方式区别<a class="hash-link" href="#dma与程序中断方式区别" title="Direct link to heading">#</a></h3><p>① 从数据传送看,程序中断方式靠程序传送,DMA方式靠硬件传送.
② 从CPU响应时间看,程序中断方式是在一条指令执行结束时响应,而DMA方式可在指令周期内的任一存取周期结束时响应.
③ 程序中断方式有处理异常事件的能力,DMA方式没有这种能力,主要用于大批数据的传送,如硬盘存取、图像处理、高速数据采集系统等,可提高数据吞吐量.
④ 程序中断方式需要中断现行程序,故需保护现场;DMA方式不中断现行程序,无需保护现场.
⑤ DMA的优先级比程序中断的优先级高.</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="计算机操作系统"></a>计算机操作系统<a class="hash-link" href="#计算机操作系统" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="概论"></a>概论<a class="hash-link" href="#概论" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="三个关键问题"></a>三个关键问题<a class="hash-link" href="#三个关键问题" title="Direct link to heading">#</a></h3><p>虚拟化(virtualization)、并发(concurrency)和持久性(persistence)</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="程序运行时会发生什么？"></a>程序运行时会发生什么？<a class="hash-link" href="#程序运行时会发生什么？" title="Direct link to heading">#</a></h4><p>执行指令。处理器从内存中获取(fetch)一条指令,对其进行解码(decode)(弄清楚这是哪条指令),</p><p>然后执行(execute)它(做它应该做的事情,如两个数相加、访问内存、检查条件、跳转到函数等)。</p><p>完成这条指令后,处理器继续执行下一条指令,依此类推,直到程序最终完成</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="关键问题操作系统如何将资源虚拟化"></a>关键问题:操作系统如何将资源虚拟化<a class="hash-link" href="#关键问题操作系统如何将资源虚拟化" title="Direct link to heading">#</a></h4><p>操作系统如何将资源虚拟化？:它让系统更易于使用。</p><p>操作系统通过哪些机制和策略来实现虚拟化？</p><p>操作系统如何有效地实现虚拟化？</p><p>需要哪些硬件支持？</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟化virtualization"></a>虚拟化(virtualization)<a class="hash-link" href="#虚拟化virtualization" title="Direct link to heading">#</a></h4><p>操作系统将物理(physical)资源(如处理器、内存或磁盘)转换为更通用、更强大且更易于使用的虚拟形式。因此,我们有时将操作系统称为虚拟机(virtual machine)。</p><p>操作系统还提供了一些接口(API),供你调用。实际上,典型的操作系统会提供几百个系统调用(system call),让应用程序调用。</p><p>由于操作系统提供这些调用来运行程序、访问内存和设备,并进行其他相关操作,我们有时也会说操作系统为应用程序提供了一个标准库(standard library)。
最后,因为虚拟化让许多程序运行(从而共享CPU),让许多程序可以同时访问自己的指令和数据(从而共享内存),让许多程序访问设备(从而共享磁盘等),所以操作系统有时被称为资源管理器(resource manager)。每个CPU、内存和磁盘都是系统的资源(resource),因此操作系统扮演的主要角色就是管理(manage)这些资源</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟化cpu"></a>虚拟化CPU<a class="hash-link" href="#虚拟化cpu" title="Direct link to heading">#</a></h3><p>在硬件的一些帮助下,操作系统负责提供这种假象(illusion),即系统拥有非常多的虚拟CPU的假象。</p><p>将单个CPU(或其中一小部分)转换为看似无限数量的CPU,从而让许多程序看似同时运行,这就是所谓的虚拟化CPU</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟化内存"></a>虚拟化内存<a class="hash-link" href="#虚拟化内存" title="Direct link to heading">#</a></h3><p>(physical memory)模型非常简单。内存就是一个字节数组。</p><p>要读取(read)内存,必须指定一个地址(address),才能访问存储在那里的数据。</p><p>要写入(write)或更新(update)内存,还必须指定要写入给定地址的数据。</p><p>程序运行时,一直要访问内存。程序将所有数据结构保存在内存中,并通过各种指令来访问它们,例如加载和保存,或利用其他明确的指令,在工作时访问内存。</p><p>不要忘记,程序的每个指令都在内存中,因此每次读取指令都会访问内存。</p><p>每个进程访问自己的私有虚拟地址空间(virtual address space)(有时称为地址空间,address space),操作系统以某种方式映射到机器的物理内存上</p><p>一个正在运行的程序中的内存引用不会影响其他进程(或操作系统本身)的地址空间。对于正在运行的程序,它完全拥有自己的物理内存。但实际情况是,物理内存是由操作系统管理的共享资源。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="并发concurrency"></a>并发(concurrency)<a class="hash-link" href="#并发concurrency" title="Direct link to heading">#</a></h3><p>如何构建正确的并发程序如果同一个内存空间中有很多并发执行的线程,如何构建一个正确工作的程序？</p><p>操作系统需要什么原语？</p><p>硬件应该提供哪些机制？</p><p>我们如何利用它们来解决并发问题？
3条指令并不是以原子方式(atomically)执行(所有的指令一次性执行)的,所以奇怪的事情可能会发生。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="持久性persistence"></a>持久性(persistence)<a class="hash-link" href="#持久性persistence" title="Direct link to heading">#</a></h3><p>如何持久地存储数据文件系统是操作系统的一部分,负责管理持久的数据。持久性需要哪些技术才能正确地实现？</p><p>需要哪些机制和策略才能高性能地实现？</p><p>面对硬件和软件故障,可靠性如何实现？</p><p>持久性(persistence)。在系统内存中,数据容易丢失,因为像DRAM这样的设备以易失(volatile)的方式存储数值。如果断电或系统崩溃,那么内存中的所有数据都会丢失。因此,我们需要硬件和软件来持久地(persistently)存储数据。这</p><p>硬件以某种输入/输出(Input/Output,I/O)设备的形式出现。,硬盘驱动器(hard drive),固态硬盘(Solid-State Drive,SSD)</p><p>操作系统中管理磁盘的软件通常称为文件系统(filesystem)。因此它负责以可靠和高效的方式,将用户创建的任何文件(file)存储在系统的磁盘上。</p><p>第一个是对open()的调用,它打开文件并创建它。第二个是write(),将一些数据写入文件。第三个是close(),只是简单地关闭文件,从而表明程序不会再向它写入更多的数据。这些系统调用(system call)被转到称为文件系统(file system)的操作系统部分,然后该系统处理这些请求,并向用户返回某种错误代码。</p><p>你可能想知道操作系统为了实际写入磁盘而做了什么。文件系统必须做很多工作:首先确定新数据将驻留在磁盘上的哪个位置,然后在文件系统所维护的各种结构中对其进行记录。这样做需要向底层存储设备发出I/O请求,以读取现)有结构或更新(写入)它们。所有写过设备驱动程序(device driver</p><p>大多数文件系统都包含某种复杂的写入协议,如日志(journaling)或写时复制(copy-on-write),仔细排序写入磁盘的操作,以确保如果在写入序列期间发生故障,系统可以在之后恢复到合理的状态。为了使不同的通用操作更高效,文件系统采用了许多不同的数据结构和访问方法,从简单的列表到复杂的B树。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="设计目标"></a>设计目标<a class="hash-link" href="#设计目标" title="Direct link to heading">#</a></h3><p>操作系统实际上做了什么:它取得CPU、内存或磁盘等物理资源(resources),并对它们进行虚拟化(virtualize)。它处理与并发(concurrency)有关的麻烦且棘手的问题。它持久地(persistently)存储文件,从而使它们长期安全。</p><p>鉴找到合适的折中是建立系统的关键
一个最基本的目标,是建立一些抽象(abstraction),让系统方便和易于使用
设计和实现操作系统的一个目标,是提供高性能(performance)。换言之,我们的目标是最小化操作系统的开销(minimize the overhead)。虚拟化和让系统易于使用是非常值得的,但不会不计成本
另一个目标是在应用程序之间以及在OS和应用程序之间提供保护(protection)。因为我们希望让许多程序同时运行,所以要确保一个程序的恶意或偶然的不良行为不会损害其他程序。。保护是操作系统基本原理之一的核心,这就是隔离(isolation)。让进程彼此隔离是保护的关键,因此决定了OS必须执行的大部分任务。
操作系统也必须不间断运行。当它失效时,系统上运行的所有应用程序也会失效。由于这种依赖性,操作系统往往力求提供高度的可靠性(reliability)。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="历史"></a>历史<a class="hash-link" href="#历史" title="Direct link to heading">#</a></h3><p>系统调用和过程调用之间的关键区别在于,系统调用将控制转移(跳转)到OS中,同时提高硬件特权级别(hardwareprivilege level)。用户应用程序以所谓的用户模式(usermode)运行,这意味着硬件限制了应用程序的功能。</p><p>例如,以用户模式运行的应用程序通常不能发起对磁盘的I/O请求,不能访问任何物理内存页或在网络上发送数据包。在发起系统调用时 [通常通过一个称为陷阱(trap)的特殊硬件指令],硬件将控制转移到预先指定的陷阱处理程序(trap handler)(即预先设置的操作系统),并同时将特权级别提升到内核模式(kernel mode)。在内核模式下,操作系统可以完全访问系统的硬件,因此可以执行诸如发起I/O请求或为程序提供更多内存等功能。当操作系统完成请求的服务时,它通过特殊的陷阱返回(return-from-trap)指令将控制权交还给用户,该指令返回到用户模式,同时将控制权交还给应用程序,回到应用离开的地方。
多道程序时代: I/O进行和任务中断时,要支持多道程序和重叠运行。内存保护(memory protection)等问题变得重要。我们不希望一个程序能够访问另一个程序的内存。了解如何处理多道程序引入的并发(concurrency)问题也很关键。在中断存在的情况下,确保操作系统正常运行是一个很大的挑战。</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟化"></a>虚拟化<a class="hash-link" href="#虚拟化" title="Direct link to heading">#</a></h1><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="抽象进程"></a>抽象:进程<a class="hash-link" href="#抽象进程" title="Direct link to heading">#</a></h2><p>进程(process)就是程操作系统为正在运行的程序提供的抽象。程序本身是没有生命周期的,它只是存在磁盘上面的一些指令(也可能是一些静态数据)。</p><p>关键问题:如何提供有许多CPU的假象？虽然只有少量的物理CPU可用,但是操作系统如何提供几乎有无数个CPU可用的假象？</p><p>操作系统通过虚拟化(virtualizing)CPU来提供这种假象。通过让一个进程只运行一个时间片,然后切换到其他进程,操作系统提供了存在多个虚拟CPU的假象。这就是时分共享(time sharing)CPU技术
要实现CPU的虚拟化:操作系统就需要一些低级机制以及一些高级智能。我们将低级机制称为机制(mechanism)。机制是一些低级方法或协议,实现了所需的功能。上下文切换(context switch),它让操作系统能够停止运行一个程序,并开始在给定的CPU上运行另一个程序。</p><p>所有现代操作系统都采用了这种分时机制。</p><p>提示:使用时分共享(和空分共享)时分共享(time sharing)是操作系统共享资源所使用的最基本的技术之一。</p><p>通过允许资源由一个实体使用一小段时间,然后由另一个实体使用一小段时间,如此下去,所谓的资源(例如,CPU或网络链接)可以被许多人共享。时分共享的自然对应技术是空分共享,资源在空间上被划分给希望使用它的人。</p><p>例如,磁盘空间自然是一个空分共享资源,因为一旦将块分配给文件,在用户删除文件之前,不可能将它分配给其他文件。
这些机制之上,操作系统中有一些智能以策略(policy)的形式存在。</p><p>策略是在操作系统内做出某种决定的算法。</p><p>例如,给定一组可能的程序要在CPU上运行,操作系统应该运行哪个程序？</p><p>操作系统中的调度策略(scheduling policy)会做出这样的决定,可能利用历史信息(例如,哪个程序在最后一分钟运行得更多？)、工作负载知识(例如,运行什么类型的程序？)以及性能指标(例如,系统是否针对交互式性能或吞吐量进行优化？)来做出决定。</p><p>为了理解构成进程的是什么,我们必须理解它的机器状态(machine state):程序在运行时可以读取或更新的内容</p><p>在任何时刻,机器的哪些部分对执行该程序很重要？进程的机器状态有一个明显组成部分,就是它的内存。指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存(称为地址空间,address space)是该进程的一部分。进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器,
程序计数器(Program Counter,PC)(有时称为指令指针,Instruction Pointer或IP)告诉我们程序当前正在执行哪个指令;
类似地,栈指针(stack pointer)和相关的帧指针(frame pointer)用于管理函数参数栈、局部变量和返回地址。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="进程api"></a>进程API<a class="hash-link" href="#进程api" title="Direct link to heading">#</a></h4><p>创建(create):操作系统必须包含一些创建新进程的方法。在shell中键入命令或双击应用程序图标时,会调用操作系统来创建新进程,运行指定的程序。</p><p>销毁(destroy):由于存在创建进程的接口,因此系统还提供了一个强制销毁进程的接口。当然,很多进程会在运行完成后自行退出。但是,如果它们不退出,用户可能希望终止它们,因此停止失控进程的接口非常有用。</p><p>等待(wait):有时等待进程停止运行是有用的,因此经常提供某种等待接口。</p><p>其他控制(miscellaneous control):除了杀死或等待进程外,有时还可能有其他控制。例如,大多数操作系统提供某种方法来暂停进程(停止运行一段时间),然后恢复(继续运行)。</p><p>状态(statu):通常也有一些接口可以获得有关进程的状态信息,例如运行了多长时间,或者处于什么状态。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="进程创建"></a>进程创建<a class="hash-link" href="#进程创建" title="Direct link to heading">#</a></h4><p>操作系统运行程序必须做的第一件事是将代码和所有静态数据(例如初始化变量)加载(load)到内存中,加载到进程的地址空间中。程序最初以某种可执行格式驻留在磁盘上(disk,或者在某些现代系统中,在基于闪存的SSD上)。因此,将程序和静态数据加载到内存中的过程,需要操作系统从磁盘读取这些字节,并将它们放在内存中的某处.将代码和静态数据加载到内存后,操作系统在运行此进程之前还需要执行其他一些操作。必须为程序的运行时栈(run-timestack或stack)分配一些内存。你可能已经知道,C程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存,并提供给进程。操作系统也可能会用参数初始化栈。具体来说,它会将参数填入main()函数,即argc和argv数组。操作系统也可能为程序的堆(heap)分配一些内存。在C程序中,堆用于显式请求的动态分配数据。程序通过调用malloc()来请求这样的空间,并通过调用free()来明确地释放它。数据结构(如链表、散列表、树和其他有趣的数据结构)需要堆。起初堆会很小。随着程序运行,通过malloc()库API请求更多内存,操作系统可能会参与分配更多内存给进程,以满足这些调用。操作系统还将执行一些其他初始化任务,特别是与输入/输出(I/O)相关的任务。例如,在UNIX系统中,默认情况下每个进程都有3个打开的文件描述符(file descriptor),用于标准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。在本书的第3部分关于持久性(persistence)的知识中,我们将详细了解I/O、文件描述符等。
通过将代码和静态数据加载到内存中,通过创建和初始化栈以及执行与I/O设置相关的其他工作,OS现在(终于)为程序执行搭好了舞台。然后它有最后一项任务:启动程序,在入口处运行,即main()。通过跳转到main()例程(第5章讨论的专门机制),OS将CPU的控制权转移到新创建的进程中,从而程序开始执行。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="进程状态"></a>进程状态<a class="hash-link" href="#进程状态" title="Direct link to heading">#</a></h4><p>运行(running):在运行状态下,进程正在处理器上运行。这意味着它正在执行指令。</p><p>就绪(ready):在就绪状态下,进程已准备好运行,但由于某种原因,操作系统选择不在此时运行。</p><p>阻塞(blocked):在阻塞状态下,一个进程执行了某种操作,直到发生其他事件时才会准备运行。一个常见的例子是,当进程向磁盘发起I/O请求时,它会被阻塞,因此其他进程可以使用处理器。,让进程在就绪状态和运行状态之间转换。从就绪到运行意味着该进程已经被调度(scheduled)。从运行转移到就绪意味着该进程已经取消调度(descheduled)。一旦进程被阻塞(例如,通过发起I/O操作),OS将保持进程的这种状态,直到发生某种事件(例如,I/O完成)。此时,进程再次转入就绪状态(也可能立即再次运行,如果操作系统这样决定)。</p><p>数据结构操作系统是一个程序,和其他程序一样,它有一些关键的数据结构来跟踪各种相关的信息。例如,为了跟踪每个进程的状态,操作系统可能会为所有就绪的进程保留某种进程列表(process list),以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种方式跟踪被阻塞的进程。当I/O事件完成时,操作系统应确保唤醒正确的进程,让它准备好再次运行。
作系统追踪进程的一些重要信息。对于停止的进程,寄存器上下文将保存其寄存器的内容。当一个进程停止时,它的寄存器将被保存到这个内存位置。通过恢复这些寄存器(将它们的值放回实际的物理寄存器中),操作系统可以恢复运行该进程。我们将在后面的章节中更多地了解这种技术,它被称为上下文切换(context switch)。
,除了运行、就绪和阻塞之外,还有其他一些进程可以处于的状态。有时候系统会有一个初始(initial)状态,表示进程在创建时处于的状态。另外,一个进程可以处于已退出但尚未清理的最终(final)状态(在基于UNIX的系统中,这称为僵尸状态[插图])。这个最终状态非常有用,因为它允许其他进程(通常是创建进程的父进程)检查进程的返回代码,并查看刚刚完成的进程是否成功执行(通常,在基于UNIX的系统中,程序成功完成任务时返回零,否则返回非零)。完成后,父进程将进行最后一次调用(例如,wait()),以等待子进程的完成,并告诉操作系统它可以清理这个正在结束的进程的所有相关数据结构。
补充:数据结构—进程列表操作系统充满了我们将在这些讲义中讨论的各种重要数据结构(data structure)。进程列表(process list)是第一个这样的结构。这是比较简单的一种,但是,任何能够同时运行多个程序的操作系统当然都会有类似这种结构的东西,以便跟踪系统中正在运行的所有程序。有时候人们会将存储关于进程的信息的个体结构称为进程控制块(Process ControlBlock,PCB),这是谈论包含每个进程信息的C结构的一种方式。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="图片"></a>图片<a class="hash-link" href="#图片" title="Direct link to heading">#</a></h2><p><img alt="image-20210410215648862" src="/assets/images/image-20210410215648862-e0b260aea593576d02d23ca011469bf3.png"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="抽象"></a>抽象<a class="hash-link" href="#抽象" title="Direct link to heading">#</a></h1><p><img alt="img" src="/assets/images/2019072110111033-586b312a47e624f84bd54ed50ac0a3ab.png"></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="概论-1"></a>概论<a class="hash-link" href="#概论-1" title="Direct link to heading">#</a></h1><p><strong>操作系统提供的另一个常见的抽象层是基于进程的抽象。我们在使用计算机时总是感到程序是连续运行的，但是实际由于计算机物理资源的有限性，一个程序在处理器上的运行大多数时候是不连续的（这取决于操作系统进程调度所用的算法）。计算机只有有限数量的内核，不可能为所有程序提供全部处理器时间，一定会有程序在运行过程中被切换为另一个程序，一段时间后再继续运行。同样地，计算机的有限内存迫使一个程序的一部分内存被留在磁盘中，只有一些数据会实际存在于系统内存中。+因此我们在使用计算机时所认为的连续使用处理器、将全部数据存储在内存中的程序是不存在的，这种独占全部内存和处理器时间运行的程序来源于操作系统对于物理资源的抽象，也就是我们所说的“进程”。</strong></p><p>这种抽象大大方便了多个程序同时在系统中运行——程序设计者不需要考虑其它软件在内存中所占的大小和位置，也不需要考虑上下文切换（上下文切换即从一个进程切换到另一个进程的过程，我们在讲进程时会更具体地探讨这个过程）时切换内存、保留处理器状态等复杂的过程，而只需要考虑自己所设计的程序在独占全部资源的理想状态下的运行情况。</p><p>如果进程可以直接与物理资源发生接触，那么一个进程就可以修改磁盘上所有数据，直接导致数据丢失，使其它程序无法运行。操作系统作为一个抽象层可以在给用户进程提供服务的同时保证无相应权限的用户无法对物理资源进行利用，防止上述情况发生。同样，由于每个进程都在抽象的内存空间中进行读写操作，它们不能直接接触到其它进程的内存，这保护了每个进程不受到其它恶意进程的侵害。</p><p>执行操作系统的核心功能（提供公共服务、协调进程交互、构建虚拟机、管控物理资源）的部分称为 操作系统内核（kernel)</p><p>在处理输入值时，我们很多时候需要用这个函数将不同的参数分隔开</p><p><code>char* strtok(char* str, const char* delimiters);</code> 这个函数将输入的字符串str用输入的分隔符delimiters分为更短的字符串。delimiters是一个含有多个字符的字符串，其中每一个字符都是一个独立的分隔符。如\n\t中\n和\t分别可以作为独立的分隔符。需要注意的是，strtok会修改输入的字符串str；因此如果你想保留原有的字符串，最好先用strcpy将原有的字符串复制到另一个字符串里，然后再将字符串输入到strtok里分割。当我们将一个字符串str输入到strtok里后，strtok会返回一个指向第一个由非分隔符字符的指针的分割片段；之后的每一次调用，我们都会把NULL作为第一个参数，如果调用成功就会返回下一个分割片段，如果已经到达str的末尾则会返回NU</p><p>调试工具</p><p>gdb:<a href="http://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener noreferrer">http://sourceware.org/gdb/current/onlinedocs/gdb/</a></p><p>valgrind:<a href="https://www.valgrind.org/" target="_blank" rel="noopener noreferrer">https://www.valgrind.org/</a></p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="进程"></a>进程<a class="hash-link" href="#进程" title="Direct link to heading">#</a></h1><p><strong>由于计算机所拥有的物理资源有限，当多个程序在计算机上同时运行时，它们不可能连续地在处理器上运行或占用全部内存，因此我们需要进程的抽象在用户的一侧隐藏上下文切换等细节。进程作为运行的程序的抽象，包含了一个程序的运行状态和这个程序所用的抽象内存及其中存储的数据。我们将后一部分，即一个进程可以使用的全部内存的地址和它们存储的数据，称为这个进程的 地址空间（address space）。我们可以将进程笼统地看做是一个或多个线程与一个地址空间的结合。</strong></p><p>一方面，进程的结构必须能够囊括一个进程的运行状态，在由于中断、异常或系统调度进入内核态时我们应该能够将进程的运行状态放入内存中的某一位置，使我们可以在某一个时间点根据进程的优先级接着这次的进度再次运行该进程；另一方面，由于进程在用户一侧对内存进行了抽象，我们需要在系统一侧包含从抽象内存向实际内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址和其中存储的数据。</p><p>为了实现上述的第一个目的，即在进程中存储其运行状态，我们将在进程中存储处理器状态寄存器、指令计数器、栈指针、通用寄存器等代表了进程目前的运行状态的值。由于现代计算机中往往有多个核或多个处理器，我们的程序可以达到 并行（parallelism，即在物理时间上同时运行，区别于多个进程在处理器上的并发（concurrency）），因此同一个进程可能同时包含有多个不同的运行状态。为了更好地区分进程在一个处理器上的运行状态和进程本身的运行状态，我们在此引入 线程（thread） 的概念。</p><p>每个线程拥有一个 线程控制块（thread control block, TCB），用来存储我们上述提到的处理器状态寄存器、指令计数器、栈指针、通用寄存器等数值，但同一个进程中的所有线程都共享同一个地址空间。</p><p><img alt="img" src="/assets/images/d623ba5f1e352fe303ada7d6e4554aa74cc59e8f-9b4236d6696914531e29e2dccde802f6.png"></p><p>在前文我们已经提到，一个用户进程所看到的内存空间是抽象的，区别于实际的物理内存，因此为了支持进程从抽象内存获取物理内存中存储的信息，我们需要在进程中包含从抽象内存向物理内存的映射，即该系统所用的地址转换方法所需要的信息。地址转换有很多种不同方法，包括分页存储、分段存储等，它们都需要不同的信息来实现地址转换；</p><p> 在 Base and Bound 方法中，系统将一段连续的物理内存分配给一个进程，Base 代表基地址，即系统分配给一个进程的可用内存的起始地址，Bound 代表这个进程可用的内存的最高地址。为了读写物理内存，我们将基地址与抽象内存地址相加，获得实际地址；</p><p>只要实际地址不大于 Bound，内核就会允许进程进行该操作。因此在这个方法中，为了实现进程地址空间的抽象，进程在系统一侧的数据结构中必须包括这段可用的内存的基地址、可用长度。</p><p>为了能在一个进程开始运行的时候方便地载入上面提到的两方面的数据，我们需要一个数据结构来包含这些数据。这个数据结构就是 进程控制块（Process Control Block, PCB）。对于内核来说，它是进程存在的唯一标识。</p><p>进程控制块中存储的信息除了上面提到的实现地址转换的信息和表示运行状态的线程信息以外，还包括了很多系统在调度进程时需要的信息，比如进程号、进程所处状态（我们将在下一节中更多地解释进程可能所处的状态与不同状态间的切换）、进程的优先级等等。需要注意的是，我们不会将整个地址空间中包含的地址及其数据都存储在进程控制块里；我们只需要可以帮助我们从抽象内存地址获得实际物理地址的方法，而实际数据仍然存储在内存的对应位置中。 由于进程控制块中的信息包含了优先级、基地址、可用地址范围等用户进程不应该有权限修改的信息，用户进程不应该有权限修改进程控制块。因此我们将进程控制块存储在内核空间中。</p><p>，处于就绪态的进程不会因为遇到任何事件而无法进入等待态；处于等待状态的进程在事件发生后考虑到优先级等问题，必须先回到就绪状态而不能直接运行。</p><p><img alt="img" src="/assets/images/b49f9d2d90d601cb3ff832695ce1727592adba5b-f5e7770a85c51bdce78716daad06d227.png"></p><p>一个进程在运行结束或产生重大错误（如：企图越权使用内核的特权指令）后会被系统终止。但我们在由fork()产生的子程序中也可以用exit()系统调用主动结束这个程序。</p><p> void exit(int status); </p><p>exit()函数在stdlib.h头文件中；它的参数status表示这个进程退出时的结束状态。</p><p>当我们用这个函数结束一个子进程时，status会作为子进程的结束状态被提供给wait()的第一个参数。 </p><p>pid_t wait(int* stat_loc); </p><p>但我们也可以把这个设为NULL，函数仍可以正常运行。wait()函数会使父进程的状态变为等待态，直到父进程的所有子进程中的 一个 成功退出并返回结束状态值，父进程才可以进入就绪状态，准备继续运行；</p><p>如果在wait()被调用时已经有可用的结束状态值，那么wait()会立即返回。</p><p>wait()返回的值是返回结束状态值的子进程的进程标识 ID；</p><p>如果在等待过程中出现了错误（如已经没有可等待的子进程），那么wait()将返回 -1</p><p>注意，父进程直接不能等待子进程的子进程！</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="地址管理"></a>地址管理<a class="hash-link" href="#地址管理" title="Direct link to heading">#</a></h1><p>每个进程都拥有自己的 地址空间（Address Space），包括这个进程可以使用的全部地址和其中存储的所有数据；为了防止不同进程修改彼此的地址空间，操作系统需要将进程的逻辑地址转换为物理内存中的实际地址，这一过程可以由不同方法实现。</p><p>碎片即在内存中无法有效利用的部分，分为外部碎片和内部碎片。</p><p>外部碎片（external fragmentation） 指的是因为长度过短而无法被使用的 未分配内存；</p><p>相对的，内部碎片（internal fragmentation） 指的是 已分配内存 中因为分配长度过长而没有被进程有效利用的内存。</p><p><img alt="img" src="/assets/images/a90cd422be8383843c86cb431d37a9324155f712-474f19101b701fdd6786f44238b3a876.png"></p><p>每一个进程在获得一段连续的内存后将内存的 基地址（Base） 和 限长（Bound） 存入进程控制块中；每次进程需要读写内存时，系统利用进程控制块中存储的基地址和限长检查进程是否企图使用超出其分配范围外的内存，从而达到保护进程不受其它进程侵害的目的。</p><p>在连续内存管理中，由于每个进程都只有一块连续的内存，我们只能将整个进程都移出内存，因此我们一般会选择处于等待态的进程移出内存。如果我们选择运行态或就绪态的进程移出内存，那么这个进程的响应时间就会被延长，影响系统效率。但是如果没有进程处于等待态，我们应该把哪一部分内存移出呢？参考上面的覆盖技术我们可以知道，一个进程并不是同时需要其地址空间的所有部分都处于内存中，因此理想状态下，我们应该可以只把运行需要的部分留在内存中，而系统将自动把其它部分移出。这就是非连续存储管理的意义。</p><p>分段存储管理会将进程的逻辑地址分为两部分，段号和段内位移。每一个进入系统的进程都会拥有自己的段表，表中的每一行都对应着段号等于行号的段的段长和基址，以及一些用于限制这一段的操作权限的保护位（如是否可读、可写）。这样我们就可以通过段号获取逻辑地址所对应的段的基址，然后将段长与位移作比较，如果位移未超过段长则将位移与基址相加，得到实际的物理地址。由于系统对于段号和段内位移的尾数做出了限制，如果在 32 位系统中段号由 i 位组成，则用户进程在设计分段时不能设计超出 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">2^i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></span> 个段，每段长度不能超过 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mn>32</mn><mo>−</mo><mi>i</mi></mrow></msup></mrow><annotation encoding="application/x-tex">2^{32-i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.824664em;vertical-align:0em"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">2</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></span>字节。</p><p>每次进程在对内存进行操作时，都必须用段号作为行号进入该进程的段表，获取基址和段长；如果段号大于该进程的最大段号，或进程对这一地址的操作不被该段允许，或逻辑地址中的段内位移大于段长，则硬件会触发异常，这就是你在写 C 程序时可能会见到的段错误（Segmentation fault）。 下面的图片可以给你一个对于分段存储管理的更加直观的理解：</p><p><img alt="img" src="/assets/images/e7dbcf00c0b327beba3387876cd9f6088a83d16e-63d1d6c648318b4c550c2b0728b5c50a.png"></p><p>分段存储的优点是，不同进程间可以共享一段逻辑上相对独立的内存，比如两个运行同一程序的进程可以共享代码分段，两个公用一个库的进程可以共享只包含这个库的段。</p><p>但分段存储也有一个明显的缺点：它的每一个段大小不固定，因此可能面临内存中存在很多外部碎片，需要移动已有进程才能运行新进程的局面。</p><p>分页存储管理：为了将地址空间中的⻚与物理内存⾥的⻚框相对应，每⼀个进程有⾃⼰的⻚表， ⻓度由进程所需的⻚⾯数决定，我们可以在第 ⾏查看⻚⾯号（逻辑地址）等 于 的⻚⾯在物理内存中对应的实际⻚框号。第 ⾏中同时也包含⼀些其他的 信息，如读写权限位（read bit and write bit）、表⽰⻚⾯是否实际存在于内存 中的有效位（valid bit）、表⽰⻚⾯是否被修改过的 ⻚⾯重写标志位（dirty bit） 等等，我们会在讲到请求分⻚虚拟存储管理时更具体地讲到这些内容。 从⻚表中获得⻚框号后，我们可以将⻚框号与位移合成该逻辑地址对应的物理地 址。为了分配⻚⾯给不同的进程，系统将需要⼀个内存物理块表，⽤来记录⻚框 状态，即哪些⻚框还未被分配，已分配的⻚框属于哪些进程等等；在新进程进⼊ 系统后，我们将在内存物理块表中寻找未被分配的⻚框给这个进程使⽤。</p><p><img alt="img" src="/assets/images/68cfe794b03b8f9a4cb268a5e9d92566d44a10b1-1380e8e6acfdd7f74756706177ab0dbb.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">分段与分⻚都会将⼀个进程的地址空间分为⼏个⼩段，将这些⼩段分别存储在连续的⼀段内存中，但同⼀进程的不同段可能存储在不连续的内存中；</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    它们的不同点在于，分⻚完全根据⼀个固定的⼤⼩将内存分为⼤⼩相等的段，与内存中所存储的内容⽆关，⽽分段存储管理是根据内存的逻辑结构将内存分为⼏个部分。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ⼀种常⻅的分段⽅法是将进程内存分为代码、数据、栈和堆四部分，然后将这⼏个部分分别存放在⼏段可能相互不连续的内存中；</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    ⽽在分⻚的存储模式中，栈可能会分布在⼏个在物理内存中不连续的⻚⾯中。另⼀点不同是，在分⻚存储管理中，⻚的划分是⽤⼾进程不可⻅的；⽽在分段存储管理中，段的划分是⽤⼾进程可⻅的，可以根据⾃⼰的需求和逻辑地址结构的限制来⾃⾏划分段。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">分段和分⻚也可以被结合起来使⽤：我们可以将每个段对应⼀个⻚表，这样每次需要将内存中的⼀些部分与外存中的部分对换时，我们可以只对换某⼀段中的⼀⻚，⽽不是将整个段移出内存，这就解决了分段内存中由段落⼤⼩不同造成的外部碎⽚问题。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><img alt="image-20210327194006666" src="/assets/images/image-20210327194006666-21bd314617185fef8678f6e1ef4d2544.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">多级⻚表的想法很简单，即将原来的⻚号分为两部分，⽤第⼀部分将原来的⼤⻚</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">表分为⼏个⼩⻚表，称为⻚表⻚，将每个⻚表⻚分别存在内存的⼀个位置，然后</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">将这些位置与我们⽤来区分⻚表⻚的⻚⾯号的第⼀部分⼀⼀对应，形成⼀个⻚⽬</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">录表。我们在转换地址时先通过⻚号的第⼀部分⻚表⽬录找到⼀个⻚表⻚，然后</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">再⽤⻚号的第⼆部分在该⻚表⻚中找到⻚框号；因此我们将⻚号的第⼀部分称为</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">⻚⽬录位移，⻚号的第⼆部分称为⻚表⻚位移。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><img alt="img" src="/assets/images/9999291df18f209292bb6cee274daf5e027bb2c8-1d92abcc0a03cf8a9d776a38f8e82c55.png"></p><p>固定分区存储管理+内存被分为大小不同的固定的几个分区，每个分区只能被分配给一个进程。+主要缺点是可能有很多内部碎片，+且当进程内存需求大于任何一个分区的大小时需要采用复杂的技术解决这一问题。</p><p>+可变分区存储管理+内存分区大小可变，由进程需要的内存大小决定；+空闲的分区按一定顺序被排列在一个链表中，在新进程进入系统时被分配给进程。+分配给进程的空闲分区包含的进程需要的大小以外的内存将作为新的空闲分区加入链表；+一个进程撤销后其分区重新成为空闲分区，与周围的空闲分区合并后进入链表。+主要缺点是一段时间后会产生很多外部碎片，需要移动所有进程来产生足够大的空闲分区分配给新进程。</p><p>+分段存储管理+将进程的逻辑地址空间按照程序结构分为几段，每一段在内存中获得一段连续的内存。+优点是便于共享，缺点是由于每段的长度不同，容易产生外部碎片。</p><p>+单级分页存储管理+将逻辑地址分为页号与页内位移两部分，+在转换逻辑地址的过程中，系统将页号作为索引进入每个进程的页表，寻找对应的页框号，+将页框号与页内位移合成物理地址。+其优点是不会产生外部碎片，且易于保护进程和在不同进程间共享页面，+缺点是页表所占的空间与逻辑地址空间大小成正比，所占内存过大。</p><p>+多级分页存储管理+将单级分页存储管理中逻辑地址里的页号进一步分为页目录位移和页表页位移，+将页目录位移相同的逻辑地址放入同一页表页，+通过页目录位移找到页表页起始地址后再从页表页中寻找页框号。+其优点是，可以不将所有页表页都留在内存中，节省空间，+其缺点是，每访问一次内存实际都对应三次访问内存，因此效率较低。</p><p>+反置页表+以进程标识符和页号作为哈希函数的输入值，用哈希函数的输出值找到一个反置页表项，+对比进程标识符与页号是否相同，如果不同则跟随哈希指针查看下一个项，+如果相同则将对应的页框号与页内位移组合，获得物理地址。+其优点是反置页表的大小与物理内存大小成正比，所占空间远小于一般页表；+缺点是反置页表中只存储存在于物理内存中的页面，其他页面仍需设立一般页表来存储</p><p>这种方法被称为 最近最少使用方法（Least Recently Used，LRU）</p><p>TLB翻译快表</p><p><img alt="image-20210327194648039" src="/assets/images/image-20210327194648039-889bbdd2145a85ca49769fb85377b8e4.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">分⻚存储管理中，对⼀个地址的操作需要⾄少两次访问内存，因此我们想通过节省地址转换的时间来提⾼效率。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">当⼀个进程所需的⻚⾯⽐物理内存⼤时，我们就只将运⾏所需的⻚⾯保留在内存中，将其它⻚⾯保留在读写速度较慢的外存中。因此当我们发现⼀个⻚⾯不在内存中（即⻚表中或翻译快表中该⻚⾯对应的有效位为 </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain">时，我们就触发了 缺⻚异常（Page Fault Exception），原本负责地址转换的 存储管理部件（MMU） 会将控制权交给内核，⽽内核会使进程进⼊等待态，选择⼀个空闲的⻚框或将⼀个内存中的⻚⾯移出⾄外存，将所缺⻚⾯从外存复制到该空闲⻚框中。这⼀过程就被称为请求分⻚虚存管理，即只在需要⻚⾯时将⻚⾯从外存调⼊内存。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">⼀类是全局替换算法，⼀类是局部替换算法，前者从物理内存的全部⻚⾯中 选</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">取⼀个⻚⾯进⾏替换，⽽后者只从需要调⼊⻚⾯的进程本⾝的⻚⾯⾥选取⼀个</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">替换。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">在翻译快表中⽤到的 FIFO（先进先出算法）、LRU（最近最少⽤到算法） 和 Random （随机算法） 依然适⽤于全局替换算法。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    最佳⻚⾯替换算法（OPT）要求系统在需要从外存调⼊⼀个新⻚⾯时选择内存中 未来最⻓的⼀段时间内不会被⽤到的⻚⾯ 来替换</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    不存在的OPT最佳页面置换</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><img alt="img" src="/assets/images/05bbed7621307dd00311b697cdf88b85a4cc6177-dede2713264bfd849f5d9f4ddc0f396a.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">将逻辑地址分为⻚号和⻚内位移两部分。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">查看该⻚号是否存在于 TLB 中，如果存在且该⻚⾯有效位为 </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain">，则直接将对应的⻚框号与⻚内位移组合、获得物理地址；如果存在但⻚⾯⽆效，则触发缺⻚异常。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">通过 MMU 中存放的⻚表基址进⼊⻚表，查找与⻚号对应的⻚表项，如果有效则将对应的⻚框号与⻚内位移组合、获得物理地址；否则触发缺⻚异常。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">操作系统在缺⻚异常被触发后存储进程的运⾏状态，将进程设为等待态，然后选择⼀个空闲⻚框或应⽤⻚⾯替换算法选择⼀个被替换的⻚⾯，将被请求的⻚⾯装⼊该⻚框。操作系统将等待中的进程重新设为就绪态，⼀段时间后继续运⾏。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">通过 TLB 获得进程的⻚表基址，进⼊⻚表获取⻚框号，如果有效则将对应的⻚框号与⻚内位移组合、获得物理地址；否则触发缺⻚异常。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>了fork()，我们可以通过这个系统调用产生一个子进程，然后用exec()在子进程中执行另一个程序，在父进程中调用wait()等待进程运行完毕，但这样父进程中只能获得进程的退出码，这之外的数据我们就无法获得了；而随着子进程的终止，子进程的地址空间也会被系统回收，我们就更无法获得它的数据了。为了能够读取这个数据，我们只有把它存储在一个两个进程都能读取、且不会随着进程的终止而被回收的存储位置，这个位置就是外存。</p><p>，我们可以利用一个文件进行 进程间的通信（Inter-process Communication，IPC。进程 A 终止前将输出值写入这个文件，然后进程 B 再将这个文件的内容作为输入值读取进来，开始运行。</p><p>实际上，一段内存的共享也是通过将一个共享的文件同时映射到两个进程的地址空间实现的。</p><p> 另一种进程间通信的方法就是 信号（Signal）。信号类似于异常和中断，是异步的；</p><p>进程在接到信号后在内核态通过对应的信号处理函数来处理该信号。</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="文件"></a>文件<a class="hash-link" href="#文件" title="Direct link to heading">#</a></h1><p>文件是对外存中存储的数据的抽象，而外存实际上就是磁盘（disk），固态硬盘（SSD，Solid State Drives），磁带（tape）等物理存储设备。这些存储设备与鼠标、键盘、屏幕等无异，都属于 I/O 设备，你可以向这些设备里输入数据，或从这些硬件中获得我们想要的输出数据。因此，从文件中读取数据或向文件中写入数据实际都属于 I/O 的范畴</p><p>利用open()返回给我们的 文件描述符（file descriptor）。一个文件描述符就是一个整数，用来代表一个被打开的文件。每个文件描述符都对应一个文件内指针，表示这个被打开文件的实例中指针的位置，也就是说如果一个文件被同一个进程打开了多次，那么这几个文件描述符中的指针位置可能是不同的</p><p>每个系统都对一个进程可以同时打开的文件数量有限制；每个进程都有一个由文件描述符指向文件的 文件描述符表（file descriptor table）。open()每次一般会把新打开的文件放到这个表格中的某个空行，然后返回这个文件描述符。需要注意的是，这个文件描述符只是这个进程中代表这个这个文件的描述符，其它进程即使打开同一个文件也可能有不同的文件描述符；</p><p><strong>只有由fork()产生的子进程才会有和父进程一样的文件描述符。</strong> </p><p><code>#include &lt;unistd.h&gt; 2 int dup2(int oldfd, int newfd);</code></p><p> dup2()能够使newfd指向oldfd指向的文件；如果newfd本来对应着其他的文件，那么就关掉原来的文件，再使它指向oldfd指向的文件。通过调用dup2()，我们可以把标准输出和标准错误都关掉，而将 1，2 文件描述符替换为我们想要的文件</p><p><code>#include &lt;unistd.h&gt; int dup(int oldfd);</code></p><p>dup()会选择最小的空闲文件描述符，使它指向oldfd指向的文件，它返回的是新的指向这个文件的描述符。这样在调用dup2()以前，我们可以先用dup()复制一个指向标准输出的文件描述符，然后用dup2()关闭原来的标准输出的文件描述符。</p><p>无缓冲IO：read()，write()，lseek()，fsync()和close()。</p><p>lseek()： <code>off_t lseek(int fd, off_t offset, int whence); </code></p><p>SEEK_END，SEEK_SET和SEEK_CUR</p><p>我们完成了读取文件数据和向文件写入数据的操作后，我们需要注意一点，<strong>那就是我们写入的数据可能没有实际被写入磁盘！向外存中写入数据是很花时间的，因此内核为了提高效率会推迟实际写入数据。为了确保我们的数据确实进入了外存，我们需要调用int fsync(int fd);</strong> 这个函数在成功调用时返回 0，否则返回 -1。</p><p>最后，在完成对文件的所有操作后，一定要记得关掉这个文件。在系统中如果有多个进程同时打开了一个文件，而其中一个进程删除了这个文件时，打开这个文件的进程不能突然产生错误，因此内核需要统计一个文件被多少个进程打开，在使用这个文件的进程数为零后再回收这段内存。 <code>int close(int fd);</code></p><p>文件描述符只在进程的范围内有意义，换到另一个进程中后就不再指向同一个文件了 这个问题的答案就是，匿名管道两端的进程必须具有共同祖先；它们从同一个祖先继承了同样的文件描述符表，因此它们的文件描述符指向同一个文件。这是匿名管道的局限性</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ipc"></a>IPC<a class="hash-link" href="#ipc" title="Direct link to heading">#</a></h1><p>命名管道（FIFO）。你一定在想，FIFO 不是先进先出的意思吗，为什么这里变成了命名管道呢这是因为管道在写入数据时采取的也是先入先出的策略。下面这个系统调用允许我们建立一个命名管道 int mkfifo(const char* pathname, mode_t mode); 我们可以看到，这个系统调用的第一个参数是一个路径名称，这个路径名称就是我们的管道的名称；第二个参数mode表示的是这个命名管道的权限可以被umask命令修改。</p><p>命名管道与匿名管道的不同在于命名管道自创建以后就可以被任何进程像使用一般文件那样使用；即使创建管道的进程已经退出，管道仍然存在，只有在被删除后才会消失。它不同于一般文件的一点在于读取数据的进程和写入数据的进程必须同时出现；假如一个进程要求读取数据，而没有进程正在向这个管道写入数据，那么它就会被阻塞（block），直到有写入数据的进程出现时它才会开始读取数据并最终返回。</p><p>epoll()。它被用于在一段时间内同时等待多个文件产生我们希望的 I/O 事件；在这段时间结束后，epoll()会返回这段时间里产生等待的 I/O 事件的文件数量，并允许我们通过一个指向包含 I/O 事件的数据结构的指针遍历所有产生的事件。</p><p>在初始化epoll()时我们需要调用下面这个函数：</p><p>int epoll_create(int size); 参数size表示的是epoll()需要监控的文件描述符的总数量</p><p>由于系统具备了动态分配内存的能力，size这个参数会被自动忽略，但我们仍需要输入一个大于 00 的数，以保证新版本系统仍能兼容老版本系统。 这个函数成功时返回的值是一个非零的文件描述符，代表一个新的epoll()实例。注意，在结束使用epoll()后我们需要关闭这个文件描述符，以便于系统回收资源。</p><p>。向epoll()中加入新的等待事件、从epoll()中删除等待事件和修改epoll()中现有的等待事件这三种功能都可以通过一个函数实现，</p><p>int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event); </p><p>它的第一个参数epfd是代表epoll()实例的文件描述符，也就是我们刚才调用epoll_create()返回的值；</p><p>op有三个可能的值： 1 EPOLL_CTL_ADD EPOLL_CTL_MOD 3EPOLL_CTL_DEL</p><p> struct epoll_event中data是可以被自由使用、方便进程在事件产生后获取有关事件的信息的；一般我们会将与事件关联的文件描述符存储在data.fd里，这样事件发生后我们才能知道事件是由哪个文件产生的。而events一般是几个由或运算连接在一起的事件，我们在这里只介绍几个常见的事件：</p><p> 1 EPOLLIN // 文件有数据可供读取 </p><p>2 EPOLLOUT // 文件可以被写入数据 </p><p>3 EPOLLERR // 文件出现了错误，epoll() 默认会监控这个事件 4</p><p> EPOLLHUP // 文件被挂起，epoll() 默认会监控这个事件</p><p>。epoll_wait()返回时，我们可以通过返回值获得实际产生时间的数量，然后根据这个数量遍历events中的每一项；在每一个struct epoll_event的结构中，data都与我们之前添加或修改这个事件时代入的data一致，因此我们可以通过data获得我们之前存储的信息。 当timeout为 0 时，epoll_wait()会立即返回，即使没有事件产生；反之，当它被设为一个负值时，epoll_wait()就会一直等到有事件发生时再返回。</p><p>中断产生时进程会通过中断向量表获得处理中断的函数地址进入内核态处理中断；信号类似于中断，可能由一些运行过程中的指令触发，也可能由键盘输入或其它进程触发，但它的处理函数可以由用户定义。</p><p>^C 发送的就是一个信号，SIGINT。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly C"><div tabindex="0" class="prism-code language-C codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;sys/types.h&gt; </span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">#include &lt;signal.h&gt;</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">int kill(pid_t pid, int sig);</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>kill()代入两个参数，pid和sig，根据两者的不同的值，kill()会有不同的表现： 当pid和sig都大于 00 时，kill()会给进程标识符等于pid的进程发送sig； 如果pid为 00 而sig大于 00 ，那么kill()会给当前进程所在的进程组中的所有进程发送sig()信号； 如果pid为 -1−1 而sig大于 00，那么kill()会给除第一个进程（init 进程，操作系统运行的第一个进程，是所有用户进程的祖先，如果这个进程退出，那么操作系统就会退出）外的目前运行的所有进程发送sig；在 Linux 中这个选项不会给自己发送信号，为了给自己发送信号，我们需要使pid等于getpid()； 如果pid小于 -1−1 而sig大于 00，那么kill()将会给所有进程组标识符等于-pid的进程组发送sig； 最后，如果sig为 00，那么kill()不会实际发送任何信号，但它仍然会检查是否存在以pid为进程（组）标识符的进程（组）；这种用法经常被用来检查以pid为标识符的进程或进程组是否存在。</p><p>信号被发出后，会被内核检测到，Linux 内核会调用do_signal()执行收到的信号；如果用户定义了某一信号的处理方式，那么信号的处理可能会在用户空间发生。类似于中断的处理，系统会先将进程当前的运行状态存放到信号处理栈上，然后再调用信号处理函数。在信号处理函数执行完毕后，只要进程没有退出或停止，它都会调用sigreturn()回到系统空间，下一次运行该进程时就会从信号栈获取原来的运行状态后继续运行</p><p>消息队列。消息队列相对于管道有⼀个好处，就是读取消息和写⼊消息的两 个进程不需要同时出现；它就像公共邮箱⼀样，⼀个进程把消息发送到邮箱中后 另⼀个进程可以过⼀段时间再来阅读。当然，我们后⾯就会看到，我们也可以把 消息队列和信号联⽤，这样我们就可以让收信⽅第⼀时间得到通知，处理消息</p><p>⽂件实现的 mmap() ；它能够通过将外存中的⽂件映射到⼀段内存中使多个进程在其地址空间中共享⼀段内存。 mmap() 也可以不基于任何⽂件，我们在下⾯的讲解中会讲到这⼀部分⽤法。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">include</span><span class="token macro property"> </span><span class="token macro property string" style="color:rgb(195, 232, 141)">&lt;sys/mman.h&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">void</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> addr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">size_t</span><span class="token plain"> length</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> prot</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> flags</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> fd</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">off_t</span><span class="token plain"> offset</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">munmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">void</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain"> addr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">size_t</span><span class="token plain"> length</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>mmap() 的第⼀个参数 addr 表⽰的是我们希望⽤于映射⽂件的⼤概位置；在不 同的实现⽅法下， mmap() 实际选择的地址是不同的，很可能并不等于 addr 。 当我们将 作为 addr 代⼊时， mmap() 就会选择任意的地址进⾏映射（当然， 它不会选择 或其它已经映射的内存区域）。 length ， fd 和 offset 这三个参数 分别表⽰映射的内存的⻓度，被映射的⽂件所对应的⽂件描述符和映射在⽂ 件中起始的位置（相对于⽂件开头的偏移）。 接下来我们将重点讲解 prot 和 flags 这两个参数；它们决定了 mmap() 的模式。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">/*defined in &lt;sys/mman.h&gt;*/</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">PROT_READ </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 表⽰可以读取映射内存区的数据</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">PROT WRITE </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">//表⽰可以向映射内存区写⼊数据</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly cpp"><div tabindex="0" class="prism-code language-cpp codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 的第⼀个参数 addr 表⽰的是我们希望⽤于映射⽂件的⼤概位置；在不</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">同的实现⽅法下， </span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 实际选择的地址是不同的，很可能并不等于 addr 。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">当我们将 作为 addr 代⼊时， </span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 就会选择任意的地址进⾏映射（当然，</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">它不会选择 或其它已经映射的内存区域）。 length ， fd 和 offset 这三个参数</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">分别表⽰映射的内存的⻓度，被映射的⽂件所对应的⽂件描述符和映射在⽂</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">件中起始的位置（相对于⽂件开头的偏移）。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">接下来我们将重点讲解 prot 和 flags 这两个参数；它们决定了 </span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 的模式。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">与 prot 搭配使⽤的是 flags ，它表⽰映射内存的模式。它常⽤的值包括下⾯⼏个</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">值：</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">MAP_SHARED 和 MAP_PRIVATE 两个标志必须使⽤⼀个且只使⽤⼀个，它们可以被</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">或运算与其它的标志连接在⼀起。⾃ Linux kernel </span><span class="token number" style="color:rgb(247, 140, 108)">2.4</span><span class="token plain"> 起，Linux 开始⽀持</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">将 MAP_SHARED 与 MAP_ANONYMOUS 联⽤，⽤于在两个进程间共享⼀段不与⽂件关联的内存，但这种⽤法仅限于有共同祖先的进程，因为映射不基于⽂件⽽只取决</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">于进程⾃⼰的地址空间。注意，如果我们使⽤ MAP_SHARED 和 PROT_WRITE ，那么⽤⼾必须拥有向 fd 对应的⽂件写⼊数据的权限。</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">MAP_SHARED </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 使进程对于⽂件的修改对其它映射该⽂件的进程可⻅并被写⼊原⽂件</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">MAP_PRIVATE </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 与 MAP_SHARED 相反，使进程对于⽂件的修改对其它映射该⽂件的</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">MAP ANONYMOUS </span><span class="token comment" style="color:rgb(105, 112, 152);font-style:italic">// 使映射不基于任何⽂件；⼤部分实现中 fd 与 offset 会被忽略</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 是以⻚为单位分配映射内存区的，因此 </span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 返回的地址⼀定是⻚⾯⼤⼩ 的整数倍。如果 length 不到⻚⾯⼤⼩的整数倍，那么 </span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 分配的内存会有未被使 ⽤的部分；如果进程尝试使⽤这⼀部分内存，那么就会触发 SIGBUS 信号，产⽣ 错误。同样的，当我们试图⽤ </span><span class="token function" style="color:rgb(130, 170, 255)">munmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 关闭⼀个映射时，其参数 addr 必须是⻚⾯ 的整数倍，否则会产⽣错误。 </span><span class="token function" style="color:rgb(130, 170, 255)">munmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 的第⼆个参数 length 可以与我们⼀开始映射 的内存⼤⼩不同⸺我们可以映射⻓度相当于 个⻚⾯的⼤⼩的⽂件到内存中， 然后只关闭其中 个⻚⾯的映射。注意，关闭 fd 并不能关闭这段映射，只 有 </span><span class="token function" style="color:rgb(130, 170, 255)">munmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 可以关闭⼀段映射。</span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 除了可以被⽤于进程间通信，还可以被⽤来提⾼读写⽂件的效率：如果两个进程都需要读取同⼀个⽂件的同⼀段内容，那么我们就可以⽤ </span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 使这两个⽂件公⽤⼀段内存。这会⼤⼤节省将⽂件复制到内存中的时间。 </span><span class="token function" style="color:rgb(130, 170, 255)">mmap</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 也⽅便我们对⼀个⽂件进⾏随机的读写；</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">在多线程状态下，每个线程拥有⼀个⾃⼰的栈和程序计数器（PC），⽽堆，地址空间和全局变量则是多个线程共⽤的。每个线程对应⼀个叫做 线程控制块（Thread Control Block，TCB） 的数据结构，⾥⾯存储了这个线程的栈指针、程序计数器、处理器状态、线程标识符（类似于进程标识符，是系统中唯⼀明这个线程的⼀个数字）    多进程不共享地址空间在不同进程间切换时，由于进程地址空间不同，我们需要清空翻译快表和基于逻辑地址的⾼速缓冲存储器，这⼀过程会使我们的程序运⾏效率⼤打折扣    #include </span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain">pthread</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain">h</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> pthread </span><span class="token function" style="color:rgb(130, 170, 255)">create</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">pthread t </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">thread</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">const</span><span class="token plain"> pthread attr t </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">attr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">start_routine</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">arg</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain">    start_routine 是⼀个指向函数的指针，这个被创建的新线程将只执⾏这⼀个函数；你可以看到，它的参数必须是⼀个泛型指针，它的返回值也必须是⼀个泛型指针。最后⼀个参数 arg 就是⽤来传递给 start_routine 的参数。之所以要使⽤泛型指针，是因为我们希望传⼊数据的类型不要被限制。我们可以⾃⼰定义⼀个需要的数据结构，然后将指向该结构的指针作为泛型指针传⼊，函数也能够正常运⾏成功创建返回</span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">    ⼀个线程被创建后，创建这个线程的原线程仍会继续运⾏，⼀个新的线程会进⼊就绪态，等待运⾏。⼀旦新线程开始运⾏，它就会开始执⾏你输⼊ </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_create</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 的函数，它会有⼀个⾃⼰独⽴的栈。这时如果我们想从原来的线程中获得新线程的返回值就需要调⽤ pthread_join ：它的第⼀个参数 thread 就是我们从 pthread_create 获得的线程标识符，这个函数会等待线程标识符等于 thread 的线程运⾏完毕，并将它的返回值存⼊后⼀个参数 </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">retval 所指的位置。如果这个函数运⾏成功，那么它会返回 ，并将线程返回值存储到 retval 所指的位置；否则它会返回⼀个错误码#include </span><span class="token operator" style="color:rgb(137, 221, 255)">&lt;</span><span class="token plain">pthread</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain">h</span><span class="token operator" style="color:rgb(137, 221, 255)">&gt;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_join</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_t</span><span class="token plain"> thread</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">retval</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain">锁是⽤来锁住数据的，⽽不是⽤来锁住代码的。你的每个锁⼀定会有它保护的共享数据，所有调⽤和修改该数据的操作都会被锁保护。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">上⾯的代码就是⼀种实现锁的⽅法；由于不能获得锁的线程会在 </span><span class="token keyword" style="font-style:italic">while</span><span class="token plain"> loop中不断循环，这种实现⽅法被很形象地称为 ⾃旋锁（Spinlock）。这种⽅法有⼀个显⽽易⻅的缺点，那就是它的效率很低，假设⼀个线程企图获得⼀个另⼀个线程已经持有的锁时，它会不断循环，浪费处理器时间。因此，⾃旋锁只适⽤于已知单个线程持有锁时间很短的情况。</span><span class="token keyword" style="font-style:italic">struct</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">lock</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> value</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">lock_acquire</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">struct</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">lock</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">my_lock</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token keyword" style="font-style:italic">while</span><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token function" style="color:rgb(130, 170, 255)">test_and_set</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">&amp;</span><span class="token plain">my_lock</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">value</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">return</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token keyword" style="font-style:italic">void</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">lock_unlock</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token keyword" style="font-style:italic">struct</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">lock</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">my_lock</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">{</span><span class="token plain">my_lock</span><span class="token operator" style="color:rgb(137, 221, 255)">-&gt;</span><span class="token plain">value </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">return</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token punctuation" style="color:rgb(199, 146, 234)">}</span><span class="token plain">互斥的定义是⼀段代码不能同时被两个线程运⾏，⽽我们现在希望达到的⽬的是使得两个线程不能同时运⾏两段需要锁的代码，因此我们需要⼀个⼯具通知⼀个线程另⼀个线程已经解锁，然后让想要获得锁的线程按⼀定顺序获得锁、分别运⾏。这种协调多个线程运⾏速度的⾏为被称作 同步    某个条件不成⽴时，需要该条件成⽴的线程可以对与这个条件相对应的条件变量调⽤ </span><span class="token function" style="color:rgb(130, 170, 255)">wait</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 函数， </span><span class="token function" style="color:rgb(130, 170, 255)">wait</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 函数会将这个线程加⼊等待名单，并进⼊阻塞态，并⾃动解锁；当某个线程修改这个条件涉及到的变量时，线程必须⾃⾏调⽤ </span><span class="token function" style="color:rgb(130, 170, 255)">signal</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain">或 </span><span class="token function" style="color:rgb(130, 170, 255)">broadcast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 。 </span><span class="token function" style="color:rgb(130, 170, 255)">signal</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 和 </span><span class="token function" style="color:rgb(130, 170, 255)">broadcast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 的区别是 </span><span class="token function" style="color:rgb(130, 170, 255)">signal</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 只会将等待名单上⼀个线程唤醒，由阻塞态变为就绪态，⽽ </span><span class="token function" style="color:rgb(130, 170, 255)">broadcast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 会将等待名单上所有线程都有阻塞态变为就绪态。收到信号的线程回到就绪态的线程此时仍然处于 </span><span class="token function" style="color:rgb(130, 170, 255)">wait</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 函数中 没有返回，当内核选择继续运⾏该线程时，线程会获得其 原来持有的锁，然后再从 </span><span class="token function" style="color:rgb(130, 170, 255)">wait</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 函数返回。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">信号量与条件变量的⼀⼤区别在于条件变量 没有内部状态。⽐如，如果⼀个线程调⽤了 </span><span class="token function" style="color:rgb(130, 170, 255)">signal</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> ，此时没有变量在等待这个条件发⽣变化，那么这个 </span><span class="token function" style="color:rgb(130, 170, 255)">signal</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 就不会产⽣任何影响。在条件变为不成⽴后，下⼀个来等待这个条件的线程不会因为前⾯曾经有线程调⽤过 </span><span class="token function" style="color:rgb(130, 170, 255)">signal</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 就不等待。信号量就不同了。如果⼀个信号量的初始值为</span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> ，⼀个线程在没有线程在 </span><span class="token function" style="color:rgb(130, 170, 255)">P</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 中等待时调⽤了 </span><span class="token function" style="color:rgb(130, 170, 255)">V</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> ，信号量的值就会被增加⾄ </span><span class="token number" style="color:rgb(247, 140, 108)">1</span><span class="token plain">。这时如果有⼀个线程调⽤ </span><span class="token function" style="color:rgb(130, 170, 255)">P</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> ，则它⽆需经过任何等待，因为前⾯线程的历史被信号量保留了下来。 信号量与条件变量相⽐还有⼀个缺点，那就是条件变量在等待时会将保护共享数据的锁⾃动解锁，但 </span><span class="token function" style="color:rgb(130, 170, 255)">P</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 没有这个功能，因此我们⼀般会在调⽤ </span><span class="token function" style="color:rgb(130, 170, 255)">P</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> 以前解锁，否则其它线程就⽆法修改共享数据，造成永远等待的局⾯。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token macro property directive-hash">#</span><span class="token macro property directive keyword" style="font-style:italic">include</span><span class="token macro property"> </span><span class="token macro property string" style="color:rgb(195, 232, 141)">&lt;pthread.h&gt;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_mutex_init</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">restrict mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token keyword" style="font-style:italic">const</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutexattr_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">restrict attr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token function" style="color:rgb(130, 170, 255)">pthread_mutex_init</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token operator" style="color:rgb(137, 221, 255)">&amp;</span><span class="token plain">mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> </span><span class="token constant" style="color:rgb(130, 170, 255)">NULL</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain">mutex </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> PTHREAD_MUTEX_INITIALIZER</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token plain">这两个函数都以指向锁的指针为参数，成功时返回 </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">，否则返回错误码。注意，如果⼀个线程企图获得锁时另⼀个线程已经持有了这个锁，那么调⽤ pthread_mutex_lock 的线程就会被阻塞，直⾄解锁后这个线程被内核选择作为下⼀个锁的持有者时才能继续运⾏。为了避免在这个等待过程中浪费太多时间，我们可以调⽤下⾯这个函数：它的⾏为与 pthread_mutex_lock ⼀致，但是在⽆法获得锁时它会⽴即返回，返回值等于 EBUSY ，成功获得锁时它则会返回 。</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_mutex_lock</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_mutex_unlock</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_mutex_trylock</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_mutex_destroy</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> 与 </span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> ⾮常类似，也需要初始化和摧毁，并且在没有属性参数的情况下也可以⽤⼀个宏初始化：</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_condattr_t</span><span class="token plain"> 可以被⽤来设置⼀个条件变量的处理器时钟和条件变量是否可以被其他进程使⽤，</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_cond_destroy</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">cond</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_cond_init</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">restrict cond</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token keyword" style="font-style:italic">const</span><span class="token plain"> </span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_condattr_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">restrict attr</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> cond </span><span class="token operator" style="color:rgb(137, 221, 255)">=</span><span class="token plain"> PTHREAD_COND_INITIALIZER</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_cond_broadcast</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">cond</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_cond_signal</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">cond</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_cond_timedwait</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">restrict cond</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token plain"> pt</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span><span class="token keyword" style="font-style:italic">int</span><span class="token plain"> </span><span class="token function" style="color:rgb(130, 170, 255)">pthread_cond_wait</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_cond_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">restrict cond</span><span class="token punctuation" style="color:rgb(199, 146, 234)">,</span><span class="token class-name" style="color:rgb(255, 203, 107)">pthread_mutex_t</span><span class="token plain"> </span><span class="token operator" style="color:rgb(137, 221, 255)">*</span><span class="token plain">restrict mutex</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token punctuation" style="color:rgb(199, 146, 234)">;</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="死锁"></a>死锁<a class="hash-link" href="#死锁" title="Direct link to heading">#</a></h1><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">⾯临 死锁（deadlock），也就是⼏个线程循环等待其它线程持有的锁、导致所有线程都不能继续运⾏的情况    我们可以总结出死锁出现的四个必要条件（注意，这四个条件 不是死锁产⽣的充分条件）。⾸先，为了产⽣死锁，⼏个线程必须争抢资源，这就说明资源必须是有限的。在资源⽆限的情况下，我们永远不可能产⽣死锁，因为等待的线程可以获得另⼀个空闲的等价资源。    其次，锁⼀旦被⼀个线程获得，就不能再被召回，除⾮这个线程主动放弃这个锁。如果系统可以强制剥夺⼀个线程对于锁的所有权，那么它就可以在线程循环等待时从⼀个线程处取回锁分配给另⼀个线程，打破循环等待。    另外，线程在等待时必须保留它之前获得的锁，否则循环等待永远⽆法产⽣。    最后，⼏个线程间必须有循环等待（⽐如，A 等 B，B 等 C，C 等A）。    由于这四个条件是死锁产⽣的必要条件，只要我们保证这四个条件中有⼀个不成⽴，我们就可以防⽌死锁产⽣。    第⼀个条件不成⽴，我们可以保证有⾜够多的资源⸺在哲学家就餐问题中，我们只要再增加⼀只筷⼦，根据抽屉原理，我们就可以确定⾄少⼀个⼈可以拿到⼀双筷⼦，因此不会产⽣死锁。为了使第⼆个条件不成⽴，我们可以给予系统在必要的情况下回收资源的能⼒。为了使第三个条件不成⽴，我们可以将获得多个锁的过程拆分成多个只获得⼀个锁的过程，也就是说如果我需要修改被锁 A，B，C 分别保护的三组数据，那么我先获得锁 A、修改它对应的数据，然后释放 A、再获得 B。这样⼀个线程同时只持有⼀个锁，循环等待就不可能出现了。为了使第四个条件不成⽴，我们可以规定获取锁的顺序。前⼏⻚中我们展⽰的代码之所以会出现死锁，是因为两个线程获取锁的顺序不同。如果两个线程都先获取 A、再获取 B，那么⼀个线程要么获得两个锁、要么⼀个锁都获得不了，循环等待也就不会出现了。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">银⾏家算法需要记录系统当前空闲的各类资源的总量、已分配给各个线程的各类资源的量和每个线程需要的各类资源的最⼤量。每次⼀个线程开始运⾏前，需要先报告它需要的资源的总量，然后在运⾏过程中不断请求资源。当系统收到⼀个资源请求时，它可以假设已经受理该请求，然后查看在这个情况下，尚未分配的资源能否满⾜任何线程运⾏完毕，⽽该线程释放所有资源后，是否能够满⾜下⼀个线程运⾏完毕，直⾄所有线程都能运⾏完毕。如果这⼀条件成⽴，则请求安全；否则请求不安全。延迟</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">⼀种最为直接的办法就是重启计算机。这种办法直接结束所有进程（包括实际没有参与到死锁⾥的进程），代价很⼤，但它实际是很多操作系统对于死锁的解决⽅法。第⼆种⽅法是结束与死锁有关的进程，但这⼏个进程的进度也会全部消失，因此这也不是⼀个好的解决⽅案。第三种⽅法是剥夺产⽣死锁的线程的资源⽽不结束这个线程，直⾄死锁已经解除。如果系统有对于进程进度的记录，那么系统就可以把进程的进度倒退，直⾄回到死锁可以被解除的状态，再重新开始运⾏。</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p><img alt="img" src="/assets/images/d967dd92bd9058f7c7404b6c9f91064940127309-b90ecdf1269375614ebb57905c1ceea5.png"></p><p>死锁：从进程到资源的有向边叫请求边，表示该进程申请一个单位的该类资源；从资源到进程的边叫分配边，表示该类资源已经有一个资源被分配给了该进程。</p><h1><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="调度算法"></a>调度算法<a class="hash-link" href="#调度算法" title="Direct link to heading">#</a></h1><p>在抢占式多任务系统中，每个任务会被给 予⼀段时间，我们将这段时间称为 时间⽚ （time slice）。时间⽚耗尽后，系统会引 发 计时器中断（timer interrupt），使得 现在正在运⾏的任务被切换⾄内核态，在 系统空间中还⾏计时器中断的处理函数， 我们所关⼼的任务调度算法就发⽣在计时 器中断的处理函数中。在这个处理函数 中，系统会根据任务调度算法、从就绪队 列⾥选择下⼀个运⾏的任务（有可能仍然 是现在的这个任务），然后在处理上载⼊ 这个任务的处理器状态、在存储管理部件</p><p>，这就是 响应时间（response time） 和 周转时间（turnaround time）带权周转时间:周转时间与实际运⾏时间的⽐值。⼀个系统中所 有任务的平均带权周转时间越接近 ，这个系统的效率就越⾼。</p><p>多级反馈队列调度算法</p><p>在 MFLQ 算法中，我们有 个队列，这 个队列的优先级递减，其中前 个队列实⾏ RR 算法、时间⽚⻓度递增，最后⼀个队列使⽤ FIFO 算法。在多个 队列中都含有等待的任务时，这个算法会选择优先级最⾼的队列优先运⾏。 在⼀个新任务进⼊系统时，它会进⼊优先级最⾼的队列。当⼀个任务在运⾏时耗 尽了它的时间⽚时，它就会被移到优先级低⼀级的队列的末尾；反之，如果它因 为等待 I/O ⽽主动放弃处理器使⽤权，那么它就会保持在原来的位置，或向上移 动⼀个等级。如果它不断地耗尽它的时间⽚，那么它就会被移到最后⼀个先进先 出的队列中 n </p><p>许多操作系统都使⽤了⼀种机制叫做 优先 级捐赠（priority donation）。优先级捐赠 会在⼀个优先级⾼的线程需要获得⼀个优 先级低的线程持有的锁时发⽣，这时优先 级⾼的线程会将优先级低的线程的优先级 暂时提⾼到和⾃⼰⼀样，使得这个优先级 低的线程在没有新的优先级更⾼的线程进 ⼊系统时可以⽴即开始运⾏。当线程释放 锁时，线程的优先级会重新回到原来的低 优先级，这时处理器就会被抢占，等待锁 的线程会获得锁并继续运⾏。</p><p> Linux 的 算法就是⼀种特殊的 MFLQ 算 法，但与 MFLQ 算法不同的是 算法下、越优先的任务获得的时间⽚也越 ⻓，⽽且它的运⾏时间是 ，也就是说⽆论系统中有多少个任务，它所需要 的时间都是恒定的。 Linux 算法中，每个任务有⼀个静态的优先级，被称为 nice，nice 值越⾼、这个任务的优先级就越低。 你可以这样理解这种机制⼀个⽆私的任务就不想要抢占系统资源，也 就不需要很⾼的优先级了。在计算系统调度所使⽤的实际优先级时，我们根据⼀ 个任务的互动性来计算⼀个 bonus 值（范围为 到 ），加到 nice 值上。 Linux 主要根据⼀个任务睡眠或阻塞的时间减去它运⾏时间所得的值的⼤⼩来检 验它的互动性 ⾼低；这个值越⾼说明任务因 I/O 睡眠的时间⽐例越⾼，因此它应 当被给予更多处理器时间、避免 I/O 的响应被延迟。</p><p>虽然这个算法在运⾏时间⽅⾯的优势明显，但它的缺点也很明显：正如⼀般的 MLFQ 算法⼀般，它会导致计算密集型任务的饥饿。⽽且， 算法在分配运⾏ 时间时给每个优先级的任务规定了⼀个绝对的运⾏时间⻓度，⽽这个⻓度是很难 被决定的；适⽤于⼀个任务的运⾏时间⻓度不⼀定适⽤于另⼀个任务。⽽且我们 希望当两个任务 nice 值的差相同时，它们的运⾏时间相差也是相同的，然⽽这 样如果 nice 值为 的任务运⾏时间⽚⻓度为 ，nice 值为 的任务运⾏时间 ⽚⻓度为 ，那 nice 值为 的任务运⾏时间⽚⻓度就是 ，nice 值为 的任 务运⾏时间⽚⻓度是 。这种差异明显是不合理的</p><p>完全公平算法（Completely Fair Scheduler，CFS） 所使⽤的标准。</p><p><img alt="image-20210327170506640" src="/assets/images/image-20210327170506640-edeb2b4fd9546a43b35b2797af308b28.png"></p><p>⼀种是硬链接（hard link），⼀种是软连接（soft link, or symbolic link），这 两种链接的不同之处是硬连接中每个链接都指向⽂件在存储设备中的实际位置， ⽽软连接指向的是另⼀个路径名称。</p><p>主机（host） 是计算机⽹络的两个终端，它既包含了提供数据的 服务器 （server）、⼜包含了从服务器获得数据的 ⽤⼾（client）。</p><p>所有将主机连接 在⼀起的物理连接都能够构成 ⽹络（network），它包括了光缆等多种类的物 理连接以及作为“链接中转站”的 路由器（router） 和 交换机（switch）。</p><p>⽹络可以被分为 局域⽹（Local Area Network，LAN） 和 ⼴域⽹（Wide Area Network，WAN） 两种。</p><p>⼴域⽹实际上就是将多个局域⽹连接在⼀起的⽹络， 互联⽹就是⼀个巨⼤的⼴域⽹。</p><p>在计算机⽹络中，数据被拆分成 数据包 （packet），每个数据包都包含了不同的协议为数据包提供的 标头 （header），其中包含了数据包的来源、⽬的地等，可以被⽤于传送数据包和 将数据包恢复为完整的数据。⼀</p><p>个数据包在⽹络中被由⼀个主机传送⾄另⼀个主 机的过程被称为 路由（routing），路由的过程包含了从⼀个路由器传送⾄另⼀ 个路由器或由⼀个交换机传送⾄另⼀个交换机的中间过程，这种中间过程被称 为 转发（forwarding）。</p><p><img alt="image-20210327191543837" src="/assets/images/image-20210327191543837-fb474c43e17120b6f991ad6b2f676aff.png"></p><p>⽤于通过主机名称获得 IP 地址的 DNS 和⽤于在加⼊⽹络时获得地址的 DHCP 使⽤的也都是 UDP</p><p><img alt="image-20210327191908403" src="/assets/images/image-20210327191908403-b5ee9297d8d2ce15e97086c717535377.png"></p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly c"><div tabindex="0" class="prism-code language-c codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token number" style="color:rgb(247, 140, 108)">1.</span><span class="token plain"> 在⻚⾯中输⼊ URL2</span><span class="token punctuation" style="color:rgb(199, 146, 234)">.</span><span class="token plain"> 浏览器查找域名对应的 IP 地址</span><span class="token number" style="color:rgb(247, 140, 108)">3.</span><span class="token plain"> 浏览器向 Web 服务器发送 HTTP 请求</span><span class="token number" style="color:rgb(247, 140, 108)">4.</span><span class="token plain"> 服务器处理请求，返回⼀个 HTTP 响应</span><span class="token number" style="color:rgb(247, 140, 108)">5.</span><span class="token plain"> 浏览器获取 HTML 数据并显⽰</span><span class="token number" style="color:rgb(247, 140, 108)">6.</span><span class="token plain"> 浏览器向服务器发送请求，获取嵌⼊ HTML 中的资源（JavaScript 脚本、CSS、图⽚、视频等）</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/worst0/wiki_note/edit/main/docs/5.Operating_system/A2.操作系统.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col text--right"><em><small>Last updated on <time datetime="2021-06-21T01:57:04.000Z" class="lastUpdatedDate_1WI_">6/21/2021</time></small></em></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Operating_system/A1.os"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« OS</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Operating_system/C1.计算机原理"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">C1.计算机原理 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#研究对象" class="table-of-contents__link">研究对象</a></li><li><a href="#基本知识" class="table-of-contents__link">基本知识</a></li><li><a href="#分层" class="table-of-contents__link">分层</a></li><li><a href="#英文" class="table-of-contents__link">英文</a><ul><li><a href="#cpu" class="table-of-contents__link">CPU</a></li><li><a href="#运算" class="table-of-contents__link">运算</a></li><li><a href="#总线" class="table-of-contents__link">总线</a></li><li><a href="#io接口" class="table-of-contents__link">I/O接口</a></li><li><a href="#程序中断" class="table-of-contents__link">程序中断</a></li></ul></li><li><a href="#指令系统" class="table-of-contents__link">指令系统</a><ul><li><a href="#地址码" class="table-of-contents__link">地址码</a></li><li><a href="#操作码" class="table-of-contents__link">操作码</a></li><li><a href="#寻址技术" class="table-of-contents__link">寻址技术</a></li></ul></li><li><a href="#存储器" class="table-of-contents__link">存储器</a><ul><li><a href="#cache" class="table-of-contents__link">cache</a></li></ul></li><li><a href="#虚拟存储器" class="table-of-contents__link">虚拟存储器</a></li><li><a href="#输入输出系统" class="table-of-contents__link">输入输出系统</a><ul><li><a href="#程序中断-1" class="table-of-contents__link">程序中断</a></li><li><a href="#dma" class="table-of-contents__link">DMA</a></li><li><a href="#dma与程序中断方式区别" class="table-of-contents__link">DMA与程序中断方式区别</a></li></ul></li><li><a href="#概论" class="table-of-contents__link">概论</a><ul><li><a href="#三个关键问题" class="table-of-contents__link">三个关键问题</a></li><li><a href="#虚拟化cpu" class="table-of-contents__link">虚拟化CPU</a></li><li><a href="#虚拟化内存" class="table-of-contents__link">虚拟化内存</a></li><li><a href="#并发concurrency" class="table-of-contents__link">并发(concurrency)</a></li><li><a href="#持久性persistence" class="table-of-contents__link">持久性(persistence)</a></li><li><a href="#设计目标" class="table-of-contents__link">设计目标</a></li><li><a href="#历史" class="table-of-contents__link">历史</a></li></ul></li><li><a href="#抽象进程" class="table-of-contents__link">抽象:进程</a></li><li><a href="#图片" class="table-of-contents__link">图片</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.27f44f86.js"></script>
<script src="/assets/js/main.43fd085d.js"></script>
</body>
</html>