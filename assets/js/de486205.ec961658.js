(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[3436],{3905:function(n,e,t){"use strict";t.d(e,{Zo:function(){return c},kt:function(){return N}});var i=t(67294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,i,r=function(n,e){if(null==n)return{};var t,i,r={},a=Object.keys(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var d=i.createContext({}),l=function(n){var e=i.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},c=function(n){var e=l(n.components);return i.createElement(d.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},u=i.forwardRef((function(n,e){var t=n.components,r=n.mdxType,a=n.originalType,d=n.parentName,c=s(n,["components","mdxType","originalType","parentName"]),u=l(t),N=r,f=u["".concat(d,".").concat(N)]||u[N]||p[N]||a;return t?i.createElement(f,o(o({ref:e},c),{},{components:t})):i.createElement(f,o({ref:e},c))}));function N(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var a=t.length,o=new Array(a);o[0]=u;var s={};for(var d in e)hasOwnProperty.call(e,d)&&(s[d]=e[d]);s.originalType=n,s.mdxType="string"==typeof n?n:r,o[1]=s;for(var l=2;l<a;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},74970:function(n,e,t){"use strict";t.r(e),t.d(e,{frontMatter:function(){return s},metadata:function(){return d},toc:function(){return l},default:function(){return p}});var i=t(22122),r=t(19756),a=(t(67294),t(3905)),o=["components"],s={id:"A10.\u5b57\u5178\u6811",title:"A10.\u5b57\u5178\u6811","typora-root-url":"../"},d={unversionedId:"Algorithm/A10.\u5b57\u5178\u6811",id:"Algorithm/A10.\u5b57\u5178\u6811",isDocsHomePage:!1,title:"==\u5b57\u5178\u6811==",description:"\u540d\u79f0\uff1atrie\uff0c \u5b57\u5178\u6811\uff0c\u5355\u8bcd\u67e5\u627e\u6811\uff0c\u524d\u7f00\u6811",source:"@site/docs/2.Algorithm/A10.\u5b57\u5178\u6811.md",sourceDirName:"2.Algorithm",slug:"/Algorithm/A10.\u5b57\u5178\u6811",permalink:"/Algorithm/A10.\u5b57\u5178\u6811",editUrl:"https://github.com/worst0/wiki_note/edit/main/docs/2.Algorithm/A10.\u5b57\u5178\u6811.md",version:"current",frontMatter:{id:"A10.\u5b57\u5178\u6811",title:"A10.\u5b57\u5178\u6811","typora-root-url":"../"},sidebar:"Document\ud83d\udcbb",previous:{title:"==\u5b57\u7b26\u4e32\u5339\u914d\u7b97\u6cd5==",permalink:"/Algorithm/A8.\u5b57\u7b26\u4e32\u5339\u914d"},next:{title:"A10.\u6811\u72b6\u6570\u7ec4\u548c\u7ebf\u6bb5\u6811",permalink:"/Algorithm/A10.\u6811\u72b6\u6570\u7ec4\u548c\u7ebf\u6bb5\u6811"}},l=[{value:"\u4f20\u7edf\u5b57\u5178\u6811\u7684\u7f3a\u70b9",id:"\u4f20\u7edf\u5b57\u5178\u6811\u7684\u7f3a\u70b9",children:[]},{value:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811",id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-1",children:[]},{value:"\u4e8c\u53c9\u5b57\u5178\u6811",id:"\u4e8c\u53c9\u5b57\u5178\u6811",children:[{value:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811",id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-2",children:[]},{value:"\u4e8c\u53c9\u5b57\u5178\u6811+\u54c8\u592b\u66fc\u7f16\u7801",id:"\u4e8c\u53c9\u5b57\u5178\u6811\u54c8\u592b\u66fc\u7f16\u7801",children:[]},{value:"\u57fa\u4e8e\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a",id:"\u57fa\u4e8e\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a",children:[]},{value:"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a",id:"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a",children:[]},{value:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-kai",id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-kai",children:[]},{value:"AC \u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb",id:"ac-\u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb",children:[]},{value:"AC \u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316",id:"ac-\u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316",children:[]}]},{value:"\u6700\u5927\u5f02\u6216\u548c\u5b50\u6570\u7ec4",id:"\u6700\u5927\u5f02\u6216\u548c\u5b50\u6570\u7ec4",children:[{value:"\u5e38\u89c4\u89e3\u6cd5",id:"\u5e38\u89c4\u89e3\u6cd5",children:[]},{value:"\u524d\u7f00\u6811",id:"\u524d\u7f00\u6811",children:[]}]},{value:"AC \u81ea\u52a8\u673a\u7684\u601d\u60f3",id:"ac-\u81ea\u52a8\u673a\u7684\u601d\u60f3",children:[]},{value:"\u9884\u4e60\u8d44\u6599\uff1a\u3010\u6570\u636e\u7ed3\u6784\u3011&gt; \u5b57\u7b26\u4e32\u7edf\u8ba1",id:"\u9884\u4e60\u8d44\u6599\uff1a\u3010\u6570\u636e\u7ed3\u6784\u3011-\u5b57\u7b26\u4e32\u7edf\u8ba1",children:[{value:"\u5b58\u50a8\u4efb\u610f\u7c7b\u578b\u7684\u6808",id:"\u5b58\u50a8\u4efb\u610f\u7c7b\u578b\u7684\u6808",children:[]},{value:"\u4e8c\u53c9\u6811\u524d\u5e8f\u904d\u5386\uff08\u975e\u9012\u5f52\uff09",id:"\u4e8c\u53c9\u6811\u524d\u5e8f\u904d\u5386\uff08\u975e\u9012\u5f52\uff09",children:[]}]},{value:"\u57fa\u4e8e\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a",id:"\u57fa\u4e8e\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a-1",children:[]},{value:"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a",id:"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a-1",children:[]},{value:"AC \u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb",id:"ac-\u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb-1",children:[]},{value:"AC \u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316",id:"ac-\u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316-1",children:[]},{value:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811",id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-3",children:[]},{value:"\u5b57\u5178\u6811",id:"\u5b57\u5178\u6811",children:[]}],c={toc:l};function p(n){var e=n.components,s=(0,r.Z)(n,o);return(0,a.kt)("wrapper",(0,i.Z)({},c,s,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"\u540d\u79f0\uff1atrie\uff0c \u5b57\u5178\u6811\uff0c\u5355\u8bcd\u67e5\u627e\u6811\uff0c\u524d\u7f00\u6811"),(0,a.kt)("p",null,"\u4f5c\u7528\uff1a\u5355\u8bcd\u67e5\u627e\uff0c\u5b57\u7b26\u4e32\u6392\u5e8f"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\u4e5f\u53eb\u505a\uff1a\u524d\u7f00\u7d22\u5f15\u6811"),(0,a.kt)("li",{parentName:"ol"},"\u628a\u6bcf\u4e2a\u5b57\u7b26\u4e32\u6309\u7167\u524d\u7f00\u7684\u987a\u5e8f\u63d2\u5165\u5230\u6811\u5f62\u7ed3\u6784\u4e2d"),(0,a.kt)("li",{parentName:"ol"},"\u5b57\u5178\u6811\u53ef\u4ee5\u7528\u4e8e\u5b57\u7b26\u4e32\u7684\u6392\u5e8f\uff0c\u65f6\u95f4\u590d\u6742\u5ea6 ",(0,a.kt)("span",{parentName:"li",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mi",{parentName:"mrow"},"O"),(0,a.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,a.kt)("mi",{parentName:"mrow"},"n"),(0,a.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(n)")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,a.kt)("span",{parentName:"span",className:"mopen"},"("),(0,a.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,a.kt)("span",{parentName:"span",className:"mclose"},")"))))))),(0,a.kt)("p",null,"\u5b57\u5178\u6811\u7b49\u4ef7\u4e8e\u5355\u8bcd\u8868"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image-20210126235307421",src:t(20383).Z})),(0,a.kt)("p",null,"9 < 11 \u5b57\u5178\u5e8f:09 < 11 ->\u6587\u4ef6\u5939\u547d\u540d\u6392\u5e8f"),(0,a.kt)("p",null,"\u7ea2\u8272\u8282\u70b9\u53ef\u505a\u7ed3\u5c3e\uff0c\u72ec\u7acb\u6210\u8bcd\uff0c\u8fb9\u4ee3\u8868\u5b57\u6bcd"),(0,a.kt)("p",null,"\u6bd4\u8f83\u64cd\u4f5c\u7684\u65f6\u95f4\u4e0b\u9650\u4e3aO(nlogn);"),(0,a.kt)("p",null,"\u5b57\u5178\u5e8f\u6392\u5e8f\u5355\u8bcd\uff1a\u4e3aO(n); "),(0,a.kt)("p",null,"\u5c0f\u70b9\uff1a\u7cfb\u7edf\u547d\u540d\u662f1,2,3\uff0c...10\u76f4\u63a5\u6392\u524d\uff0c\u5b57\u5178\u5e8f"),(0,a.kt)("p",null,"\u8ba1\u7b97\u673a\uff1a\u5b66\u4e60\u4fe1\u606f\u7684\u8868\u793a"),(0,a.kt)("p",null,"\u64cd\u4f5c\u7cfb\u7edf\uff1a\u5982\u4f55\u8868\u793a\u6587\u4ef6\uff0c\u914d\u7f6e\u6587\u4ef6\uff0c"),(0,a.kt)("p",null,"\u8ba1\u7b97\u673a\u7f51\u7edc\uff1a\u5982\u4f55\u5408\u7406\u5c01\u88c5\u4fe1\u606f\uff0c\u5982\u4f55\u4fdd\u8bc1\uff0c\u534f\u8bae"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"\u627e\u5230\u5177\u6709\u540c\u4e00\u524d\u7f00\u7684\u5168\u90e8\u952e\u503c\u3002"),(0,a.kt)("li",{parentName:"ul"},"\u6309\u8bcd\u5178\u5e8f\u679a\u4e3e\u5b57\u7b26\u4e32\u7684\u6570\u636e\u96c6")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#define BASE 26\n#define BASE_LETTER \'a\'\n\ntypedef struct Node {\n    int flag;\n    struct Node *next[BASE];\n} Node;\n\nNode *getNewNode() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    return p;\n}\n\ninline int code(char ch) {\n    return ch - BASE_LETTER;\n}\n\nvoid insert(Node *root, char *str) {\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        if (p->next[code(str[i])] == NULL) p->next[code(str[i])] = getNewNode();\n        p = p->next[code(str[i])];\n    }\n    p->flag = 1;\n    return ;\n}\n\nint query(Node *root, char *str) {\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        p = p->next[code(str[i])];\n        if (p == NULL) return 0;\n    }\n    return p->flag;\n}\n\nvoid output(Node *root, int k, char *buff) {\n    if (root == NULL) return ;\n    if (root->flag) printf("%s\\n", buff);\n    for (int i = 0; i < BASE; i++) {\n        buff[k] = BASE_LETTER + i;\n        buff[k + 1] = \'\\0\';\n        output(root->next[i], k + 1, buff);\n    }\n    return ;\n}\n\nvoid clear(Node *root) {\n    if (root == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(root->next[i]);\n    }\n    free(root);\n    return ;\n}\n\nint main() {\n    char str[1000];\n    int n;\n    Node *root = getNewNode();\n    scanf("%d", &n);\n    for (int i = 0; i < n; i++) {\n        scanf("%s", str);\n        insert(root, str);\n    }\n    output(root, 0, str);\n    while (~scanf("%s", str)) {\n        printf("query %s, result = %s\\n", str, query(root, str) ? "Yes" : "No");\n    }\n    return 0;\n}\n')),(0,a.kt)("p",null,"\u6307\u9488\u53d8\u91cf-8\u5b57\u8282(sizeof(int *))"),(0,a.kt)("h1",{id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811"},"==\u53cc\u6570\u7ec4\u5b57\u5178\u6811=="),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://raw.githubusercontent.com/worst0/picture/master/img/image-20201017104134948.png",alt:"image-20201017104134948"})),(0,a.kt)("h2",{id:"\u4f20\u7edf\u5b57\u5178\u6811\u7684\u7f3a\u70b9"},"\u4f20\u7edf\u5b57\u5178\u6811\u7684\u7f3a\u70b9"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u5b9e\u9645\u5b58\u50a8\u7ed3\u6784\u662f\u8fde\u7eed\u6570\u7ec4\u7a7a\u95f4\uff0c\u601d\u7ef4\u903b\u8f91\u7ed3\u6784\u662f\u6811\u578b\u7684"),(0,a.kt)("li",{parentName:"ol"},"\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u8282\u7701\u4e86\u5927\u91cf\u7684\u5b58\u50a8\u8fb9\u7684\u7a7a\u95f4"),(0,a.kt)("li",{parentName:"ol"},"\u4f18\u5316\u601d\u60f3\uff1a\u8bb0\u5f55\u5f0f \u6539 \u8ba1\u7b97\u5f0f"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("span",{parentName:"li",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mi",{parentName:"mrow"},"n")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.43056em",verticalAlign:"0em"}}),(0,a.kt)("span",{parentName:"span",className:"mord mathnormal"},"n")))))," \u4e2a\u8282\u70b9\u7684\u5b57\u5178\u6811\uff0c\u6709\u6548\u4f7f\u7528 ",(0,a.kt)("span",{parentName:"li",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mi",{parentName:"mrow"},"n"),(0,a.kt)("mo",{parentName:"mrow"},"\u2212"),(0,a.kt)("mn",{parentName:"mrow"},"1")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"n-1")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}}),(0,a.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,a.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"1")))))," \u6761\u8fb9\uff0c\u6d6a\u8d39\u4e86 ",(0,a.kt)("span",{parentName:"li",className:"math math-inline"},(0,a.kt)("span",{parentName:"span",className:"katex"},(0,a.kt)("span",{parentName:"span",className:"katex-mathml"},(0,a.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,a.kt)("semantics",{parentName:"math"},(0,a.kt)("mrow",{parentName:"semantics"},(0,a.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,a.kt)("mi",{parentName:"mrow"},"k"),(0,a.kt)("mo",{parentName:"mrow"},"\u2212"),(0,a.kt)("mn",{parentName:"mrow"},"1"),(0,a.kt)("mo",{parentName:"mrow",stretchy:"false"},")"),(0,a.kt)("mo",{parentName:"mrow"},"\u2217"),(0,a.kt)("mi",{parentName:"mrow"},"n"),(0,a.kt)("mo",{parentName:"mrow"},"+"),(0,a.kt)("mn",{parentName:"mrow"},"1")),(0,a.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"(k-1)*n+1")))),(0,a.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.kt)("span",{parentName:"span",className:"mopen"},"("),(0,a.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03148em"}},"k"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,a.kt)("span",{parentName:"span",className:"mbin"},"\u2212"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"1"),(0,a.kt)("span",{parentName:"span",className:"mclose"},")"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,a.kt)("span",{parentName:"span",className:"mbin"},"\u2217"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.66666em",verticalAlign:"-0.08333em"}}),(0,a.kt)("span",{parentName:"span",className:"mord mathnormal"},"n"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,a.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,a.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,a.kt)("span",{parentName:"span",className:"base"},(0,a.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,a.kt)("span",{parentName:"span",className:"mord"},"1")))))," \u6761\u8fb9\u7684\u5b58\u50a8\u7a7a\u95f4"),(0,a.kt)("li",{parentName:"ol"},"\u53c2\u8003\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u4f18\u70b9\uff0c\u63d0\u51fa\u4e86\u53cc\u6570\u7ec4\u5b57\u5178\u6811")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"==\u4fe1\u606f\u7684\u7b49\u4ef7==")," \u53ea\u662f\u4fee\u6539\u4e86\u5b57\u5178\u6811\u7684\u8868\u793a\u65b9\u5f0f---\u8ba1\u7b97\u673a\u672c\u8d28\u5c31\u662f\u4fe1\u606f\u7684\u8868\u793a"),(0,a.kt)("p",null,"\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u662f\u79bb\u6563\u6784\u5efa\u7684\uff0c\u4e0d\u592a\u652f\u6301\u52a8\u6001\u63d2\u5165\uff0c\u5176\u5b9e\u5b83\u662f\u5b57\u5178\u6587\u4ef6->\u5efa\u7acb\u5bf9\u5e94\u5b57\u5178\u6811->\u8f6c\u4e3a\u76f8\u5e94\u53cc\u6570\u7ec4\u5b57\u5178\u6811"),(0,a.kt)("h2",{id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-1"},"\u53cc\u6570\u7ec4\u5b57\u5178\u6811"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\u987e\u540d\u601d\u4e49\uff0c\u4e24\u4e2a\u6570\u7ec4\u4ee3\u8868\u4e00\u68f5\u5b57\u5178\u6811\u7ed3\u6784"),(0,a.kt)("li",{parentName:"ol"},"base \u6570\u7ec4\u4fe1\u606f\u4e0e\u5b50\u8282\u70b9\u7f16\u53f7\u76f8\u5173\uff0cbase + i \u5c31\u662f\u7b2c i \u4e2a\u5b50\u8282\u70b9\u7f16\u53f7"),(0,a.kt)("li",{parentName:"ol"},"check \u6570\u7ec4\u4fe1\u606f\u8d1f\u8d23\u505a\u3010\u4eb2\u5b50\u9274\u5b9a\u3011\uff0ccheck \u6570\u7ec4\u4e2d\u7528\u6b63\u8d1f\u8868\u793a\u662f\u5426\u72ec\u7acb\u6210\u8bcd"),(0,a.kt)("li",{parentName:"ol"},"\u4e0d\u64c5\u957f\u8fdb\u884c\u52a8\u6001\u63d2\u5165\u64cd\u4f5c"),(0,a.kt)("li",{parentName:"ol"},"\u4e00\u6b21\u5efa\u7acb\uff0c\u7ec8\u8eab\u4f7f\u7528"),(0,a.kt)("li",{parentName:"ol"},"\u4e3a\u4e86\u65b9\u4fbf\uff0c\u57fa\u4e8e\u666e\u901a\u5b57\u5178\u6811\u5b9e\u73b0\u7684\u53cc\u6570\u7ec4\u5b57\u5178\u6811"),(0,a.kt)("li",{parentName:"ol"},"\u589e\u52a0\u4e86 fail \u6570\u7ec4\uff0c\u53ef\u4ee5\u5b8c\u6210\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a"),(0,a.kt)("li",{parentName:"ol"},"\u8d85\u5c0f\u89c4\u6a21\u5b9e\u9a8c\u7ed3\u679c\uff1a\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u538b\u7f29\u6548\u7387\u662f 25 \u500d"),(0,a.kt)("li",{parentName:"ol"},"\u975e\u5e38\u65b9\u4fbf\u7684\u8f93\u51fa\u5230\u6587\u4ef6\u4e2d\uff0c\u8fdb\u884c\u673a\u5668\u4e4b\u95f4\u7684\u5171\u4eab"),(0,a.kt)("li",{parentName:"ol"},"\u8bfe\u540e\u4f5c\u4e1a\uff1a\u5229\u7528\u771f\u5b9e\u6570\u636e\u96c6\uff0c\u6d4b\u8bd5\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684\u538b\u7f29\u6548\u7387"),(0,a.kt)("li",{parentName:"ol"},"base\u503c\u53ef\u4ee5\u76f8\u540c,base\u7684\u5b50\u8282\u70b9\u7684\u503c\u624d\u91cd\u8981,\u4e0d\u53ef\u4ee5\u51b2\u7a81")),(0,a.kt)("h2",{id:"\u4e8c\u53c9\u5b57\u5178\u6811"},"\u4e8c\u53c9\u5b57\u5178\u6811"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\u8ba1\u7b97\u673a\u4e2d\u6240\u6709\u4fe1\u606f\u90fd\u662f\u4e8c\u8fdb\u5236\u5b58\u50a8\u7684"),(0,a.kt)("li",{parentName:"ol"},"\u4efb\u4f55\u4fe1\u606f\u90fd\u53ef\u4ee5\u770b\u6210\u4e00\u4e2a\u4e8c\u8fdb\u5236\u4e32"),(0,a.kt)("li",{parentName:"ol"},"\u63d2\u5165\u4e8c\u8fdb\u5236\u4e32\u7684\u5b57\u5178\u6811\uff0c\u5c31\u662f\u4e8c\u53c9\u5b57\u5178\u6811"),(0,a.kt)("li",{parentName:"ol"},"\u4e8c\u53c9\u5b57\u5178\u6811\u53ef\u4ee5\u5b58\u50a8\u4efb\u610f\u4fe1\u606f"),(0,a.kt)("li",{parentName:"ol"},"\u8282\u7701\u7a7a\u95f4\uff0c\u6d6a\u8d39\u65f6\u95f4\uff0c\u672c\u8d28\uff1a\u65f6\u95f4\u6362\u7a7a\u95f4\u7684\u7b97\u6cd5\u601d\u7ef4"),(0,a.kt)("li",{parentName:"ol"},"\u54c8\u5f17\u66fc\u7f16\u7801 + \u4e8c\u53c9\u5b57\u5178\u6811 \u53ef\u80fd\u66f4\u914d\u54e6\uff0c\u65e2\u8282\u7701\u4e86\u7a7a\u95f4\uff0c\u53c8\u5728\u6700\u5927\u9650\u5ea6\u4e0a\u8282\u7701\u4e86\u67e5\u627e\u65f6\u95f4")),(0,a.kt)("p",null,"\u4e0d\u79ef\u8dec\u6b65\uff0c\u65e0\u4ee5\u81f3\u5343\u91cc\u3002\u4e0d\u79ef\u5c0f\u6d41\uff0c\u65e0\u4ee5\u6210\u6c5f\u6d77\u3002"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"\u5efa\u8bae\uff1a"),"\u591a\u770b\u51e0\u672c\u57fa\u672c\u7684\u7b97\u6cd5\u4e66\u3001\u3010\u6570\u8bba\u57fa\u7840\u3011\u3001\u591a\u63a5\u89e6\u79bb\u6563\u578b\u6570\u5b66\u601d\u7ef4"),(0,a.kt)("p",null,"\u5b57\u5178\u6811\u53f6\u5b50\u8282\u70b9\u6d6a\u8d39\u7a7a\u95f4\u8fc7\u5927"),(0,a.kt)("p",null,"\u8bb0\u5f55\u5f0f\u8f6c\u8ba1\u7b97\u5f0f"),(0,a.kt)("h3",{id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-2"},"\u53cc\u6570\u7ec4\u5b57\u5178\u6811"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image-20201017104134948",src:t(9168).Z})),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"==\u4fe1\u606f\u7684\u7b49\u4ef7==")),(0,a.kt)("p",null,"\u53ea\u662f\u4fee\u6539\u4e86\u5b57\u5178\u6811\u7684\u8868\u793a\u65b9\u5f0f---\u8ba1\u7b97\u673a\u672c\u8d28\u5c31\u662f\u4fe1\u606f\u7684\u8868\u793a"),(0,a.kt)("p",null,"\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u662f\u79bb\u6563\u6784\u5efa\u7684\uff0c\u4e0d\u592a\u652f\u6301\u52a8\u6001\u63d2\u5165\uff0c\u5176\u5b9e\u5b83\u662f\u5b57\u5178\u6587\u4ef6->\u5efa\u7acb\u5bf9\u5e94\u5b57\u5178\u6811->\u8f6c\u4e3a\u76f8\u5e94\u53cc\u6570\u7ec4\u5b57\u5178\u6811"),(0,a.kt)("p",null,"\u7236\u8282\u70b9\u4e0e\u5b50\u8282\u70b9\u7684\u5173\u7cfb\u7684\u8ba1\u7b97\u5f0f\u8868\u793a\uff1a"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"base[]\uff1a\u8ba1\u7b97\u7236\u5b50\u8282\u70b9\u7684\u8fb9\u7684\u4e2d\u95f4\u91cf"),(0,a.kt)("p",{parentName:"li"},"\u200b\tfather\u7684\u7b2ci\u4e2a\u5b69\u5b50(i\u662f\u5b57\u7b26\u7f16\u7801) \uff1a child_i = base","[father]"," + i;")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"check[]\uff1a\u8bb0\u5f55\u6bcf\u4e2a\u5b50\u8282\u70b9\u7684\u771f\u6b63\u7236\u8282\u70b9, \u4ee5\u53ca\u662f\u5426\u72ec\u7acb\u6210\u8bcd(\u6b63\u8d1f)"),(0,a.kt)("p",{parentName:"li"},"\u200b\tcheck","[child_i]"," = father;"),(0,a.kt)("p",{parentName:"li"},"\u200b\tcheck","[child_i]"," = -father; \u8d1f\u6570\u989d\u5916\u4ee3\u8868\u72ec\u7acb\u6210\u8bcd"),(0,a.kt)("p",{parentName:"li"},"\u200b\t\u4e0d\u53ef\u8bb0\u5f550\u53f7\uff0c\u4ece1\u53f7\u5f00\u59cb\uff1b\u76f8\u5e94\u8282\u70b9\u7684\u7236\u8282\u70b9\u4e0d\u53ef\u4e3a0\u53f7"),(0,a.kt)("p",{parentName:"li"},"\u200b\t\u521d\u59cbcheck[]\u4e3a0\uff0c\u4ee3\u8868\u672a\u5360\u7528\uff0c\u4e00\u65e6\u8bb0\u5f55\u4e00\u5b9a\u975e0\uff1b")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"base","[child_i]"," = "))),(0,a.kt)("p",null,"\u8bb0\u5f55\u66f4\u591a\u7684\u4fe1\u606f\uff0c\u53ef\u901a\u8fc7\u5c01\u88c5\u7ed3\u6784\u4f53\uff0c\u591a\u4e2a\u6570\u7ec4"),(0,a.kt)("h3",{id:"\u4e8c\u53c9\u5b57\u5178\u6811\u54c8\u592b\u66fc\u7f16\u7801"},"\u4e8c\u53c9\u5b57\u5178\u6811+\u54c8\u592b\u66fc\u7f16\u7801"),(0,a.kt)("p",null,"\u7f16\u7801\uff1a\u6839\u636e\u95ee\u9898\u573a\u666f\u6765\u7b49\u4ef7\u4fe1\u606f\u8868\u793a\u3002"),(0,a.kt)("p",null,"\u54c8\u592b\u66fc\u7f16\u7801\uff1a\u5c06\u4fe1\u606f\u8868\u793a\u4e3a\u6700\u77ed"),(0,a.kt)("p",null,"\u56de\u7b54\uff1a"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u54c8\u592b\u66fc\u7f16\u7801\u7b97\u51fa\uff1a\u9700\u8981\u7684\u4fe1\u606f\uff0c\u7edf\u8ba1\u95ee\u9898\u573a\u666f\u4e0b\u7684\u6982\u7387\uff1b")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"\u5bf9\u4e2d\u6587\u5b57\u7b26\u96c6\u7f16\u7801\uff1a\u4e00\u4e2a\u4e2d\u6587\u5360\u82e5\u5e72\u7f16\u7801\uff0c\u5bf9\u6bcf\u4e2a\u5b57\u8282\u7f16\u7801"))),(0,a.kt)("h3",{id:"\u57fa\u4e8e\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a"},"\u57fa\u4e8e\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'/*************************************************************************\n   > File Name: 12.double_array_trie.cpp\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u4e09  8/21 14:14:38 2019\n ************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define BASE 26\n#define BEGIN_LETTER \'a\'\n\ntypedef struct Node {\n    int flag;\n    struct Node *next[BASE];\n} Node;\n\ntypedef struct DATrie {\n    int *base, *check;\n    int root, size;\n} DATrie;\n\nDATrie *getDATrie(int n) {\n    DATrie *tree = (DATrie *)calloc(sizeof(DATrie), 1);\n    tree->root = 1;\n    tree->size = n;\n    tree->base = (int *)calloc(sizeof(int), n);\n    tree->check = (int *)calloc(sizeof(int), n);\n    tree->check[tree->root] = 1;\n    return tree;\n}\n\nNode *getNewNode() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    return p;\n}\n\nint insert(Node *root, const char *str) {\n    int cnt = 0;\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), cnt += 1;\n        p = p->next[ind];\n    }\n    p->flag = 1;\n    return cnt;\n}\n\nvoid clear(Node *root) {\n    if (root == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(root->next[i]);\n    }\n    free(root);\n    return ;\n}\n\nint getBaseValue(Node *root, DATrie *tree) {\n    int base = 0, flag;\n    do {\n        flag = 1;\n        base += 1;\n        for (int i = 0; i < BASE; i++) {\n            if (root->next[i] == NULL) continue;\n            if (tree->check[base + i] == 0) continue;\n            flag = 0;\n            break;\n        }\n    } while (!flag);\n    return base;\n}\n\nint buildDATrie(int ind, Node *root, DATrie *tree) {\n    int base = tree->base[ind] = getBaseValue(root, tree);\n    int ans = ind;\n    for (int i = 0; i < BASE; i++) {\n        if (root->next[i] == NULL) continue;\n        tree->check[base + i] = ind;\n    }\n    for (int i = 0; i < BASE; i++) {\n        if (root->next[i] == NULL) continue;\n        int temp = buildDATrie(base + i, root->next[i], tree);\n        if (temp > ans) ans = temp;\n    }\n    if (root->flag) tree->check[ind] = -tree->check[ind];\n    return ans;\n}\n\nint query(DATrie *tree, const char *str) {\n    int p = tree->root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (abs(tree->check[tree->base[p] + ind]) != p) return 0;\n        p = tree->base[p] + ind;\n    }\n    return tree->check[p] < 0;\n}\n\nvoid clearDA(DATrie *tree) {\n    if (tree == NULL) return ;\n    free(tree->base);\n    free(tree->check);\n    free(tree);\n    return ;\n}\n\nint main() {\n    int n, cnt1 = 1, cnt2;\n    char str[100];\n    scanf("%d", &n);\n    Node *root = getNewNode();\n    while (n--) {\n        scanf("%s", str);\n        cnt1 += insert(root, str);\n    }\n    DATrie *tree = getDATrie(cnt1 * BASE + 5);\n    cnt2 = buildDATrie(tree->root, root, tree) + 1;\n    while (~scanf("%s", str)) {\n        printf("search %s, result = %s\\n", str, query(tree, str) ? "YES" : "NO");\n    }\n    int mem1 = cnt1 * sizeof(Node), mem2 = cnt2 * sizeof(int) * 2 + sizeof(int) * 2;\n    printf("Trie memory : %d Bytes\\n", mem1);\n    printf("Double Array Trie memory : %d Bytes\\n", mem2);\n    printf("memory rate : %.4lf%%\\n", 1.0 * mem2 / mem1 * 100);\n    clearDA(tree);\n    clear(root);\n    return 0;\n}\n')),(0,a.kt)("h3",{id:"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a"},"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define BASE 26\n#define BEGIN_LETTER \'a\'\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define has_child(data, ind, i) (abs(data[data[ind].base + i].check) == ind)\n\ntypedef struct DANode {\n    int base, check, fail;\n    char *str;\n} DANode;\n\ntypedef struct Node {\n    int flag;\n    char *str;\n    struct Node *next[BASE];\n} Node, *Trie;\n\nint node_cnt = 0;\n\nNode *get_new_node() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    node_cnt += 1;\n    return p;\n}\n\nvoid clear(Trie root) {\n    if (root == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(root->next[i]);\n    }\n    if (root->flag) free(root->str);\n    free(root);\n    return ;\n}\n\nNode *insert(Trie root, const char *str) {\n    if (root == NULL) root = get_new_node();\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (p->next[ind] == NULL) p->next[ind] = get_new_node();\n        p = p->next[ind];\n    }\n    p->flag = 1;\n    p->str = strdup(str);\n    return root;\n}\n\nint get_base(Node *node, DANode *data) {\n    int base = 2, flag = 0;\n    while (!flag) {\n        flag = 1;\n        for (int i = 0; i < BASE; i++) {\n            if (node->next[i] == NULL) continue;\n            if (data[base + i].check == 0) continue;\n            flag = 0;\n            break;\n        }\n        base += (!flag);\n    }\n    return base;\n}\n\nint build(Node *node, DANode *data, int ind) {\n    if (node == NULL) return 0;\n    if (node->flag) data[ind].check = -data[ind].check, data[ind].str = node->str;\n    int max_ind = ind;\n    data[ind].base = get_base(node, data);\n    for (int i = 0; i < BASE; i++) {\n        if (node->next[i] == NULL) continue;\n        data[data[ind].base + i].check = ind;\n    }\n    for (int i = 0; i < BASE; i++) {\n        if (node->next[i] == NULL) continue;\n        int temp = build(node->next[i], data, data[ind].base + i);\n        max_ind = max(max_ind, temp);\n    }\n    return max_ind;\n}\n\nvoid build_ac(DANode *data) {\n    #define MAX_N 100000\n    int *queue = (int *)malloc(sizeof(int) * MAX_N);\n    int head = 0, tail = 0;\n    data[1].fail = 0;\n    queue[tail++] = 1;\n    while (head < tail) {\n        int ind = queue[head++];\n        for (int i = 0; i < BASE; i++) {\n            if (!has_child(data, ind, i)) continue;\n            int p = data[ind].fail;\n            while (p && !has_child(data, p, i)) p = data[p].fail;\n            if (p == 0) p = 1;\n            else p = data[p].base + i;\n            data[data[ind].base + i].fail = p;\n            queue[tail++] = data[ind].base + i;\n        }\n    }\n    return ;\n    #undef MAX_N\n}\n\nvoid search_ac(DANode *data, const char *str) {\n    int p = 1;\n    for (int i = 0; str[i]; i++) {\n        while (p && !has_child(data, p, str[i] - BEGIN_LETTER)) p = data[p].fail;\n        if (p == 0) p = 1;\n        else p = data[p].base + str[i] - BEGIN_LETTER;\n        int q = p;\n        while (q) {\n            if (data[q].check < 0) printf("find string : %s\\n", data[q].str);\n            q = data[q].fail;\n        }\n    }\n    return ;  \n}\n\nvoid output_da(DANode *data, int n) {\n    for (int i = 1; i <= n; i++) {\n        if (i - 1 && i % 5 == 1) printf("\\n");\n        printf("(%2d %2d %3d)    ", i, data[i].base, data[i].check);\n    }\n    printf("\\n");\n    return ;\n}\n\nint main() {\n    Trie root = NULL;\n    #define INSERT_CNT 5\n    root = insert(root, "hai");\n    root = insert(root, "zei");\n    root = insert(root, "ha");\n    root = insert(root, "ab");\n    root = insert(root, "ehz");\n    DANode *data = (DANode *)calloc(sizeof(DANode), (INSERT_CNT * 100));\n    int da_cnt = build(root, data, 1);\n    build_ac(data);\n    output_da(data, da_cnt);\n    search_ac(data, "sasherhs");\n    #undef INSERT_CNT \n    return 0;\n}\n')),(0,a.kt)("h3",{id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-kai"},"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-kai"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'/*************************************************************************\n    > File Name: 1.double_array_trie.cpp\n    > Author: huguang\n    > Mail: hug@haizeix.com\n    > Created Time: \n ************************************************************************/\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <vector>\nusing namespace std;\n\n#define BASE 26\n#define MSG_LEVEL 2\n#define DEBUG_LEVEL 1\n#define INFO_LEVEL 2\n\n#define LOG(level, frm, args...) { \\\n    if (level >= MSG_LEVEL) { \\\n        printf(frm,##args); \\\n    } \\\n}\n\n#define LOG_DEBUG(args...) LOG(DEBUG_LEVEL, args)\n#define LOG_INFO(args...) LOG(INFO_LEVEL, args)\n\ntypedef struct Node {\n    int flag;\n    struct Node *next[BASE];\n} Node;\n\ntypedef struct DANode {\n    int base, check, fail;\n} DANode;\n\nNode *getNewNode() {\n    Node *p = (Node *)malloc(sizeof(Node));\n    p->flag = 0;\n    memset(p->next, 0, sizeof(p->next));\n    return p;\n}\n\ninline int code(char c) { return c - \'a\'; }\n\nint insert(Node *root, const char *str) {\n    int cnt = 0;\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = code(str[i]);\n        if (p->next[ind] == NULL) {\n            cnt += 1;\n            p->next[ind] = getNewNode();\n        }\n        p = p->next[ind];\n    }\n    p->flag = 1;\n    return cnt;\n}\n\nvoid clear_trie(Node *root) {\n    if (root == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear_trie(root->next[i]);\n    }\n    free(root);\n    return ;\n}\n\nint get_base_value(Node *root, DANode *tree, int ind) {\n    int base = 1, flag;\n    do {\n        base += 1;\n        flag = 1;\n        for (int i = 0; i < BASE && flag; i++) {\n            if (root->next[i] == NULL) continue;\n            if (tree[base + i].check) flag = 0;\n        }\n    } while (flag == 0);\n    return base;\n}\n\nint transform_double_array_trie(Node *root, DANode *tree, int ind) {\n    if (root == NULL) return 0;\n    if (root->flag) tree[ind].check = -tree[ind].check;\n    int base = get_base_value(root, tree, ind);\n    tree[ind].base = base;\n    for (int i = 0; i < BASE; i++) {\n        if (root->next[i] == NULL) continue;\n        tree[base + i].check = ind;\n    }\n    int max_ind = ind;\n    for (int i = 0; i < BASE; i++) {\n        int a = transform_double_array_trie(root->next[i], tree, base + i);\n        if (a > max_ind) max_ind = a;\n    }\n    return max_ind;\n}\n\nvoid dump_double_array_trie(DANode *tree, int n) {\n    LOG_INFO("%d\\n", n);\n    for (int i = 0; i <= n; i++) {\n        LOG_INFO("%d %d %d\\n", tree[i].base, tree[i].check, tree[i].fail);\n    }\n    return ;\n}\n\nvoid build_ac_base_double_array_trie(DANode *tree, int max_ind) {\n    int *que = (int *)malloc(sizeof(int) * (max_ind + 5));\n    int head, tail;\n    head = tail = 0;\n    tree[1].fail = 0;\n    for (int i = 0; i < BASE; i++) {\n        int child_ind = tree[1].base + i;\n        if (abs(tree[child_ind].check) != 1) continue;\n        tree[child_ind].fail = 1;\n        que[tail++] = child_ind;\n    }\n    while (head < tail) {\n        int p = que[head++];\n        for (int i = 0; i < BASE; i++) {\n            int c = tree[p].base + i, k = tree[p].fail;\n            if (abs(tree[c].check) != p) continue;\n            while (k && abs(tree[tree[k].base + i].check) != k) k = tree[k].fail;\n            if (k == 0) k = 1;\n            if (abs(tree[tree[k].base + i].check) == k) k = tree[k].base + i;\n            tree[c].fail = k;\n            que[tail++] = c;\n        }\n    }\n    free(que);\n    return ;\n}\n\nint main() {\n    int n, cnt = 1;\n    char str[1000];\n    scanf("%d", &n);\n    Node *root = getNewNode();\n    for (int i = 0; i < n; i++) {\n        scanf("%s", str);\n        cnt += insert(root, str);\n    }\n    size_t tree_size = sizeof(DANode) * (cnt * BASE);\n    DANode *tree = (DANode *)malloc(tree_size);\n    memset(tree, 0, tree_size);\n    int max_ind = transform_double_array_trie(root, tree, 1);\n    size_t s1 = cnt * sizeof(Node);\n    size_t s2 = max_ind * sizeof(DANode);\n    LOG_DEBUG("trie(%lu Byte), double array trie(%lu Byte)\\n", s1, s2);\n    LOG_DEBUG("rate : %.2lf\\n", 1.0 * s2 / s1);\n    for (int i = 0; i <= max_ind; i++) {\n        LOG_DEBUG("(%d | %d, %d)\\t", i, tree[i].base, tree[i].check);\n        if ((i + 1) % 5 == 0) LOG_DEBUG("\\n");\n    }\n    LOG_DEBUG("\\n");\n    build_ac_base_double_array_trie(tree, max_ind);\n    dump_double_array_trie(tree, max_ind);\n    free(tree);\n    clear_trie(root);\n    return 0;\n}\n')),(0,a.kt)("h3",{id:"ac-\u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb"},"AC \u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nconst int SIZE = 26;\nconst char BASE = \'a\';\nconst int MAX_SIZE = 200000;\nconst int MAX_LEN = 200000;\nchar str_buffer[200005];\n\ntypedef struct TrieNode {\n    int count;\n    struct TrieNode** childs;\n    struct TrieNode* fail, *father;\n} TrieNode, *Trie;\n\nTrieNode* new_node() {\n    TrieNode *p = (TrieNode *)malloc(sizeof(TrieNode));\n    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        p->childs[i] = NULL;\n    }\n    p->fail = NULL;\n    p->count = 0;\n    return p;\n}\n\nvoid clear(TrieNode *node) {\n    if (node == NULL) return ;\n    for (int i = 0; i < SIZE; i++) {\n        if (node->childs[i] == NULL) continue;\n        clear(node->childs[i]);\n    }\n    free(node->childs);\n    free(node);\n    return ;\n}\n\nvoid insert(TrieNode *trie, const char *buffer) {\n    TrieNode *p = trie;\n    for (int i = 0; i < strlen(buffer); i++) {\n        if (p->childs[buffer[i] - BASE] == NULL) {\n            p->childs[buffer[i] - BASE] = new_node();\n            p->childs[buffer[i] - BASE]->father = p;\n        }\n        p = p->childs[buffer[i] - BASE];\n    }\n    p->count++;\n    return ;\n}\n\nvoid build_automaton(TrieNode *node) {\n    #define next childs\n    #define Node TrieNode\n    if (node == NULL) return ;\n    if (node->fail == NULL) build_automaton(node->father);\n    for (int i = 0; i < SIZE; i++) {\n        if (node->next[i] == NULL) continue;\n        if (node->next[i]->fail) continue;\n        Node *p = node->fail, *pre_p = node;\n        while (p && p->next[i] == NULL) {\n            if (p->fail == NULL) build_automaton(p->father);\n            pre_p = p;\n            p = p->fail;\n        }\n        if (p == NULL) p = pre_p;\n        else p = p->next[i];\n        node->next[i]->fail = p;\n        build_automaton(node->next[i]);\n    }\n    return ;\n    #undef next\n    #undef Node\n}\n\nint match_count(TrieNode *ac_tree, const char *str) {\n    int ret = 0;\n    TrieNode *p = ac_tree, *q;\n    while (str[0]) {\n        while (p && p->childs[str[0] - \'a\'] == NULL) p = p->fail;\n        if (p == NULL) p = ac_tree;\n        else p = p->childs[str[0] - \'a\'];\n        q = p;\n        while (q) ret += q->count, q = q->fail;\n        str++;\n    }\n    return ret;\n}\n\nint main() {\n    Trie root = new_node();\n    int n;\n    scanf("%d", &n);\n    for (int i = 0; i < n; ++i) {\n        char pattern[MAX_LEN];\n        scanf("%s", pattern);\n        insert(root, pattern);\n    }\n    build_automaton(root);\n    scanf("%s", str_buffer);\n    printf("%d\\n", match_count(root, str_buffer));\n    //clear(root);\n    return 0;\n}\n')),(0,a.kt)("h3",{id:"ac-\u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316"},"AC \u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nconst int SIZE = 26;\nconst char BASE = \'a\';\nconst int MAX_SIZE = 200000;\nconst int MAX_LEN = 200000;\nchar str_buffer[200005];\n\ntypedef struct TrieNode {\n    int count;\n    struct TrieNode** childs;\n    struct TrieNode *fail;\n} TrieNode, *Trie;\n\nTrieNode* new_node() {\n    TrieNode *p = (TrieNode *)calloc(sizeof(TrieNode), 1);\n    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        p->childs[i] = NULL;\n    }\n    p->count = 0;\n    return p;\n}\n\nvoid clear(TrieNode *node) {\n    if (node == NULL) return ;\n    for (int i = 0; i < SIZE; i++) {\n        if (node->childs[i] == NULL) continue;\n        clear(node->childs[i]);\n    }\n    free(node->childs);\n    free(node);\n    return ;\n}\n\nvoid insert(TrieNode *trie, const char *buffer) {\n    TrieNode *p = trie;\n    for (int i = 0; i < strlen(buffer); i++) {\n        if (p->childs[buffer[i] - BASE] == NULL) {\n            p->childs[buffer[i] - BASE] = new_node();\n        }\n        p = p->childs[buffer[i] - BASE];\n    }\n    p->count++;\n    return ;\n}\n\nvoid build_automaton(TrieNode *node) {\n    TrieNode **queue = (TrieNode **)malloc(sizeof(TrieNode *) * (MAX_SIZE + 5));\n    int head = 0, tail = 0;\n    queue[tail++] = node;\n    while (head < tail) {\n        TrieNode *now = queue[head++];\n        for (int i = 0; i < SIZE; i++) {\n            if (now->childs[i] == NULL) {\n                if (now != node) now->childs[i] = now->fail->childs[i];\n                continue;\n            }\n            TrieNode *p = (now->fail ? now->fail->childs[i] : node);\n            if (p == NULL) p = node;\n            now->childs[i]->fail = p;\n            queue[tail++] = now->childs[i];\n        }\n    }\n    free(queue);\n    return ;\n}\n\nint match_count(TrieNode *ac_tree, const char *str) {\n    int ret = 0;\n    TrieNode *p = ac_tree, *q;\n    while (str[0]) {\n        p = p->childs[str[0] - \'a\'];\n        q = p;\n        while (q) ret += q->count, q = q->fail;\n        if (p == NULL) p = ac_tree;\n        str++;\n    }\n    return ret;\n}\nint main() {\n    Trie root = new_node();\n    int n;\n    scanf("%d", &n);\n    for (int i = 0; i < n; ++i) {\n        char pattern[MAX_LEN];\n        scanf("%s", pattern);\n        insert(root, pattern);\n    }\n    printf("insert done\\n");\n    fflush(stdout);\n    build_automaton(root);\n    scanf("%s", str_buffer);\n    printf("%d\\n", match_count(root, str_buffer));\n    //clear(root);\n    return 0;\n}\n')),(0,a.kt)("h2",{id:"\u6700\u5927\u5f02\u6216\u548c\u5b50\u6570\u7ec4"},"\u6700\u5927\u5f02\u6216\u548c\u5b50\u6570\u7ec4"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\u9898\u76ee\uff1a\u7ed9\u5b9a\u4e00\u4e2a\u6570\u7ec4\uff0c\u6c42\u5b50\u6570\u7ec4\u7684\u6700\u5927\u5f02\u6216\u548c\u3002\u5176\u4e2d\uff0c\u4e00\u4e2a\u6570\u7ec4\u7684\u5f02\u6216\u548c\u5b9a\u4e49\u4e3a\u6570\u7ec4\u4e2d\u6240\u6709\u7684\u6570\u5f02\u6216\u8d77\u6765\u7684\u7ed3\u679c\u3002\n")),(0,a.kt)("h3",{id:"\u5e38\u89c4\u89e3\u6cd5"},"\u5e38\u89c4\u89e3\u6cd5"),(0,a.kt)("p",null,"\u6d89\u53ca\u5b50\u6570\u7ec4\u7684\u9898\u76ee\uff0c\u603b\u4f53\u601d\u8def\u4e00\u6837\uff1a\u4ee5",(0,a.kt)("inlineCode",{parentName:"p"},"i"),"\u7ed3\u5c3e\u7684\u5b50\u6570\u7ec4\u5f02\u6216\u548c\uff0c\u518d\u5c06",(0,a.kt)("inlineCode",{parentName:"p"},"i"),"\u4ece",(0,a.kt)("inlineCode",{parentName:"p"},"0 < i <= n"),"\u904d\u5386\u4e00\u904d\uff0c\u6c42\u51fa\u6240\u6709\u4f4d\u7f6e\u7684\u5b50\u6570\u7ec4\u5f02\u6216\u548c\uff0c\u6700\u5927\u503c\u5c31\u5728\u5176\u4e2d\u3002\u4f46\u662f\u5982\u6b64\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u5206\u6790\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\u4ee5i\u4e3a\u4f8b\uff1a\n    i-1~i\n    i-2~2\n    ...\n    0 ~ i\n")),(0,a.kt)("p",null,"\u9700\u8981\u6c42\u51fai\u4e2a\u5b50\u6570\u7ec4\u7684\u5f02\u6216\u548c\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u5f02\u6216\u548c\u65f6\u95f4\u590d\u6742\u5ea6\u4e3a",(0,a.kt)("inlineCode",{parentName:"p"},"O(n)"),",\u56e0\u4e3a\u4ec5\u4ec5\u6c42\u4e00\u4e2a\u4f4d\u7f6ei\u7684\u5b50\u6570\u7ec4\u5f02\u6216\u548c\u5c31\u9ad8\u8fbe",(0,a.kt)("inlineCode",{parentName:"p"},"O(n^2)"),"\u7684\u590d\u6742\u5ea6\u3002\u5916\u5c42\u518d\u5c06i\u4ece",(0,a.kt)("inlineCode",{parentName:"p"},"0 < i <= n"),"\u904d\u5386\u4e00\u904d\uff0c\u65f6\u95f4\u590d\u6742\u5ea6",(0,a.kt)("inlineCode",{parentName:"p"},"O(n^3)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int maxXor(int* arr, int length) {\n    int outside_xor =0;\n    int max_=0;\n\n    for(int i=0; i < length; ++i) { \n        outside_xor ^= arr[i];   // \u8bb0\u5f55\u4ee5 i \u4f4d\u7f6e\u7ed3\u675f\u7684 0~i\u7684\u6570\u7ec4\u5f02\u6216\u548c\n        max_ = std::max(max_, outside_xor);\n        // \u6c42\u53d6\u4ee5i\u4f4d\u7f6e\u7ed3\u5c3e\u7684\u6240\u6709\u5b50\u6570\u7ec4\u5f02\u6216\u548c\n        for(int j=0; j < i; ++j) { \n            int inside_xor = 0;\n            for(int k=0; k < j; ++k) { \n                inside_xor ^= arr[k];                //  0~ j-1 \u4f4d\u7f6e\u7684\u5f02\u6216\u548c \n                int x = outside_xor ^ inside_xor;    // j ~ i \u4f4d\u7f6e\u7684\u5f02\u6216\u548c\uff0c\u5176\u4e2d 0 <= j <i\uff0c\u8fd9\u5c31\u662f\u4ee5i\u7ed3\u5c3e\u6240\u6709\u5b50\u6570\u7ec4\u5f02\u6216\u548c\n                if(max_ < x) max_ = x;\n            }\n        }\n    }\n    return max_;\n}\n")),(0,a.kt)("p",null,"\u5982\u679c\u6539\u8fdb\uff0c\u964d\u4f4e\u7b97\u6cd5\u7684\u590d\u6742\u5ea6\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4\u8bb0\u5f55\u4e0b\u4e4b\u524d\u7684\u4e00\u4e9b\u91cd\u590d\u8ba1\u7b97\u7684\u503c\u3002\u6bd4\u5982\u8fd9\u9898\u7684\u6240\u6709\u4ee5",(0,a.kt)("inlineCode",{parentName:"p"},"j"),"\u7ed3\u5c3e\u7684",(0,a.kt)("inlineCode",{parentName:"p"},"0~j"),"\u7684\u5b50\u6570\u7ec4\uff0c\u90fd\u5728\u91cd\u590d\u8ba1\u7b97\uff0c\u90a3\u4e48\u5c31\u662f\u53ef\u4ee5\u7528\u4e00\u4e2a\u6570\u7ec4\u6765\u5b58\u50a8\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u53ef\u4ee5\u964d\u4f4e\u4e3a",(0,a.kt)("inlineCode",{parentName:"p"},"O(n^2)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"int maxXor(int* arr, int length) {\n    int outside_xor =0;\n    int max_=0;\n    int xorsum[length]; // \u4ee5 i\u7ed3\u675f\u7684 0~i\u7684\u6240\u6709\u5f02\u6216\u548c\n\n    for(int i=0; i < length; ++i) { \n        outside_xor ^= arr[i]; \n        max_ = std::max(max_, outside_xor);\n        xorsum[i] = outside_xor;   // \u5b58\u50a8\u8d77\u6765\n        for(int j=0; j < i; ++j) { \n            int x =  xorsum[j] ^ outside_xor; // \u8fd9\u91cc\u4ee5 0~j\u533a\u95f4\u7684\u5f02\u6216\u548c\uff0c\u4e4b\u524d\u5df2\u7ecf\u8ba1\u7b97\u597d\uff0c\u76f4\u63a5\u4f7f\u7528\n            if(max_ < x) max_ = x;\n        }\n    }\n    return max_;\n}\n")),(0,a.kt)("h3",{id:"\u524d\u7f00\u6811"},"\u524d\u7f00\u6811"),(0,a.kt)("p",null,"\u5c06\u6bcf\u4e2a\u6570\u5b57\u53d8\u6210\u4e8c\u8fdb\u5236\u7528\u4e00\u4e2a\u4e8c\u53c9\u6811\u6765\u8868\u793a\uff0c\u6240\u6709\u7684\u4e8c\u53c9\u6811\u90fd\u662f\u5de6\u5b50\u8282\u70b9\u662f0\uff0c\u53f3\u5b50\u8282\u70b9\u662f1\u3002\u6574\u4e2a\u6811\u6839\u8282\u70b9\u4e0d\u8868\u793a\uff0c\u53ea\u662f\u4e32\u8054\u5de6\u53f3\u5b50\u6811\u3002"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"0 ~ 1\u7684\u5f02\u6216\u548c\n0 ~ 2\u7684\u5f02\u6216\u548c\n...\n0 ~ i-1\u7684\u5f02\u6216\u548c\n")),(0,a.kt)("p",null,"\u5728\u6c42",(0,a.kt)("inlineCode",{parentName:"p"},"0~i"),"\u533a\u95f4\u6700\u5927\u5f02\u6216\u548c\u5b50\u6570\u7ec4\u65f6\uff0c\u524d\u9762\u5f97\u5404\u4e2a\u4f4d\u7f6e\u4fe1\u606f\u90fd\u5df2\u7ecf\u5177\u5907\u4e86\u3002\u56e0\u6b64\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u4e86\uff1a\u5c06 ",(0,a.kt)("inlineCode",{parentName:"p"},"0 ~ i")," \u524d\u9762\u7684\u5f02\u6216\u548c\u751f\u6210\u524d\u7f00\u6811\uff0c\u5728\u6c42",(0,a.kt)("inlineCode",{parentName:"p"},"i"),"\u4f4d\u7f6e",(0,a.kt)("inlineCode",{parentName:"p"},"arr[i]"),"\u7684\u65f6\u5019\uff0c\u5982\u4e0b\u9650\u5236\uff1a"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"\u7b2c\u4e00\u4f4d\u662f\u7b26\u53f7\u4f4d\uff0c\u5e94\u8be5\u8be5\u4f4d\u7f6e\u662f0\uff0c\u8868\u793a\u6b63\u6570"),(0,a.kt)("li",{parentName:"ul"},"\u9664\u4e86\u7b26\u53f7\u4f4d\u5916\uff0c\u5728\u524d\u7f00\u6811\u4e2d\uff0c\u80fd\u9009\u62e91\u5c31\u9009\u62e91\u3002\u5982\u679c\u6ca1\u67091\uff0c\u53ea\u80fd\u90090\u3002")),(0,a.kt)("p",null,"\u6ee1\u8db3\u4ee5\u4e0a\u4e24\u4e2a\uff0c\u8fd9\u6837\u624d\u80fd\u4fdd\u6301\u6700\u5927\u3002 \u8bf4\u7684\u53ef\u80fd\u4e0d\u592a\u597d\u7406\u89e3\u3002"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\u6bd4\u5982\uff1a\n 0 ~ 0\u7684\u5f02\u6216\u548c\u662f 0001 \n 0 ~ 1\u7684\u5f02\u6216\u548c\u662f 0101\n 0 ~ 2\u7684\u5f02\u6216\u548c\u662f 1011\n 0 ~ 3\u7684\u5f02\u6216\u548c\u662f 1111\n \u6c42\u4ee5\u4f4d\u7f6e3\u7ed3\u5c3e\u7684\u6700\u5927\u5f02\u6216\u548c\u5b50\u6570\u7ec4 \n \n                        root \n                      /     \\\n                     0       1\n                    / \\     /\n                   0   1   0\n                  /    /    \\\n                 0    0      1\n                 \\     \\      \\\n                  1     1      1\n")),(0,a.kt)("p",null,"\u4ee5",(0,a.kt)("inlineCode",{parentName:"p"},"0~3"),"\u4f4d\u7f6e\u7684\u5f02\u6216\u548c",(0,a.kt)("inlineCode",{parentName:"p"},"1111"),"\u6765\u786e\u5b9a\u4ee5\u4f4d\u7f6e3\u7ed3\u5c3e\u7684\u6700\u5927\u5f02\u6216\u548c\u5b50\u6570\u7ec4\u3002"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"\u7b2c\u4e00\u4f4d\u7b26\u53f7\u4f4d\u662f1\uff1a\u671f\u671b\u7684\u662f0\uff0c\u4e0a\u9762\u7684\u524d\u7f00\u6811\u4e2d\u7b2c\u4e8c\u5c42\u5b58\u5728 root - 1"),(0,a.kt)("li",{parentName:"ul"},"\u7b2c\u4e8c\u4f4d\u662f1\uff0c\u5982\u679c\u8981\u8ba9\u5f02\u6216\u548c\u6700\u5927\uff0c\u8fd9\u4f4d\u5f02\u6216\u540e\u7684\u7ed3\u679c\u4e5f\u662f1\uff0c\u90a3\u4e48\u5c31\u671f\u5f850\u3002\u524d\u7f00\u6811\u4e2d\u4e5f\u5b58\u5728 root - 1 - 0"),(0,a.kt)("li",{parentName:"ul"},"\u540c\u7406\uff0c\u7b2c\u4e09\u4f4d\u4e5f\u671f\u671b\u662f1\uff0c\u9700\u8981\u4e0e0\u5f02\u6216\uff0c\u4f46\u662f\u6b64\u65f6\u4e0d\u5b58\u57280\uff0c\u53ea\u80fd\u9009\u62e91"),(0,a.kt)("li",{parentName:"ul"},"\u540c\u7406\uff0c\u7b2c\u56db\u4f4d\u4e5f\u53ea\u80fd\u4e0e1\u5f02\u6216")),(0,a.kt)("p",null,"\u6700\u7ec8\u7684\u5f02\u6216",(0,a.kt)("inlineCode",{parentName:"p"},"1011 ^ 1111 =  0100"),"\uff0c\u5373\u4f7f4\uff0c\u4e5f\u5c31\u662f\u6700\u5927\u5f02\u6216\u5b50\u6570\u7ec4\u533a\u95f4\uff1a",(0,a.kt)("inlineCode",{parentName:"p"},"[2,3]"),"\u3002 \u4ee3\u7801\u53ca\u5176\u89e3\u91ca\u5982\u4e0b\uff1a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"public class Solution { \n\n    public static class Node {\n        public Node[] nexts = new Node[2]; // \u4e24\u4e2a\u8282\u70b9\uff0c\u4e00\u4e2a\u6307\u54110\uff0c\u4e00\u4e2a\u6307\u54111\uff0c\n    }\n\n    public static class NumTrie {\n        public Node head = new Node();\n\n        // \u7528\u4e8e\u751f\u6210\u524d\u7f00\u6811\n        public void add(int num) {\n            Node cur = head;\n            for (int move = 31; move >= 0; move--) {\n                // \u4ece\u9ad8\u4f4d\u5230\u4f4e\u4f4d \u4f9d\u6b21\u53d6\u51fa\u6bcf\u4e00\u4f4d\u7684\u4e8c\u8fdb\u5236\u6570\n                int path = ((num >> move) & 1);\n                // cur.nexts[path] = cur.nexts[path] == null ? new Node() : cur.nexts[path];\n                if(cur.nexts[path] == null)\n                    cur.nexts[path] = new Node();\n                    \n                cur = cur.nexts[path];\n            }\n        }\n\n        // \u6839\u636e\u524d\u7f00\u6811\u67e5\u8be2\u5f02\u6216\u6700\u5927\u503c\n        public int maxXor(int num) {\n            Node cur = head;\n            int res = 0;\n            for (int move = 31; move >= 0; move--) {\n                // \u53d6\u51fa\u6bcf\u4f4d\u4e8c\u8fdb\u5236\u6570\n                int path = (num >> move) & 1;\n                // \u7b26\u53f7\u4f4d\uff0c\u9700\u8981\u548c\u7b26\u53f7\u4f4d\u4fdd\u6301\u4e00\u81f4\uff0c\u624d\u80fd\u5f02\u6216\u4e3a0\u3002\u975e\u7b26\u53f7\u4f4d\u671f\u671b\u662f1 \n                // \u975e\u7b26\u53f7\u4f4d\u7f6e\uff0c\u9700\u8981\u5f02\u6216\u7684\u7ed3\u679c\u662f1\uff0c\u56e0\u6b64 path ^1\uff0c\u6700\u4f4e\u4e3a\u4f4d\u80af\u5b9a\u662f1\n                int best = move == 31 ? path : (path ^ 1);\n                // \u8fd9\u91cc\u6ca1\u6709\u521b\u5efa\u7ed3\u70b9\uff0c\u5c31\u662f\u67e5\u8be2\uff0c\u9009\u62e9\u9053\u8def\n                best = cur.nexts[best] != null ? best : (best ^ 1); // \u5b9e\u9645\u7684\u503c\n                res |= (path ^ best) << move; \n                cur = cur.nexts[best];\n            }\n            return res;\n        }\n\n    }\n\n    public static int maxXorSubarray(int[] arr) {\n        if (arr == null || arr.length == 0) {\n            return 0;\n        }\n        int max = Integer.MIN_VALUE;\n        int eor = 0;\n        NumTrie numTrie = new NumTrie();\n        numTrie.add(0);\n        for (int i = 0; i < arr.length; i++) {\n            eor ^= arr[i]; //  0 ~ i \u7684\u5f02\u6216\u548c\n            max = Math.max(max, numTrie.maxXor(eor)); // \u6c42\u53d6\n            numTrie.add(eor);\n        }\n        return max;\n    }\n}\n")),(0,a.kt)("p",null,"\u663e\u800c\u6613\u89c1\uff0c\u65f6\u95f4\u590d\u6742\u5ea6\u662f",(0,a.kt)("inlineCode",{parentName:"p"},"O(N)"),"\u3002"),(0,a.kt)("h1",{id:"\u591a\u6a21\u5339\u914d\u95ee\u9898"},"==\u591a\u6a21\u5339\u914d\u95ee\u9898=="),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\u6709\u591a\u4e2a\u6a21\u5f0f\u4e32\u7684\u5339\u914d\u95ee\u9898\uff0c\u5c31\u662f\u591a\u6a21\u5339\u914d\u95ee\u9898"),(0,a.kt)("li",{parentName:"ol"},"Step1\uff1a\u591a\u4e2a\u6a21\u5f0f\u4e32\uff0c\u5efa\u7acb\u6210\u4e00\u68f5\u5b57\u5178\u6811"),(0,a.kt)("li",{parentName:"ol"},"Step2\uff1a\u548c\u6587\u672c\u4e32\u7684\u6bcf\u4e00\u4f4d\u5bf9\u9f50\u5339\u914d\uff0c\u6a21\u62df\u66b4\u529b\u5339\u914d\u7b97\u6cd5\u7684\u8fc7\u7a0b")),(0,a.kt)("h2",{id:"ac-\u81ea\u52a8\u673a\u7684\u601d\u60f3"},"AC \u81ea\u52a8\u673a\u7684\u601d\u60f3"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"\u5f53\u5339\u914d\u6210\u529f\u6587\u672c\u4e32\u4e2d\u7684 she \u65f6\uff0c\u4e5f\u5c31\u610f\u5473\u7740\u540e\u7eed\u4e00\u5b9a\u4f1a\u5339\u914d\u6210\u529f he"),(0,a.kt)("li",{parentName:"ol"},"she \u5bf9\u5e94\u4e86\u5b57\u5178\u6811\u4e2d\u7684\u8282\u70b9 P\uff0che \u5bf9\u5e94\u4e86\u5b57\u5178\u6811\u4e2d\u7684\u8282\u70b9Q"),(0,a.kt)("li",{parentName:"ol"},"P \u548c Q \u5c31\u662f\u7b49\u4ef7\u5339\u914d\u8282\u70b9\uff0c\u5982\u679c\u4ece P \u5f15\u51fa\u4e00\u6761\u8fb9\u6307\u5411 Q\uff0c\u5c31\u53ef\u4ee5\u52a0\u901f\u5339\u914d\u8fc7\u7a0b"),(0,a.kt)("li",{parentName:"ol"},"\u5728 P \u4e0b\u9762\u67e5\u627e\u8282\u70b9\u7684\u64cd\u4f5c\uff0c\u7b49\u4ef7\u4e8e\u5728 Q \u4e0b\u9762\u67e5\u627e\u8282\u70b9\u7684\u64cd\u4f5c"),(0,a.kt)("li",{parentName:"ol"},"\u8fd9\u6761\u7b49\u4ef7\u5173\u7cfb\u8fb9\uff0c\u901a\u5e38\u5728 AC \u81ea\u52a8\u673a\u4e0a\u53eb\u505a \u3010Fail \u6307\u9488\u3011\u7b49\u4ef7\u5339\u914d\u6307\u9488"),(0,a.kt)("li",{parentName:"ol"},"AC \u81ea\u52a8\u673a = Trie + Fail \u6307\u9488"),(0,a.kt)("li",{parentName:"ol"},"\u5b50\u8282\u70b9\u7684 Fail \u6307\u9488\u662f\u9700\u8981\u53c2\u7167\u7236\u8282\u70b9\u7684 Fail\u6307\u9488\u4fe1\u606f\u7684\uff0c\u6700\u7b80\u5355\u7684\u5efa\u7acb\u65b9\u5f0f\uff0c\u5c31\u662f\u91c7\u7528\u3010\u5c42\u5e8f\u904d\u5386\u3011"),(0,a.kt)("li",{parentName:"ol"},"\u6ca1\u505a\u4f18\u5316\u7684 AC \u81ea\u52a8\u673a\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a NFA\uff08\u975e\u786e\u5b9a\u578b\u6709\u7a77\u72b6\u6001\u81ea\u52a8\u673a\uff09"),(0,a.kt)("li",{parentName:"ol"},"\u901a\u4fd7\u7406\u89e3\uff1a\u6839\u636e\u5f53\u524d\u72b6\u6001 p\uff0c\u4ee5\u53ca\u8f93\u5165\u5b57\u7b26 c\uff0c\u65e0\u6cd5\u901a\u8fc7\u4e00\u6b65\u64cd\u4f5c\u786e\u5b9a\u72b6\u6001"),(0,a.kt)("li",{parentName:"ol"},"\u7b2c\u4e8c\u79cd\u7406\u89e3\uff1a\u5f53\u524d\u72b6\u6001\uff0c\u5e76\u4e0d\u4ee3\u8868\u552f\u4e00\u72b6\u6001\u3002")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"AC \u81ea\u52a8\u673a\u4f18\u5316\uff1a"),"\u4f7f\u7528\u8def\u5f84\u538b\u7f29\u601d\u60f3\uff0c\u4f7f\u72b6\u6001\u8f6c\u79fb\u65f6\u53ef\u4ee5\u4e00\u6b65\u8df3\u8f6c\u5230\u76ee\u6807\u72b6\u6001\u3002"),(0,a.kt)("p",null,"\u4f18\u5316\u4ee5\u540e\u7684 AC \u81ea\u52a8\u673a\uff0c\u66f4\u50cf DFA\uff08\u786e\u5b9a\u6027\u6709\u7a77\u72b6\u6001\u81ea\u52a8\u673a\uff09\u3002"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image-20210127193634993",src:t(35870).Z})),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image-20210127193826398",src:t(7447).Z})),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"image-20210217201415813",src:t(71453).Z})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define BASE 26\n#define BEGIN_LETTER \'a\'\n\ntypedef struct Node {\n    int flag;\n    struct Node *next[BASE], *fail;\n} Node;\n\ntypedef struct Queue {\n    Node **data;\n    int head, tail, size;\n} Queue;\n\nQueue *init_queue(int n) {\n    Queue *q = (Queue *)calloc(sizeof(Queue), 1);\n    q->data = (Node **)malloc(sizeof(Node *) * n);\n    q->tail = q->head = 0;\n    return q;\n}\n\nNode *front(Queue *q) {\n    return q->data[q->head];\n}\n\nint empty(Queue *q) {\n    return q->head == q->tail;\n}\n\nvoid push(Queue *q, Node *node) {\n    q->data[q->tail++] = node;\n    return ;\n}\n\nvoid pop(Queue *q) {\n    if (empty(q)) return ;\n    q->head++;\n}\n\nvoid clear_queue(Queue *q) {\n    if (q == NULL) return ;\n    free(q->data);\n    free(q);\n    return ;\n}\n\nNode *getNewNode() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    return p;\n}\n\nint insert(Node *root, const char *str) {\n    int cnt = 0;\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), ++cnt;\n        p = p->next[ind];\n    }\n    p->flag = 1;\n    return cnt;\n}\n\nvoid clear(Node *node) {\n    if (node == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(node->next[i]);\n    }\n    free(node);\n    return ;\n}\n\nvoid build_ac(Node *root, int n) {\n    Queue *q = init_queue(n + 10);\n    root->fail = NULL;\n    push(q, root);\n    while (!empty(q)) {\n        Node *now_node = front(q);\n        pop(q);\n        for (int i = 0; i < BASE; i++) {\n            if (now_node->next[i] == NULL) continue;\n            Node *p = now_node->fail;\n            while (p && p->next[i] == NULL) p = p->fail;\n            if (p == NULL) now_node->next[i]->fail = root;\n            else now_node->next[i]->fail = p->next[i];\n            push(q, now_node->next[i]);\n        }\n    }\n    return ;\n}\n\nint match(Node *root, const char *str) {\n    int cnt = 0;\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        while (p && p->next[ind] == NULL) p = p->fail;\n        if (p == NULL) p = root;\n        else p = p->next[ind];\n        Node *q = p;\n        while (q) cnt += q->flag, q = q->fail;\n    }\n    return cnt;\n}\n\nint main() {\n    Node *root = getNewNode();\n    int n, cnt = 0;\n    char str[1000];\n    scanf("%d", &n);\n    for (int i = 0; i < n; i++) {\n        scanf("%s", str);\n        cnt += insert(root, str);\n    }\n    // build ac\n    build_ac(root, cnt);\n    scanf("%s", str);\n    // match ac\n    printf("match word cnt : %d\\n", match(root, str));\n    return 0;\n}\n')),(0,a.kt)("h2",{id:"\u9884\u4e60\u8d44\u6599\uff1a\u3010\u6570\u636e\u7ed3\u6784\u3011-\u5b57\u7b26\u4e32\u7edf\u8ba1"},"\u9884\u4e60\u8d44\u6599\uff1a\u3010\u6570\u636e\u7ed3\u6784\u3011> \u5b57\u7b26\u4e32\u7edf\u8ba1"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"AC \u81ea\u52a8\u673a\u88f8\u9898")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\u89e3\u9898\u7684\u5173\u952e\uff0c\u5728\u4e8e\u5982\u4f55\u7ef4\u62a4\u6bcf\u4e00\u4e2a\u5355\u8bcd\u7684\u8ba1\u6570\u91cf")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"\u4f7f\u7528\u5e7c\u513f\u56ed\u5fc5\u77e5\u5fc5\u4f1a\u7684\u6307\u9488\u6280\u5de7\u7ef4\u62a4\u7684")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"\u8239\u957f\u7ffb\u8f66\uff1a"),"\u9898\u76ee\u6570\u636e\u4e2d\u7ed9\u51fa\u7684\u5355\u8bcd\u4f1a\u6709\u91cd\u590d"))),(0,a.kt)("h3",{id:"\u5b58\u50a8\u4efb\u610f\u7c7b\u578b\u7684\u6808"},"\u5b58\u50a8\u4efb\u610f\u7c7b\u578b\u7684\u6808"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"/*************************************************************************\n   > File Name: 15.any_stack.h\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u4e09  2/28 10:49:10 2018\n ************************************************************************/\n\n#ifndef _15_ANY_STACK_H\n#define _15_ANY_STACK_H\n\n#include <stdlib.h>\n#include <string.h>\n\n#define STACK_OK 1\n#define STACK_ERROR 0\n\ntypedef struct Stack {\n    char *data;\n    int data_size;\n    int size, top;\n} Stack;\n\n#define init_stack(n, T) (__init_stack(n, sizeof(T)))\n#define push_stack(s, data) (__push_stack(s, (char *)(data)))\n#define top_stack(s, T) ((T *)(__top_stack(s)))\n\nStack *__init_stack(int n, int data_size) {\n    Stack *s = (Stack *)malloc(sizeof(Stack) * 1);\n    s->data = (char *)malloc(n * data_size);\n    s->data_size = data_size;\n    s->size = n;\n    s->top = -1;\n    return s;\n}\n\nint __push_stack(Stack *s, char *data) {\n    if (s->size - 1 == s->top) {\n        return STACK_ERROR;\n    }\n    s->top += 1;\n    memcpy(s->data + s->top * s->data_size, data, s->data_size);\n    return STACK_OK;\n}\n\nint empty_stack(Stack *s) {\n    return s->top == -1;\n}\n\nchar *__top_stack(Stack *s) {\n    if (empty_stack(s)) {\n        return NULL;\n    }\n    return s->data + s->top * s->data_size;\n}\n\nint pop_stack(Stack *s) {\n    if (empty_stack(s)) {\n        return STACK_ERROR;\n    }\n    s->top -= 1;\n    return STACK_OK;\n}\n\nvoid clear_stack(Stack *s) {\n    free(s->data);\n    free(s);\n    return ;\n}\n\n#endif\n")),(0,a.kt)("h3",{id:"\u4e8c\u53c9\u6811\u524d\u5e8f\u904d\u5386\uff08\u975e\u9012\u5f52\uff09"},"\u4e8c\u53c9\u6811\u524d\u5e8f\u904d\u5386\uff08\u975e\u9012\u5f52\uff09"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'/*************************************************************************\n   > File Name: 14.binary_non_recursive.cpp\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u4e09  2/28 10:26:37 2018\n ************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include "15.any_stack.h"\n\ntypedef struct Node {\n    int data;\n    struct Node *lchild, *rchild;\n} Node;\n\nNode *getNewNode(int data) {\n    Node *p = (Node *)malloc(sizeof(Node) * 1);\n    p->data = data;\n    p->lchild = p->rchild=  NULL;\n    return p;\n}\n\nNode *init_binary_tree() {\n    Node *root = getNewNode(1);\n    root->lchild = getNewNode(3);\n    root->rchild = getNewNode(6);\n    root->lchild->rchild = getNewNode(9);\n    root->rchild->rchild = getNewNode(11);\n    root->rchild->lchild = getNewNode(14);\n    root->lchild->rchild->lchild = getNewNode(17);\n    return root;\n}\n\nvoid __pre_order(Node *root) {\n    // status = 0\n    if (root == NULL) return ; // status = 100\n    printf("%d\\n", root->data); // status = 1\n    __pre_order(root->lchild); // status = 2\n    __pre_order(root->rchild); // status = 3\n    return ; // status = 100\n}\n\ntypedef struct PreOrderArgs {\n    Node *root;\n    int status;\n} PreOrderArgs;\n\nPreOrderArgs *getNewArgs(Node *root) {\n    PreOrderArgs *p = (PreOrderArgs *)malloc(sizeof(PreOrderArgs) * 1);\n    p->root = root;\n    p->status = 0;\n    return p;\n}\n\nvoid pre_order(Node *root) {\n    Stack *s = init_stack(100, PreOrderArgs);\n    PreOrderArgs *temp_args = getNewArgs(root), *p_args;\n    push_stack(s, temp_args);\n    while (!empty_stack(s)) {\n        p_args = top_stack(s, PreOrderArgs);\n        switch (p_args->status) {\n            case 0: {\n                if (p_args->root == NULL) {\n                    p_args->status = 100;\n                } else {\n                    p_args->status = 1;\n                }\n            } break;\n            case 1: {\n                printf("%d\\n", p_args->root->data);\n                p_args->status = 2;\n            } break;\n            case 2: {\n                temp_args->root = p_args->root->lchild;\n                temp_args->status = 0;\n                push_stack(s, temp_args);\n                p_args->status = 3;\n            } break;\n            case 3: {\n                temp_args->root = p_args->root->rchild;\n                temp_args->status = 0;\n                push_stack(s, temp_args);\n                p_args->status = 100;\n            } break;\n            case 100: {\n                pop_stack(s);\n            } break;\n        }\n    }\n    free(temp_args);\n    clear_stack(s);\n    return ;\n}\n\n\n\nint main() {\n    Node *root = init_binary_tree();\n    pre_order(root);\n    __pre_order(root);\n    return 0;\n}\n')),(0,a.kt)("h1",{id:"3-\u5feb\u901f\u6392\u5e8f\uff08\u975e\u9012\u5f52\uff09"},"3. \u5feb\u901f\u6392\u5e8f\uff08\u975e\u9012\u5f52\uff09"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MC(T, n) ((T *)malloc(sizeof(T) * n))\n\n#define init_stack(s, n, T) (__init_stack(s, n, sizeof(T)))\n#define push_stack(s, value) ({ \\\n    __typeof(value) __temp = (value); \\\n    __push_stack(s, (const char *)(&(__temp))); \\\n})\n\n#define empty_stack(s) (__empty_stack(s))\n#define pop_stack(s) (__pop_stack(s))\n#define top_stack(s, T) (*((T *)__top_stack(s)))\n#define clear_stack(s) (__clear_stack(s))\n#define swap(a, b) { \\\n    __typeof(a) __temp = (a); \\\n    (a) = (b); (b) = (__temp); \\\n}\n#define ERROR 0\n#define OK 1\n\ntypedef struct Stack {\n    char *data;\n    int top, size;\n    int value_size;\n} Stack;\n\nvoid __init_stack(Stack *s, int n, int value_size);\nint __push_stack(Stack *s, const char *value);\nint __empty_stack(Stack *s);\nint __pop_stack(Stack *s);\nchar *__top_stack(Stack *s);\nvoid __clear_stack(Stack *s);\n\ntypedef struct Node {\n    int val;\n    struct Node *lchild, *rchild;\n} Node;\n\nNode *init(int val) {\n    Node *p = MC(Node, 1);\n    p->val = val;\n    p->lchild = p->rchild = NULL;\n    return p;\n}\n\ntypedef struct QuickSortArgs {\n    int *arr;\n    int l, r;\n    int x;\n    int status;\n} QuickSortArgs;\n\nint __quick_sort(int *arr, int l, int r) {\n    // 0 : if (r <= l) return ;\n    int x, y, z;\n    x = l, y = r, z = arr[l];\n    while (x < y) {\n        while (x < y && arr[y] >= z) --y;\n        if (x < y) arr[x++] = arr[y];\n        while (x < y && arr[x] <= z) ++x;\n        if (x < y) arr[y--] = arr[x];\n    }\n    arr[x] = z;\n    return x;\n    // 2: quick_sort(arr, l, x - 1);\n    // 3 : quick_sort(arr, x + 1, r);\n    // 4 : return ;\n}\n\nvoid init_quick_sort_args(QuickSortArgs *qsa, int *arr, int l, int r, int status) {\n    qsa->arr = arr;\n    qsa->l = l;\n    qsa->r = r;\n    qsa->status = 0;\n    return ;\n}\n\nvoid quick_sort(int *arr, int n) {\n    Stack *s = MC(Stack, 1);\n    init_stack(s, 1000, QuickSortArgs);\n    QuickSortArgs qsa;\n    init_quick_sort_args(&qsa, arr, 0, n - 1, 0);\n    push_stack(s, qsa);\n    while (!empty_stack(s)) {\n        QuickSortArgs *tqsa = &top_stack(s, QuickSortArgs);\n        switch (tqsa->status) {\n            case 0:\n                if (tqsa->r <= tqsa->l) {\n                    tqsa->status = 4;\n                } else {\n                    tqsa->status = 1;\n                }\n                break;\n            case 1:\n                tqsa->x = __quick_sort(tqsa->arr, tqsa->l, tqsa->r);\n                tqsa->status = 2;\n                break;\n            case 2:\n                init_quick_sort_args(&qsa, arr, tqsa->l, tqsa->x - 1, 0);\n                push_stack(s, qsa);\n                tqsa->status = 3;\n                break;\n            case 3:\n                init_quick_sort_args(&qsa, arr, tqsa->x + 1, tqsa->r, 0);\n                push_stack(s, qsa);\n                tqsa->status = 4;\n                break;\n            case 4:\n                pop_stack(s);\n                break;\n            default:\n                printf("ERROR\\n");\n                break;\n        }\n    }\n    return ;\n}\n\nint main() {\n    int arr[10] = {9, 7, 5, 4, 2 ,1 ,3, 10, 6, 8};\n    quick_sort(arr, 10);\n    for (int i = 0; i < 10; i++) {\n        printf("%d ", arr[i]);\n    }\n    printf("\\n");\n    return 0;\n}\nvoid __init_stack(Stack *s, int n, int value_size) {\n    s->data = (char *)malloc(value_size * n);\n    s->top = -1;\n    s->size = n;\n    s->value_size = value_size;\n    return ;\n}\n\nint __push_stack(Stack *s, const char *value) {\n    if (s->top == s->size - 1) {\n        return ERROR;\n    }\n    ++(s->top);\n    memcpy(s->data + s->top * s->value_size, value, s->value_size);\n    return OK;\n}\n\nint __empty_stack(Stack *s) {\n    return s->top == -1;\n}\n\nint __pop_stack(Stack *s) {\n    if (__empty_stack(s)) {\n        return ERROR;\n    }\n    --(s->top);\n    return OK;\n}\n\nchar *__top_stack(Stack *s) {\n    if (__empty_stack(s)) {\n        return NULL;\n    }\n    return s->data + s->top * s->value_size;\n}\n\nvoid __clear_stack(Stack *s) {\n    free(s->data);\n    free(s);\n    return ;\n}\n')),(0,a.kt)("h2",{id:"\u57fa\u4e8e\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a-1"},"\u57fa\u4e8e\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'/*************************************************************************\n   > File Name: 19.ac.cpp\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u65e5  1/13 20:43:58 2019\n ************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define BASE 26\n#define BEGIN_LETTER \'a\'\n\ntypedef struct Node {\n    int flag;\n    struct Node *next[BASE], *fail;\n} Node;\n\ntypedef struct Queue {\n    Node **data;\n    int head, tail, size;\n} Queue;\n\nQueue *init_queue(int n) {\n    Queue *q = (Queue *)calloc(sizeof(Queue), 1);\n    q->data = (Node **)malloc(sizeof(Node *) * n);\n    q->tail = q->head = 0;\n    return q;\n}\n\nNode *front(Queue *q) {\n    return q->data[q->head];\n}\n\nint empty(Queue *q) {\n    return q->head == q->tail;\n}\n\nvoid push(Queue *q, Node *node) {\n    q->data[q->tail++] = node;\n    return ;\n}\n\nvoid pop(Queue *q) {\n    if (empty(q)) return ;\n    q->head++;\n}\n\nvoid clear_queue(Queue *q) {\n    if (q == NULL) return ;\n    free(q->data);\n    free(q);\n    return ;\n}\n\nNode *getNewNode() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    return p;\n}\n\nint insert(Node *root, const char *str) {\n    int cnt = 0;\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), ++cnt;\n        p = p->next[ind];\n    }\n    p->flag = 1;\n    return cnt;\n}\n\nvoid clear(Node *node) {\n    if (node == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(node->next[i]);\n    }\n    free(node);\n    return ;\n}\n\nvoid build_ac(Node *root, int n) {\n    Queue *q = init_queue(n + 10);\n    root->fail = NULL;\n    push(q, root);\n    while (!empty(q)) {\n        Node *now_node = front(q);\n        pop(q);\n        for (int i = 0; i < BASE; i++) {\n            if (now_node->next[i] == NULL) continue;\n            Node *p = now_node->fail;\n            while (p && p->next[i] == NULL) p = p->fail;\n            if (p == NULL) now_node->next[i]->fail = root;\n            else now_node->next[i]->fail = p->next[i];\n            push(q, now_node->next[i]);\n        }\n    }\n    return ;\n}\n\nint match(Node *root, const char *str) {\n    int cnt = 0;\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        while (p && p->next[ind] == NULL) p = p->fail;\n        if (p == NULL) p = root;\n        else p = p->next[ind];\n        Node *q = p;\n        while (q) cnt += q->flag, q = q->fail;\n    }\n    return cnt;\n}\n\nint main() {\n    Node *root = getNewNode();\n    int n, cnt = 0;\n    char str[1000];\n    scanf("%d", &n);\n    for (int i = 0; i < n; i++) {\n        scanf("%s", str);\n        cnt += insert(root, str);\n    }\n    // build ac\n    build_ac(root, cnt);\n    scanf("%s", str);\n    // match ac\n    printf("match word cnt : %d\\n", match(root, str));\n    return 0;\n}\n')),(0,a.kt)("h2",{id:"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684-ac-\u81ea\u52a8\u673a-1"},"\u57fa\u4e8e\u53cc\u6570\u7ec4\u5b57\u5178\u6811\u7684 AC \u81ea\u52a8\u673a"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'/*************************************************************************\n   > File Name: 15.Double_Array_Trie.cpp\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u516d  8/ 4 15:28:36 2018\n ************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define BASE 26\n#define BEGIN_LETTER \'a\'\n#define max(a, b) ((a) > (b) ? (a) : (b))\n#define has_child(data, ind, i) (abs(data[data[ind].base + i].check) == ind)\n\ntypedef struct DANode {\n    int base, check, fail;\n    char *str;\n} DANode;\n\ntypedef struct Node {\n    int flag;\n    char *str;\n    struct Node *next[BASE];\n} Node, *Trie;\n\nint node_cnt = 0;\n\nNode *get_new_node() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    node_cnt += 1;\n    return p;\n}\n\nvoid clear(Trie root) {\n    if (root == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(root->next[i]);\n    }\n    if (root->flag) free(root->str);\n    free(root);\n    return ;\n}\n\nNode *insert(Trie root, const char *str) {\n    if (root == NULL) root = get_new_node();\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (p->next[ind] == NULL) p->next[ind] = get_new_node();\n        p = p->next[ind];\n    }\n    p->flag = 1;\n    p->str = strdup(str);\n    return root;\n}\n\nint get_base(Node *node, DANode *data) {\n    int base = 2, flag = 0;\n    while (!flag) {\n        flag = 1;\n        for (int i = 0; i < BASE; i++) {\n            if (node->next[i] == NULL) continue;\n            if (data[base + i].check == 0) continue;\n            flag = 0;\n            break;\n        }\n        base += (!flag);\n    }\n    return base;\n}\n\nint build(Node *node, DANode *data, int ind) {\n    if (node == NULL) return 0;\n    if (node->flag) data[ind].check = -data[ind].check, data[ind].str = node->str;\n    int max_ind = ind;\n    data[ind].base = get_base(node, data);\n    for (int i = 0; i < BASE; i++) {\n        if (node->next[i] == NULL) continue;\n        data[data[ind].base + i].check = ind;\n    }\n    for (int i = 0; i < BASE; i++) {\n        if (node->next[i] == NULL) continue;\n        int temp = build(node->next[i], data, data[ind].base + i);\n        max_ind = max(max_ind, temp);\n    }\n    return max_ind;\n}\n\nvoid build_ac(DANode *data) {\n    #define MAX_N 100000\n    int *queue = (int *)malloc(sizeof(int) * MAX_N);\n    int head = 0, tail = 0;\n    data[1].fail = 0;\n    queue[tail++] = 1;\n    while (head < tail) {\n        int ind = queue[head++];\n        for (int i = 0; i < BASE; i++) {\n            if (!has_child(data, ind, i)) continue;\n            int p = data[ind].fail;\n            while (p && !has_child(data, p, i)) p = data[p].fail;\n            if (p == 0) p = 1;\n            else p = data[p].base + i;\n            data[data[ind].base + i].fail = p;\n            queue[tail++] = data[ind].base + i;\n        }\n    }\n    return ;\n    #undef MAX_N\n}\n\nvoid search_ac(DANode *data, const char *str) {\n    int p = 1;\n    for (int i = 0; str[i]; i++) {\n        while (p && !has_child(data, p, str[i] - BEGIN_LETTER)) p = data[p].fail;\n        if (p == 0) p = 1;\n        else p = data[p].base + str[i] - BEGIN_LETTER;\n        int q = p;\n        while (q) {\n            if (data[q].check < 0) printf("find string : %s\\n", data[q].str);\n            q = data[q].fail;\n        }\n    }\n    return ;  \n}\n\nvoid output_da(DANode *data, int n) {\n    for (int i = 1; i <= n; i++) {\n        if (i - 1 && i % 5 == 1) printf("\\n");\n        printf("(%2d %2d %3d)    ", i, data[i].base, data[i].check);\n    }\n    printf("\\n");\n    return ;\n}\n\nint main() {\n    Trie root = NULL;\n    #define INSERT_CNT 5\n    root = insert(root, "hai");\n    root = insert(root, "zei");\n    root = insert(root, "ha");\n    root = insert(root, "ab");\n    root = insert(root, "ehz");\n    DANode *data = (DANode *)calloc(sizeof(DANode), (INSERT_CNT * 100));\n    int da_cnt = build(root, data, 1);\n    build_ac(data);\n    output_da(data, da_cnt);\n    search_ac(data, "sasherhs");\n    #undef INSERT_CNT \n    return 0;\n}\n')),(0,a.kt)("h2",{id:"ac-\u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb-1"},"AC \u81ea\u52a8\u673a\u7684\u9012\u5f52\u5efa\u7acb"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nconst int SIZE = 26;\nconst char BASE = \'a\';\nconst int MAX_SIZE = 200000;\nconst int MAX_LEN = 200000;\nchar str_buffer[200005];\n\ntypedef struct TrieNode {\n    int count;\n    struct TrieNode** childs;\n    struct TrieNode* fail, *father;\n} TrieNode, *Trie;\n\nTrieNode* new_node() {\n    TrieNode *p = (TrieNode *)malloc(sizeof(TrieNode));\n    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        p->childs[i] = NULL;\n    }\n    p->fail = NULL;\n    p->count = 0;\n    return p;\n}\n\nvoid clear(TrieNode *node) {\n    if (node == NULL) return ;\n    for (int i = 0; i < SIZE; i++) {\n        if (node->childs[i] == NULL) continue;\n        clear(node->childs[i]);\n    }\n    free(node->childs);\n    free(node);\n    return ;\n}\n\nvoid insert(TrieNode *trie, const char *buffer) {\n    TrieNode *p = trie;\n    for (int i = 0; i < strlen(buffer); i++) {\n        if (p->childs[buffer[i] - BASE] == NULL) {\n            p->childs[buffer[i] - BASE] = new_node();\n            p->childs[buffer[i] - BASE]->father = p;\n        }\n        p = p->childs[buffer[i] - BASE];\n    }\n    p->count++;\n    return ;\n}\n\nvoid build_automaton(TrieNode *node) {\n    #define next childs\n    #define Node TrieNode\n    if (node == NULL) return ;\n    if (node->fail == NULL) build_automaton(node->father);\n    for (int i = 0; i < SIZE; i++) {\n        if (node->next[i] == NULL) continue;\n        if (node->next[i]->fail) continue;\n        Node *p = node->fail, *pre_p = node;\n        while (p && p->next[i] == NULL) {\n            if (p->fail == NULL) build_automaton(p->father);\n            pre_p = p;\n            p = p->fail;\n        }\n        if (p == NULL) p = pre_p;\n        else p = p->next[i];\n        node->next[i]->fail = p;\n        build_automaton(node->next[i]);\n    }\n    return ;\n    #undef next\n    #undef Node\n}\n\nint match_count(TrieNode *ac_tree, const char *str) {\n    int ret = 0;\n    TrieNode *p = ac_tree, *q;\n    while (str[0]) {\n        while (p && p->childs[str[0] - \'a\'] == NULL) p = p->fail;\n        if (p == NULL) p = ac_tree;\n        else p = p->childs[str[0] - \'a\'];\n        q = p;\n        while (q) ret += q->count, q = q->fail;\n        str++;\n    }\n    return ret;\n}\n\nint main() {\n    Trie root = new_node();\n    int n;\n    scanf("%d", &n);\n    for (int i = 0; i < n; ++i) {\n        char pattern[MAX_LEN];\n        scanf("%s", pattern);\n        insert(root, pattern);\n    }\n    build_automaton(root);\n    scanf("%s", str_buffer);\n    printf("%d\\n", match_count(root, str_buffer));\n    //clear(root);\n    return 0;\n}\n')),(0,a.kt)("h2",{id:"ac-\u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316-1"},"AC \u81ea\u52a8\u673a\u7684\u7ebf\u7d22\u5316"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nconst int SIZE = 26;\nconst char BASE = \'a\';\nconst int MAX_SIZE = 200000;\nconst int MAX_LEN = 200000;\nchar str_buffer[200005];\n\ntypedef struct TrieNode {\n    int count;\n    struct TrieNode** childs;\n    struct TrieNode *fail;\n} TrieNode, *Trie;\n\nTrieNode* new_node() {\n    TrieNode *p = (TrieNode *)calloc(sizeof(TrieNode), 1);\n    p->childs = (TrieNode **)malloc(sizeof(TrieNode *) * SIZE);\n    for (int i = 0; i < SIZE; i++) {\n        p->childs[i] = NULL;\n    }\n    p->count = 0;\n    return p;\n}\n\nvoid clear(TrieNode *node) {\n    if (node == NULL) return ;\n    for (int i = 0; i < SIZE; i++) {\n        if (node->childs[i] == NULL) continue;\n        clear(node->childs[i]);\n    }\n    free(node->childs);\n    free(node);\n    return ;\n}\n\nvoid insert(TrieNode *trie, const char *buffer) {\n    TrieNode *p = trie;\n    for (int i = 0; i < strlen(buffer); i++) {\n        if (p->childs[buffer[i] - BASE] == NULL) {\n            p->childs[buffer[i] - BASE] = new_node();\n        }\n        p = p->childs[buffer[i] - BASE];\n    }\n    p->count++;\n    return ;\n}\n\nvoid build_automaton(TrieNode *node) {\n    TrieNode **queue = (TrieNode **)malloc(sizeof(TrieNode *) * (MAX_SIZE + 5));\n    int head = 0, tail = 0;\n    queue[tail++] = node;\n    while (head < tail) {\n        TrieNode *now = queue[head++];\n        for (int i = 0; i < SIZE; i++) {\n            if (now->childs[i] == NULL) {\n                if (now != node) now->childs[i] = now->fail->childs[i];\n                continue;\n            }\n            TrieNode *p = (now->fail ? now->fail->childs[i] : node);\n            if (p == NULL) p = node;\n            now->childs[i]->fail = p;\n            queue[tail++] = now->childs[i];\n        }\n    }\n    free(queue);\n    return ;\n}\n\nint match_count(TrieNode *ac_tree, const char *str) {\n    int ret = 0;\n    TrieNode *p = ac_tree, *q;\n    while (str[0]) {\n        p = p->childs[str[0] - \'a\'];\n        q = p;\n        while (q) ret += q->count, q = q->fail;\n        if (p == NULL) p = ac_tree;\n        str++;\n    }\n    return ret;\n}\nint main() {\n    Trie root = new_node();\n    int n;\n    scanf("%d", &n);\n    for (int i = 0; i < n; ++i) {\n        char pattern[MAX_LEN];\n        scanf("%s", pattern);\n        insert(root, pattern);\n    }\n    printf("insert done\\n");\n    fflush(stdout);\n    build_automaton(root);\n    scanf("%s", str_buffer);\n    printf("%d\\n", match_count(root, str_buffer));\n    //clear(root);\n    return 0;\n}\n')),(0,a.kt)("h2",{id:"\u53cc\u6570\u7ec4\u5b57\u5178\u6811-3"},"\u53cc\u6570\u7ec4\u5b57\u5178\u6811"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'/*************************************************************************\n   > File Name: 12.double_array_trie.cpp\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u4e09  8/21 14:14:38 2019\n ************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define BASE 26\n#define BEGIN_LETTER \'a\'\n\ntypedef struct Node {\n    int flag;\n    struct Node *next[BASE];\n} Node;\n\ntypedef struct DATrie {\n    int *base, *check;\n    int root, size;\n} DATrie;\n\nDATrie *getDATrie(int n) {\n    DATrie *tree = (DATrie *)calloc(sizeof(DATrie), 1);\n    tree->root = 1;\n    tree->size = n;\n    tree->base = (int *)calloc(sizeof(int), n);\n    tree->check = (int *)calloc(sizeof(int), n);\n    tree->check[tree->root] = 1;\n    return tree;\n}\n\nNode *getNewNode() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    return p;\n}\n\nint insert(Node *root, const char *str) {\n    int cnt = 0;\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (p->next[ind] == NULL) p->next[ind] = getNewNode(), cnt += 1;\n        p = p->next[ind];\n    }\n    p->flag = 1;\n    return cnt;\n}\n\nvoid clear(Node *root) {\n    if (root == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(root->next[i]);\n    }\n    free(root);\n    return ;\n}\n\nint getBaseValue(Node *root, DATrie *tree) {\n    int base = 0, flag;\n    do {\n        flag = 1;\n        base += 1;\n        for (int i = 0; i < BASE; i++) {\n            if (root->next[i] == NULL) continue;\n            if (tree->check[base + i] == 0) continue;\n            flag = 0;\n            break;\n        }\n    } while (!flag);\n    return base;\n}\n\nint buildDATrie(int ind, Node *root, DATrie *tree) {\n    int base = tree->base[ind] = getBaseValue(root, tree);\n    int ans = ind;\n    for (int i = 0; i < BASE; i++) {\n        if (root->next[i] == NULL) continue;\n        tree->check[base + i] = ind;\n    }\n    for (int i = 0; i < BASE; i++) {\n        if (root->next[i] == NULL) continue;\n        int temp = buildDATrie(base + i, root->next[i], tree);\n        if (temp > ans) ans = temp;\n    }\n    if (root->flag) tree->check[ind] = -tree->check[ind];\n    return ans;\n}\n\nint query(DATrie *tree, const char *str) {\n    int p = tree->root;\n    for (int i = 0; str[i]; i++) {\n        int ind = str[i] - BEGIN_LETTER;\n        if (abs(tree->check[tree->base[p] + ind]) != p) return 0;\n        p = tree->base[p] + ind;\n    }\n    return tree->check[p] < 0;\n}\n\nvoid clearDA(DATrie *tree) {\n    if (tree == NULL) return ;\n    free(tree->base);\n    free(tree->check);\n    free(tree);\n    return ;\n}\n\nint main() {\n    int n, cnt1 = 1, cnt2;\n    char str[100];\n    scanf("%d", &n);\n    Node *root = getNewNode();\n    while (n--) {\n        scanf("%s", str);\n        cnt1 += insert(root, str);\n    }\n    DATrie *tree = getDATrie(cnt1 * BASE + 5);\n    cnt2 = buildDATrie(tree->root, root, tree) + 1;\n    while (~scanf("%s", str)) {\n        printf("search %s, result = %s\\n", str, query(tree, str) ? "YES" : "NO");\n    }\n    int mem1 = cnt1 * sizeof(Node), mem2 = cnt2 * sizeof(int) * 2 + sizeof(int) * 2;\n    printf("Trie memory : %d Bytes\\n", mem1);\n    printf("Double Array Trie memory : %d Bytes\\n", mem2);\n    printf("memory rate : %.4lf%%\\n", 1.0 * mem2 / mem1 * 100);\n    clearDA(tree);\n    clear(root);\n    return 0;\n}\n')),(0,a.kt)("h2",{id:"\u5b57\u5178\u6811"},"\u5b57\u5178\u6811"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},' \n/*************************************************************************\n   > File Name: 11.trie.cpp\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u4e00  8/19 19:11:36 2019\n ************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define BASE 26\n#define BASE_LETTER \'a\'\n\ntypedef struct Node {\n    int flag;\n    struct Node *next[BASE];\n} Node;\n\nNode *getNewNode() {\n    Node *p = (Node *)calloc(sizeof(Node), 1);\n    return p;\n}\n\ninline int code(char ch) {\n    return ch - BASE_LETTER;\n}\n\nvoid insert(Node *root, char *str) {\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        if (p->next[code(str[i])] == NULL) p->next[code(str[i])] = getNewNode();\n        p = p->next[code(str[i])];\n    }\n    p->flag = 1;\n    return ;\n}\n\nint query(Node *root, char *str) {\n    Node *p = root;\n    for (int i = 0; str[i]; i++) {\n        p = p->next[code(str[i])];\n        if (p == NULL) return 0;\n    }\n    return p->flag;\n}\n\nvoid output(Node *root, int k, char *buff) {\n    if (root == NULL) return ;\n    if (root->flag) printf("%s\\n", buff);\n    for (int i = 0; i < BASE; i++) {\n        buff[k] = BASE_LETTER + i;\n        buff[k + 1] = \'\\0\';\n        output(root->next[i], k + 1, buff);\n    }\n    return ;\n}\n\nvoid clear(Node *root) {\n    if (root == NULL) return ;\n    for (int i = 0; i < BASE; i++) {\n        clear(root->next[i]);\n    }\n    free(root);\n    return ;\n}\n\nint main() {\n    char str[1000];\n    int n;\n    Node *root = getNewNode();\n    scanf("%d", &n);\n    for (int i = 0; i < n; i++) {\n        scanf("%s", str);\n        insert(root, str);\n    }\n    output(root, 0, str);\n    while (~scanf("%s", str)) {\n        printf("query %s, result = %s\\n", str, query(root, str) ? "Yes" : "No");\n    }\n    return 0;\n}\n')))}p.isMDXComponent=!0},9168:function(n,e,t){"use strict";e.Z=t.p+"assets/images/image-20201017104134948-0c87b2c8bc7f6d8939b9841251005089.png"},20383:function(n,e,t){"use strict";e.Z=t.p+"assets/images/image-20210126235307421-1623756908422-2176259e3577b5f1455264448e32cece.png"},35870:function(n,e,t){"use strict";e.Z=t.p+"assets/images/image-20210127193634993-0fe7ec113c3e15e7f17d855724e45688.png"},7447:function(n,e,t){"use strict";e.Z=t.p+"assets/images/image-20210127193826398-67e299a2b2bce03bb6e9c5c4fc69754b.png"},71453:function(n,e,t){"use strict";e.Z=t.p+"assets/images/image-20210217201415813-3188ca5f0d8817b304d57dd40e14c7fa.png"}}]);