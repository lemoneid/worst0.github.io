"use strict";(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[6816],{3905:function(n,e,t){t.d(e,{Zo:function(){return d},kt:function(){return m}});var i=t(67294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function r(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?r(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function c(n,e){if(null==n)return{};var t,i,a=function(n,e){if(null==n)return{};var t,i,a={},r=Object.keys(n);for(i=0;i<r.length;i++)t=r[i],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)t=r[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var p=i.createContext({}),l=function(n){var e=i.useContext(p),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},d=function(n){var e=l(n.components);return i.createElement(p.Provider,{value:e},n.children)},s={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},u=i.forwardRef((function(n,e){var t=n.components,a=n.mdxType,r=n.originalType,p=n.parentName,d=c(n,["components","mdxType","originalType","parentName"]),u=l(t),m=a,h=u["".concat(p,".").concat(m)]||u[m]||s[m]||r;return t?i.createElement(h,o(o({ref:e},d),{},{components:t})):i.createElement(h,o({ref:e},d))}));function m(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var r=t.length,o=new Array(r);o[0]=u;var c={};for(var p in e)hasOwnProperty.call(e,p)&&(c[p]=e[p]);c.originalType=n,c.mdxType="string"==typeof n?n:a,o[1]=c;for(var l=2;l<r;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}u.displayName="MDXCreateElement"},98722:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return c},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var i=t(87462),a=t(63366),r=(t(67294),t(3905)),o=["components"],c={id:"A99.\u5b9e\u73b0ADT",title:"A99.\u5b9e\u73b0ADT","typora-root-url":"../"},p="\u5b9e\u73b0ADT",l={unversionedId:"Algorithm/A99.\u5b9e\u73b0ADT",id:"Algorithm/A99.\u5b9e\u73b0ADT",isDocsHomePage:!1,title:"A99.\u5b9e\u73b0ADT",description:"\u4f7f\u7528\u4e24\u4e2a\u54c8\u5e0c\u8868\u548c\u4e00\u4e2a\u53cc\u5411\u94fe\u8868\u3002",source:"@site/docs/2.Algorithm/A99.\u5b9e\u73b0ADT.md",sourceDirName:"2.Algorithm",slug:"/Algorithm/A99.\u5b9e\u73b0ADT",permalink:"/Algorithm/A99.\u5b9e\u73b0ADT",editUrl:"https://github.com/worst0/wiki_note/edit/main/docs/2.Algorithm/A99.\u5b9e\u73b0ADT.md",version:"current",lastUpdatedAt:1633869865,formattedLastUpdatedAt:"10/10/2021",frontMatter:{id:"A99.\u5b9e\u73b0ADT",title:"A99.\u5b9e\u73b0ADT","typora-root-url":"../"},sidebar:"Document\ud83d\udcbb",previous:{title:"A15.\u4f4d\u56fe\u548c\u8df3\u8868",permalink:"/Algorithm/A15.\u4f4d\u56fe\u548c\u8df3\u8868"},next:{title:"B1.\u7b97\u6cd5\u5206\u6790",permalink:"/Algorithm/B1.\u7b97\u6cd5\u5206\u6790"}},d=[{value:"LFU",id:"lfu",children:[]},{value:"\u5927\u6574\u6570",id:"\u5927\u6574\u6570",children:[]},{value:"\u5927\u6d6e\u70b9\u6570",id:"\u5927\u6d6e\u70b9\u6570",children:[]}],s={toc:d};function u(n){var e=n.components,t=(0,a.Z)(n,o);return(0,r.kt)("wrapper",(0,i.Z)({},s,t,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"\u5b9e\u73b0adt"},"\u5b9e\u73b0ADT"),(0,r.kt)("h1",{id:"lru"},(0,r.kt)("a",{parentName:"h1",href:"https://leetcode-cn.com/problems/lru-cache/"},"LRU")),(0,r.kt)("p",null,"\u4f7f\u7528\u4e24\u4e2a\u54c8\u5e0c\u8868\u548c\u4e00\u4e2a\u53cc\u5411\u94fe\u8868\u3002"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u53cc\u5411\u94fe\u8868\u7528\u6765\u5b58\u50a8\u6570\u636e\uff0c\u4e3a\u4fdd\u6301\u6570\u636e\u7684\u4f18\u5148\u7ea7\uff0c\u8ba9\u53cc\u5411\u94fe\u8868\u7684\u5934\u90e8\u662f\u4f18\u5148\u7ea7\u6700\u9ad8\uff0c\u5c3e\u90e8\u4f18\u5148\u7ea7\u6700\u4f4e\u3002"),(0,r.kt)("li",{parentName:"ul"},"\u56e0\u4e3a\u4ece\u94fe\u8868\u4e2d\u67e5\u627e\u65f6\u95f4\u590d\u6742\u5ea6 ",(0,r.kt)("inlineCode",{parentName:"li"},"O(n)"),"\uff0c\u4e24\u4e2a",(0,r.kt)("inlineCode",{parentName:"li"},"hash"),"\u8868\u7528\u4e8e\u5feb\u901f\u5b9a\u4f4d\u8282\u70b9\u4f4d\u7f6e\u3002")),(0,r.kt)("h4",{id:"\u624b\u64b8\u94fe\u8868\u5b9e\u73b0"},"\u624b\u64b8\u94fe\u8868\u5b9e\u73b0"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class LRUCache {\npublic:\n    LRUCache(int capacity)\n    :capacity_(capacity) \n    { \n        assert(capacity >=0);\n    }\n\n    int get(int key) {\n        if(keyNodeMap_.find(key) == keyNodeMap_.end()) \n            return -1;\n\n        // \u53ea\u6709\u5728\u8d85\u8fc71\u4e2a\u8282\u70b9\u65f6\u624d\u9700\u8981\u79fb\u52a8\u5230\u5934\u90e8\uff0c\u518d\u8fd4\u56de\u503c\n        nodeLst_.moveToHead(keyNodeMap_[key]);\n        return keyNodeMap_[key]->val;\n    }\n    \n    void put(int key, int value) {\n        if(keyNodeMap_.find(key) != keyNodeMap_.end()) { \n            Node* node = keyNodeMap_[key];\n            node->val  = value;\n            nodeLst_.moveToHead(node);\n        }\n        // \u63d2\u5165\u4e00\u4e2a\u65b0\u7684\u8282\u70b9\n        else { \n            Node* node = new Node(value);\n            keyNodeMap_[key]  = node;\n            nodeKeyMap_[node] = key;\n            nodeLst_.insert(node);\n            if(keyNodeMap_.size() > capacity_) \n                removeMostUnusedNode();\n        }\n    }\n\nprivate:\n    void removeMostUnusedNode() { \n        // \u9700\u8981\u5148\u627e\u5230\u8282\u70b9\n        Node* node = nodeLst_.removeTail(); \n        int key = nodeKeyMap_[node];\n        keyNodeMap_.erase(key);\n        nodeKeyMap_.erase(node);\n        \n        delete node;\n    }\n\n    struct Node { \n        Node* prev;\n        Node* succ;\n        int val;\n\n        Node(int v, Node* prev=nullptr, Node* succ=nullptr)\n        : val(v), prev(prev), succ(succ) \n        { }\n    };\n\n    class DoubleList {\n    public:\n        DoubleList(Node* head=nullptr, Node* tail=nullptr)\n        : head(head), tail(tail) \n        { }\n\n        ~DoubleList() {\n            // \u4e00\u6b21\u6790\u6784\u6389\u6240\u6709\u8282\u70b9\n            while(head) { \n                Node* next = head->succ;\n                delete head;\n\n                head = next;\n            }\n        }\n\n        void insert(Node* node) { \n            if(node ==nullptr) return;\n            // \u82e5\u662f\u7a7a\u94fe\u8868\n            if(head ==nullptr) { \n                head = node; \n                tail = node; \n            }\n            else {\n                // \u63d2\u5165\u65b0\u7684\u8282\u70b9\uff0c\u603b\u662f\u653e\u5728\u9996\u90e8\n                node->succ = head;\n                head->prev = node;\n\n                head = node;\n            }\n        }\n\n        void moveToHead(Node* node) { \n            if(node ==nullptr || node == head) return; \n         \n            if(node == tail) { \n                tail = node->prev;\n                tail->succ = nullptr;\n            }\n            else { \n                node->prev->succ = node->succ;\n                node->succ->prev = node->prev;\n            }\n            // \u52a0\u5165\u5230\u9996\u8282\u70b9\n            insert(node);\n        }\n\n        Node* removeTail() { \n            if(tail ==nullptr) return tail;\n\n            Node* ret = tail;\n            if(head ==tail) { \n                head = nullptr;\n                tail = nullptr;\n            }\n            else { \n                tail = tail->prev;\n                tail->succ = nullptr;\n            }\n\n            return ret;\n        }\n\n    private:\n        // \u8fd9\u4e24\u4e2a\u662f\u54e8\u5175\uff0c\u6307\u5411\u94fe\u8868\u7684\u5934\u90e8\u548c\u5c3e\u90e8\u8282\u70b9\n        Node* head;\n        Node* tail;\n    };\n\nprivate:\n    std::unordered_map<int, Node*> keyNodeMap_;\n    std::unordered_map<Node*, int> nodeKeyMap_;\n    DoubleList nodeLst_;\n\n    size_t capacity_;\n};\n")),(0,r.kt)("h4",{id:"\u4f7f\u7528stl\u5e93\u5b9e\u73b0"},"\u4f7f\u7528",(0,r.kt)("inlineCode",{parentName:"h4"},"STL"),"\u5e93\u5b9e\u73b0"),(0,r.kt)("p",null,"\u53ef\u4ee5\u66f4\u52a0\u7b80\u7ec3\uff0c\u4f7f\u7528\u4e00\u4e2a\u94fe\u8868\u5c31\u80fd\u5b8c\u6210LRU\u8bbe\u8ba1"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class LRUCache {\npublic:\n    LRUCache(int capacity)\n    : capacity_(capacity) \n    { }\n    \n    int get(int key) {\n      const auto& iter = keyNodeMap_.find(key);\n\n      if(iter == keyNodeMap_.end()) { \n        return -1;\n      }\n      \n      Node node = *(iter->second);\n      list_.erase(iter->second);\n      list_.push_front(node);\n      keyNodeMap_[key] = list_.begin();\n      return node.value;\n    }\n    \n    void put(int key, int value) {\n      const auto& iter = keyNodeMap_.find(key);\n\n      if(list_.size() == capacity_ && iter == keyNodeMap_.end()) { \n        const Node& tail = list_.back();\n        keyNodeMap_.erase(tail.key);\n        list_.pop_back();\n      }      \n    \n      if(iter != keyNodeMap_.end()) {  \n        list_.erase(iter->second);\n        keyNodeMap_.erase(iter);\n      }\n     \n      list_.emplace_front(Node(key, value));\n      keyNodeMap_[key] = list_.begin();\n    }\nprivate:\n    struct Node { \n      int key;\n      int value;\n\n      Node(int k, int v) : key(k),value(v) { }\n    };\n\n    std::list<Node> list_; // \u524d\u7aef\u4f18\u5148\u7ea7\u9ad8\uff0c\u5373\u6700\u5e38\u4f7f\u7528\u3002\u4ece\u540e\u7aef\u5220\u9664\n    std::unordered_map<int, std::list<Node>::iterator> keyNodeMap_;\n    int capacity_;\n};\n\n")),(0,r.kt)("h2",{id:"lfu"},"LFU"),(0,r.kt)("h4",{id:"46-lru\u7f13\u5b58\u673a\u5236httpsleetcode-cncomproblemslru-cache"},"46. LRU\u7f13\u5b58\u673a\u5236](",(0,r.kt)("a",{parentName:"h4",href:"https://leetcode-cn.com/problems/lru-cache"},"https://leetcode-cn.com/problems/lru-cache"),")"),(0,r.kt)("p",null," ",(0,r.kt)("a",{parentName:"p",href:"https://baike.baidu.com/item/LRU"},"LRU (\u6700\u8fd1\u6700\u5c11\u4f7f\u7528) \u7f13\u5b58\u673a\u5236")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"\u54c8\u5e0c\u8868 + \u94fe\u8868\u89e3\u51b3"),(0,r.kt)("li",{parentName:"ol"},"\u5f2f\u8def1:\u4e00\u4e00\u5f00\u59cb\u60f3\u5230\u4e86\u54c8\u5e0c\u8868,\u4f46\u5ffd\u7565\u4e86\u5229\u7528\u94fe\u8868\u5b9e\u73b0"),(0,r.kt)("li",{parentName:"ol"},"\u5f2f\u8def2:\u7531\u4e8e\u5934\u5c3e\u6307\u9488\u4f1a\u53d1\u751f\u751f\u53d8\u5316,\u5ffd\u7565\u4e86\u865a\u62df\u8282\u70b9\u7684\u5904\u7406\u6280\u5de7")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"class LRUCache {\npublic:\n    struct Node {\n        Node() : Node(0, 0) {}\n        Node(int key, int value) : pre(nullptr), next(nullptr), key(key), value(value) {}\n        int key, value;\n        Node *pre, *next;\n    };\n\n    unordered_map<int, Node *>ind;\n    Node head, tail;\n    int capacity, node_cnt;\n\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n        this->node_cnt = 0;\n        head.next = &tail;\n        tail.pre = &head;\n        return ;\n    }\n\n    void remove_node(Node *p) {\n        p->next->pre = p->pre;\n        p->pre->next = p->next; \n        return ;\n    }\n    void insert_tail(Node *p) {\n        p->next = &tail;\n        p->pre = tail.pre;\n        tail.pre->next = p;\n        tail.pre = p;\n        return ;\n    }\n    \n    int get(int key) {\n        if (ind.find(key) == ind.end()) return -1;\n        Node *p = ind[key];\n        remove_node(p);\n        insert_tail(p);\n        return p->value;\n    }\n    \n    void put(int key, int value) {\n        Node *p = nullptr;\n        if (ind.find(key) == ind.end()) {\n            p = new Node(key, value);\n            insert_tail(p);\n            ind[key] = p;\n            node_cnt++;\n        } else {\n            p = ind[key];\n            remove_node(p);\n            p->value = value;\n            insert_tail(p);\n        }\n        if (node_cnt > capacity) {\n            p = head.next;\n            remove_node(p);\n            ind.erase(p->key); //\u52ff\u5fd8\u53d6\u6d88\u6807\u8bb0\n            node_cnt--;\n            delete p;\n        }\n        return ;\n    }\n};\n")),(0,r.kt)("h4",{id:"leetcode-460-lfu\u7f13\u5b58"},"Leetcode-460-LFU\u7f13\u5b58"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u7f16\u7801\u8f83\u590d\u6742,\u57fa\u4e8e\u5341\u5b57\u94fe\u8868\u5b9e\u73b0 LFU \u7f13\u5b58\u673a\u5236")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u5c06\u51fa\u73b0\u6b21\u6570\u76f8\u540c\u7684\u8282\u70b9,\u5b58\u50a8\u5728\u540c\u4e00\u4e00\u4e2a \u53cc\u5411\u94fe\u8868 \u4e2d")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u5220\u9664\u8282\u70b9\u7684\u64cd\u4f5c,\u7b80\u5316\u6210\u4e86\u4e86:\u5220\u9664\u7b2c\u4e00\u4e00\u4e2a LRUCache \u4e2d\u7684\u5c3e\u7ed3\u70b9")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u64cd\u4f5c1:\u5220\u9664\u4e00\u4e00\u8282\u70b9")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u64cd\u4f5c2:\u65b0\u589e\u4e00\u4e2a\u8282\u70b9")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u64cd\u4f5c3:\u5c06\u4e00\u4e2a\u73b0\u6709\u8282\u70b9,\u79fb\u52a8\u5230\u4e0b\u4e00\u4e2a LRUCache \u4e2d"),(0,r.kt)("p",{parentName:"li"},"Map<Integer, Node> cache; // \u5b58\u50a8\u7f13\u5b58\u7684\u5185\u5bb9\nMap<Integer, DoublyLinkedList> freqMap; // \u5b58\u50a8\u6bcf\u4e2a\u9891\u6b21\u5bf9\u5e94\u7684\u53cc\u5411\u94fe\u8868\nint size;\nint capacity;\nint min; // \u5b58\u50a8\u5f53\u524d\u6700\u5c0f\u9891\u6b21"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/*\n * @lc app=leetcode.cn id=460 lang=cpp\n *\n * [460] LFU \u7f13\u5b58\n */\n\n// @lc code=start\nclass LFUCache {\npublic:\n    struct Node {\n        Node() : Node(0, 0, 0) {}\n        Node(int key, int val, int times) : \n            key(key), val(val), times(times), \n            pre(nullptr), next(nullptr) {}\n        int key, val, times;\n        Node *pre, *next;\n    };\n\n    struct ListNode {\n        ListNode() {\n            head.next = &tail;\n            tail.pre = &head;\n        }\n\n        void insert_tail(Node *p) {\n            p->next = &tail;\n            p->pre = tail.pre;\n            tail.pre->next = p;\n            tail.pre = p;\n        }\n\n        void remove_node(Node *p) {\n            p->next->pre = p->pre;\n            p->pre->next = p->next;\n        }\n        Node head, tail;\n    };\n    \n\n    LFUCache(int capacity) {\n        this->min_count = 0;\n        this->cnt = 0;\n        this->capacity = capacity;\n    }\n\n    void updata() {\n        while (ind.find(min_count) != ind.end() && ind[min_count]->head.next == &(ind[min_count]->tail)) {\n            min_count++;\n        }\n        if (ind.find(min_count) == ind.end()) {\n            min_count = 0;\n        }\n    }\n\n    void increase(Node *p) {\n        ListNode *list = ind[p->times];\n        list->remove_node(p);\n        p->times++;\n        if (ind.find(p->times) == ind.end()) {\n            ind[p->times] = new ListNode();\n        }\n        list = ind[p->times];\n        list->insert_tail(p);\n        updata();\n    }\n    \n    int get(int key) {\n        if (cache.find(key) == cache.end()) return -1;\n        Node *p = cache[key];\n        increase(p);\n        return p->val;\n    }\n    \n    void put(int key, int value) {\n        if (capacity == 0) return ;\n        if (cache.find(key) == cache.end()) {\n            if (cnt == capacity) {\n                ListNode *list = ind[min_count];\n                Node *p = list->head.next;\n                list->remove_node(p);\n                cache.erase(p->key);\n                delete p;\n                cnt--;\n                updata();\n            }\n            Node *p = new Node(key, value, 1);\n            cache[key] = p;\n            if (ind.find(1) == ind.end()) {\n                ind[1] = new ListNode();\n            }\n            ListNode *list = ind[1];\n            list->insert_tail(p);\n            cnt++;\n            min_count = 1;\n        } else {\n            Node *p = cache[key];\n            p->val = value;\n            increase(p);\n        }\n    }\nprivate :\n    unordered_map<int, Node *> cache;\n    unordered_map<int, ListNode *> ind;\n    int min_count, cnt, capacity;\n};\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n// @lc code=end\n\n")),(0,r.kt)("h2",{id:"\u5927\u6574\u6570"},"\u5927\u6574\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nauto in_range = [](int b, int e) {\n    return [=](int x) {\n        return (x <= e && x >= b);\n    };\n};\n\nauto is_digit = in_range('0', '9');\nauto is_upper = in_range('A', 'Z');\nauto is_lower = in_range('a', 'z');\n\nclass BigInt {\npublic :\n    BigInt(int base, int x) {\n        this->base = base;\n        this->data.push_back(x);\n        this->proccess_digit();\n    }\n    BigInt() : BigInt(10, 0) {}\n    BigInt(int base, const string &num_str) {\n        this->base = base;\n        for (int i = num_str.size() - 1; i >= 0; --i) {\n            this->data.push_back(BigInt::decode(num_str[i]));\n        }\n    }\n\n    BigInt &operator*=(int x) {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < vec.size(); i++) {\n            vec[i] *= x;\n        }\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator+=(int x) {\n        vector<int> &vec = this->data;\n        vec[0] += x;\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator+=(const BigInt &x) {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < x.data.size(); i++) {\n            if (i + 1 >= vec.size()) vec.push_back(x.data[i]);\n            vec[i] += x.data[i];\n        }\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator/=(int x) {\n        vector<int> &vec = this->data;\n        int i = vec.size() - 1, temp = 0;\n        while (i >= 0 && temp * base + vec[i] < x) {\n            temp = temp * base + vec[i];\n            vec.erase(vec.begin() + (i--));\n        }\n        if (i == -1) { \n            vec.push_back(0); \n            return *this;\n        }\n        while (i >= 0) {\n            temp = temp * base + vec[i];\n            vec[i--] = temp / x;\n            temp %= x;\n        }\n        return *this;\n    }\n    int operator%(int x) {\n        vector<int> &vec = this->data;\n        int temp = 0;\n        for (int i = vec.size() - 1; i >= 0; i--) {\n            temp = temp * base + vec[i];\n            temp %= x;\n        }\n        return temp;\n    }\n    BigInt &convert_to(int to_base) {\n        if (to_base == this->base) return *this;\n        vector<int> result;\n        BigInt &num = *this;\n        do {\n            result.push_back(num % to_base);\n            num /= to_base;\n        } while (num != 0);\n        num.data[0] = result[0];\n        for (int i = 1; i < result.size(); i++) {\n            num.data.push_back(result[i]);\n        }\n        return num;\n    }\n    bool operator!=(int x){\n        return !(this->operator==(x));\n    }\n    bool operator!=(const BigInt &x){\n        return !(this->operator==(x));\n    }\n    bool operator==(int x) {\n        BigInt a(this->base, x);\n        return ((*this) == a);\n    }\n    bool operator==(const BigInt &a) {\n        int now_base = this->base;\n        if (a.base - this->base) this->convert_to(a.base);\n        int flag = 1;\n        if (a.data.size() - this->data.size()) flag = 0;\n        for (int i = 0; i < a.data.size() && flag; i++) {\n            if (a.data[i] - this->data[i]) flag = 0;\n        }\n        this->convert_to(now_base);\n        return flag;\n    }\n\nprivate:\n    vector<int> data;\n    int base;\n    void proccess_digit() {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < vec.size(); i++) {\n            if (vec[i] < base) continue;\n            if (i + 1 == vec.size()) vec.push_back(vec[i] / base);\n            else vec[i + 1] += vec[i] / base;\n            vec[i] %= base;\n        }\n        return ;\n    }\n    static int decode(char ch) {\n        if (is_digit(ch)) return ch - '0';\n        if (is_upper(ch)) return ch - 'A' + 10;\n        return ch - 'a' + 36;\n    }\n    static char encode(int x) {\n        if (x < 10) return x + '0';\n        if (x < 36) return x - 10 + 'A';\n        return x - 36 + 'a';\n    }\n    \nfriend ostream &operator<<(ostream &, const BigInt &);\n};\n\nostream &operator<<(ostream &out, const BigInt &a) {\n    for (int i = a.data.size() - 1; i >= 0; i--) {\n        out << BigInt::encode(a.data[i]);\n    }\n    return out;\n}\n\nint main() {\n    int base_a, base_b;\n    string str;\n    cin >> base_a >> base_b >> str;\n    BigInt num(base_a, str);\n    cout << base_a << \" \" << num << endl;\n    num.convert_to(base_b);\n    cout << base_b << \" \" << num << endl;\n    return 0;\n}\n")),(0,r.kt)("h4",{id:"hzoj-41-2"},"HZOJ-41-2"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/*************************************************************************\n    > File Name: 41-2.cpp\n    > Author: \n    > Mail: \n    > Created Time: \u65e5  4/26 20:51:48 2020\n ************************************************************************/\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <vector>\nusing namespace std;\n#define MAX_N 1000\n\nstruct BigInt: public vector<int> {\n    BigInt(int x = 0) {\n        push_back(x);\n        normal();\n    }    \n    \n    BigInt operator*(int x) {\n        BigInt ret(*this);\n        for (int i = 0; i < ret.size(); i++) ret[i] *= x;\n        ret.normal();\n        return ret;\n    }\n\n    BigInt operator+(const BigInt &a) {\n        BigInt ret(*this);\n        for (int i = 0; i < a.size(); i++) {\n            if (i < ret.size()) ret[i] += a[i];\n            else ret.push_back(a[i]);\n        }\n        ret.normal();\n        return ret;\n    }\n\n    void normal() {\n        for (int i = 0; i < size(); i++) {\n            if (at(i) < 10) continue;\n            if (i + 1 == size()) push_back(0);\n            at(i + 1) += at(i) / 10;\n            at(i) %= 10;\n        }\n        return ;\n    }\n};\n\nBigInt f[MAX_N + 5];\n\nostream &operator<<(ostream &out, const BigInt &a) {\n    for (int i = a.size() - 1; i >= 0; --i) {\n        out << a[i];\n    }\n    return out;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    f[1] = k;\n    f[2] = (k - 1) * k;\n    f[3] = k * (k - 1) * (k - 2);\n    for (int i = 4; i <= n; i++) {\n        f[i] = f[i - 1] * (k - 2) + f[i - 2] * (k - 1);\n    }\n    cout << f[n] << endl;\n    return 0;\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"struct BigInt : vector<int>{\n    BigInt(int x) {\n        push_back(x);\n        normal();\n    }\n    BigInt operator+(const BigInt &b) {\n        BigInt ret = (*this);\n        for (int i = 0; i < b.size(); i++) {\n            if (i < ret.size()) {\n                ret[i] += b[i];\n            } else {\n                ret.push_back(b[i]);\n            }\n        }\n        ret.normal();\n        return ret;\n    } \n    void normal() {\n        for (int i = 0; i < size(); i++) {\n            if (at(i) < 10) continue;\n            if (i + 1 == size()) push_back(0);\n            at(i + 1) += at(i) / 10;\n            at(i) %= 10;\n        }\n        return ;\n    }\n};\n\nostream &operator<<(ostream &out, const BigInt &a) {\n    for (int i = a.size() - 1; i >= 0; i--) {\n        out << a[i];\n    }\n    return out;\n}\n\nint main() {\n    int n;\n    BigInt a = 1, b = 1, c = 0;\n    cin >> n;\n    while (n--) {\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    cout << a << endl;\n    return 0;\n}\n")),(0,r.kt)("h2",{id:"\u5927\u6d6e\u70b9\u6570"},"\u5927\u6d6e\u70b9\u6570"),(0,r.kt)("h4",{id:"hzoj-474-\u56db\u7ea7\u8003\u8bd5"},"HZOJ-474. \u56db\u7ea7\u8003\u8bd5"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <deque>\nusing namespace std;\n\nstruct BigFloat {\n    BigFloat(int x) {\n        lpart.push_back(x);\n        process_digit();\n    }\n    void trim() {\n        while (lpart.size() > 1 && lpart[0] == 0) lpart.pop_front();\n        while (rpart.size() && rpart[rpart.size() - 1] == 0) rpart.pop_back();\n        return;\n    }\n    void operator>>=(int x) {\n        while (x--) {\n            if (lpart.size()) {\n                rpart.push_front(lpart.back());\n                lpart.pop_back();\n            } else {\n                rpart.push_front(0);\n            }\n        }\n        if (!lpart.size()) lpart.push_back(0);\n        trim();\n    }\n    void process_digit() {\n        for (int i = rpart.size() - 1; i >= 0; i--) {\n            if (rpart[i] < 10) continue;\n            if (i == 0) lpart[lpart.size() - 1] += rpart[i] / 10;\n            else rpart[i - 1] += rpart[i] / 10;\n            rpart[i] %= 10;\n        }\n        for (int i = lpart.size() - 1; i >= 0; i--) {\n            if (lpart[i] < 10) continue;\n            if (i == 0) lpart.push_front(0), i++;\n            lpart[i - 1] += lpart[i] / 10;\n            lpart[i] %= 10;\n        }\n        trim();\n    }\n\n    void operator*=(int x) {\n        for (int i = rpart.size() - 1; i >= 0; i--) {\n            rpart[i] *= x;\n        }\n        for (int i = lpart.size() - 1; i >= 0; i--) {\n            lpart[i] *= x;\n        }\n        process_digit();\n    }\n\n    deque<int> lpart, rpart;\n};\n\nostream &operator<<(ostream &out, const BigFloat &obj) {\n    for (int i = 0; i < obj.lpart.size(); i++) {\n        out << obj.lpart[i];\n    }\n    if (!obj.rpart.size()) return out;\n    out << \".\";\n    for (int i = 0; i < obj.rpart.size(); i++) {\n        out << obj.rpart[i];\n    }\n    return out;\n}\n\nint main() {\n    int n, p[4];\n    string str;\n    cin >> n >> str;\n    BigFloat ans = 1;\n    for (int i = 0; i < n; i++) {\n        char ch;\n        for (int j = 0; j < 4; j++) {\n            cin >> p[j] >> ch;\n        }\n        ans *= p[str[i] - 'A'];\n        ans >>= 2;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n")))}u.isMDXComponent=!0}}]);