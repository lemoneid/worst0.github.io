(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[7549],{3905:function(n,t,e){"use strict";e.d(t,{Zo:function(){return u},kt:function(){return m}});var i=e(67294);function a(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function s(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){a(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function o(n,t){if(null==n)return{};var e,i,a=function(n,t){if(null==n)return{};var e,i,a={},r=Object.keys(n);for(i=0;i<r.length;i++)e=r[i],t.indexOf(e)>=0||(a[e]=n[e]);return a}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)e=r[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(a[e]=n[e])}return a}var c=i.createContext({}),l=function(n){var t=i.useContext(c),e=t;return n&&(e="function"==typeof n?n(t):s(s({},t),n)),e},u=function(n){var t=l(n.components);return i.createElement(c.Provider,{value:t},n.children)},d={inlineCode:"code",wrapper:function(n){var t=n.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(n,t){var e=n.components,a=n.mdxType,r=n.originalType,c=n.parentName,u=o(n,["components","mdxType","originalType","parentName"]),p=l(e),m=a,h=p["".concat(c,".").concat(m)]||p[m]||d[m]||r;return e?i.createElement(h,s(s({ref:t},u),{},{components:e})):i.createElement(h,s({ref:t},u))}));function m(n,t){var e=arguments,a=t&&t.mdxType;if("string"==typeof n||a){var r=e.length,s=new Array(r);s[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=n,o.mdxType="string"==typeof n?n:a,s[1]=o;for(var l=2;l<r;l++)s[l]=e[l];return i.createElement.apply(null,s)}return i.createElement.apply(null,e)}p.displayName="MDXCreateElement"},81915:function(n,t,e){"use strict";e.r(t),e.d(t,{frontMatter:function(){return o},metadata:function(){return c},toc:function(){return l},default:function(){return d}});var i=e(22122),a=e(19756),r=(e(67294),e(3905)),s=["components"],o={id:"B4.C++-others",title:"B4.C++-others","typora-root-url":"../"},c={unversionedId:"Programming_Language/B4.C++-others",id:"Programming_Language/B4.C++-others",isDocsHomePage:!1,title:"C++ othres",description:"remove_reference",source:"@site/docs/4.Programming_Language/B4.C++-others.md",sourceDirName:"4.Programming_Language",slug:"/Programming_Language/B4.C++-others",permalink:"/Programming_Language/B4.C++-others",editUrl:"https://github.com/worst0/wiki_note/edit/main/docs/4.Programming_Language/B4.C++-others.md",version:"current",lastUpdatedAt:1624240624,formattedLastUpdatedAt:"6/21/2021",frontMatter:{id:"B4.C++-others",title:"B4.C++-others","typora-root-url":"../"},sidebar:"Document\ud83d\udcbb",previous:{title:"C++-exercise",permalink:"/Programming_Language/B3.C++-exercise"},next:{title:"C++\u7f16\u8bd1",permalink:"/Programming_Language/B5.C++\u7f16\u8bd1"}},l=[{value:"C++\u591a\u7ebf\u7a0b",id:"c\u591a\u7ebf\u7a0b",children:[{value:"\u6761\u4ef6\u53d8\u91cf\u548c\u4e92\u65a5\u9501",id:"\u6761\u4ef6\u53d8\u91cf\u548c\u4e92\u65a5\u9501",children:[]},{value:"\u7ebf\u7a0b\u5b89\u5168",id:"\u7ebf\u7a0b\u5b89\u5168",children:[]},{value:"\u7ebf\u7a0b\u6c60",id:"\u7ebf\u7a0b\u6c60",children:[]}]},{value:"thread+strong",id:"threadstrong",children:[{value:"Logger\u65e5\u5fd7\u8f93\u51fa\u7c7b",id:"logger\u65e5\u5fd7\u8f93\u51fa\u7c7b",children:[]},{value:"thread_pool",id:"thread_pool",children:[]}]},{value:"handle\u8d23\u4efb\u94fe\u6a21\u5f0f",id:"handle\u8d23\u4efb\u94fe\u6a21\u5f0f",children:[]},{value:"factory\u62bd\u8c61\u5de5\u5382\u6a21\u5f0f",id:"factory\u62bd\u8c61\u5de5\u5382\u6a21\u5f0f",children:[]},{value:"singleton\u5355\u4f8b\u6a21\u5f0f",id:"singleton\u5355\u4f8b\u6a21\u5f0f",children:[]},{value:"visitor\u8bbf\u95ee\u8005\u6a21\u5f0f",id:"visitor\u8bbf\u95ee\u8005\u6a21\u5f0f",children:[{value:"\u8bbf\u95ee\u8005\u6a21\u5f0f",id:"\u8bbf\u95ee\u8005\u6a21\u5f0f",children:[]}]},{value:"\u8bbe\u8ba1\u6a21\u5f0f",id:"\u8bbe\u8ba1\u6a21\u5f0f",children:[]},{value:"\u503c\u7684\u7c7b\u578b\u548c\u79fb\u52a8\u6784\u9020",id:"\u503c\u7684\u7c7b\u578b\u548c\u79fb\u52a8\u6784\u9020",children:[]},{value:"lambda",id:"lambda",children:[]},{value:"1 const \u5e38\u91cf\u7684\u5224\u522b\u51c6\u5219",id:"1-const-\u5e38\u91cf\u7684\u5224\u522b\u51c6\u5219",children:[]},{value:"constexpr",id:"constexpr",children:[]},{value:"nullptr",id:"nullptr",children:[]},{value:"auto\u548c\u968f\u673a\u79cd\u5b50\u539f\u7406",id:"auto\u548c\u968f\u673a\u79cd\u5b50\u539f\u7406",children:[]},{value:"hash_table",id:"hash_table",children:[]},{value:"\u4e8c\u53c9\u6392\u5e8f\u6811",id:"\u4e8c\u53c9\u6392\u5e8f\u6811",children:[]},{value:"bind",id:"bind",children:[]},{value:"\u6a21\u677f\u7684\u56fe\u7075\u5b8c\u5907\u6027",id:"\u6a21\u677f\u7684\u56fe\u7075\u5b8c\u5907\u6027",children:[]},{value:"\u5f15\u7528\u6298\u53e0",id:"\u5f15\u7528\u6298\u53e0",children:[]},{value:"\u53f3\u503c",id:"\u53f3\u503c",children:[]},{value:"\u53ef\u53d8\u53c2\u6570\u6a21\u677f",id:"\u53ef\u53d8\u53c2\u6570\u6a21\u677f",children:[]},{value:"\u53ef\u53d8\u53c21",id:"\u53ef\u53d8\u53c21",children:[]},{value:"\u6a21\u677fArray",id:"\u6a21\u677farray",children:[]},{value:"\u54c8\u5e0c\u51fd\u6570",id:"\u54c8\u5e0c\u51fd\u6570",children:[]},{value:"Array\u7ec3\u4e60",id:"array\u7ec3\u4e60",children:[]},{value:"\u865a\u51fd\u6570\u8868",id:"\u865a\u51fd\u6570\u8868",children:[]},{value:"\u865a\u51fd\u6570",id:"\u865a\u51fd\u6570",children:[]},{value:"cout\u7b80\u7248\u5b9e\u73b0",id:"cout\u7b80\u7248\u5b9e\u73b0",children:[]},{value:"\u7ee7\u627f",id:"\u7ee7\u627f",children:[]},{value:"\u6790\u6784",id:"\u6790\u6784",children:[]},{value:"\u8fdb\u5236\u8f6c\u6362",id:"\u8fdb\u5236\u8f6c\u6362",children:[]},{value:"\u5927\u6d6e\u70b9\u6570",id:"\u5927\u6d6e\u70b9\u6570",children:[]},{value:"\u5927\u6574\u6570",id:"\u5927\u6574\u6570",children:[]}],u={toc:l};function d(n){var t=n.components,o=(0,a.Z)(n,s);return(0,r.kt)("wrapper",(0,i.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"remove_reference"),(0,r.kt)("p",null,"remove_pointer"),(0,r.kt)("p",null,"\u539f\u5730\u6784\u9020\u7684\u4f7f\u7528"),(0,r.kt)("p",null,"\u5b9e\u73b0\u4e00\u4e2apush_back"),(0,r.kt)("p",null,"move\uff0cforward\u672c\u8d28\u662f\u4e3a\u4e86\u91cd\u8f7d\u8c03\u7528\u6b63\u786e\u7248\u672c"),(0,r.kt)("p",null,"const Type &\u5e2e\u4e00\u5207\uff1aostream\u4e2d"),(0,r.kt)("p",null,"auto"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"c11\u4e0d\u53ef\u505a\u51fd\u6570\u53c2\u6570\uff1a\u65e0\u6cd5\u786e\u5b9a\u51fd\u6570\u7248\u672c")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"c11\u4e0d\u53ef\u505a\u6a21\u677f\u53c2\u6570")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u4e0d\u80fd\u5b9a\u4e49\u6570\u7ec4")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u4e0d\u80fd\u7528\u4e8e\u975e\u9759\u6001\u6210\u5458\u53d8\u91cf"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},'class CMP {\npublic :\n    CMP(int z = 0) : z(z) {} // z = 0 less,  z = 1 greater\n    bool operator()(int a, int b) {\n        return (a < b) ^ !!(z);\n    }\n    int z;\n};\n\nvoid sort(int *arr, int l, int r, function<bool(int, int)> cmp = CMP()) {\n    if (l >= r) return ;\n    int x = l, y = r, z = arr[(l + r) >> 1];\n    do {\n        while (cmp(arr[x], z)) ++x;\n        while (cmp(z, arr[y])) --y;\n        if (x <= y) {\n            swap(arr[x], arr[y]);\n            ++x, --y;\n       }\n    } while (x <= y);\n    sort(arr, l, y, cmp);\n    sort(arr, x, r, cmp);\n    return ;\n}\n\n} // end of haizei\n\nint main() {\n    vector<int> arr;\n    int n;\n    cin >> n;\n    while (n--) { int a; cin >> a, arr.push_back(a); }\n    sort(arr.begin(), arr.end(), haizei::CMP(1));\n    cout << arr << endl;\n    int arr2[5] = {6, 8, 4, 5, 1};\n    \n    haizei::sort(arr2, 0, 4);\n    for (int i = 0; i < 5; i++) {\n        cout << arr2[i] << " ";\n    }\n    cout << endl;\n\n    haizei::sort(arr2, 0, 4, cmp1);\n}\n')),(0,r.kt)("p",null,"\u4eff\u51fd\u6570\u5bf9\u8c61\uff1aA()\u7c7b\u7684\u533f\u540d\u5bf9\u8c61\uff08\u6784\u9020\uff09"),(0,r.kt)("p",null,"\u7c7b\u5185\u91cd\u8f7d\u4f18\u5148\u7ea7\u9ad8\u4e8e\u7c7b\u5916\u91cd\u8f7d\u4f18\u5148\u7ea7"),(0,r.kt)("p",null,"friend\u53cb\u5143\u51fd\u6570\u58f0\u660e\u5728\u5185\u90e8\uff1a\u4e3b\u8981\u662f\u4e3a\u4e86\u4fdd\u8bc1\u5f00\u53d1\u8005\u5141\u8bb8\u8be5\u51fd\u6570\u8bbf\u95ee"),(0,r.kt)("p",null,"\u539f\u5730\u6784\u9020\uff1a\u5b9e\u73b0\u6df1\u62f7\u8d1d"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210329132620508",src:e(88415).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210329130326086",src:e(57766).Z})),(0,r.kt)("p",null,"\u7f16\u8bd1\u5668\uff1a\u63d0\u4f9b\u9ed8\u8ba4\u6784\u9020\uff0c\u9ed8\u8ba4\u62f7\u8d1d\uff0c\u4e00\u65e6\u63d0\u4f9b\u6709\u53c2\u6784\u9020\uff0c\u9ed8\u8ba4\u7684\u5c31\u4e0d\u4f1a\u751f\u6210"),(0,r.kt)("p",null,"\u9ed8\u8ba4\u6784\u9020\u51fd\u6570\uff1a\u7531\u7cfb\u7edf\u751f\u6210\uff0c\u65e0\u53c2\u6784\u9020"),(0,r.kt)("p",null,"\u8f6c\u6362\u6784\u9020\uff1a\u4e00\u4e2a\u53c2\u6570\u7684\u6784\u9020\u51fd\u6570"),(0,r.kt)("p",null,"\u62f7\u8d1d\u6784\u9020\uff1a\u4e0e\u8d4b\u503c\u8fd0\u7b97\u7b26\u5b8c\u5168\u4e0d\u4e00\u6837\uff0cconst \uff1a\u517c\u5bb9const\u5bf9\u8c61\uff0c&\u907f\u514d\u503c\u65e0\u9650\u9012\u5f52"),(0,r.kt)("p",null,"\u5217\u8868\u521d\u59cb\u5316\uff1a\u6309\u7740\u7c7b\u58f0\u660e\u987a\u5e8f\u6784\u9020\u800c\u975e\u5217\u8868\u987a\u5e8f\uff0c\u6784\u9020\u548c\u8d4b\u503c\uff08\u5148\u6784\u9020\u5728\u8d4b\u503c\uff09\u4e0d\u4e00\u6837"),(0,r.kt)("p",null,"\u79fb\u52a8\u6784\u9020\uff1a\u5927\u91cf\u7684\u6df1\u62f7\u8d1d"),(0,r.kt)("p",null,"\u6790\u6784\u51fd\u6570\uff1a\u521b\u5efa\u5bf9\u8c61\u524d\uff0cc++\u4f1a\u68c0\u6d4b\u662f\u5426\u53ef\u4ee5\u6790\u6784"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"C++ \u6240\u63a8\u5d07\u7684RAII\u7684\u601d\u60f3\u3002\u867d\u7136\u901a\u5e38\u8bb2\u8d77\u6765\u90fd\u5f88\u2fbc\u6df1\uff0c\u5b9e\u9645\u4e0a\u7684\u610f\u601d\u5c31\u53ea\u6709\u2f00\u4e2a\uff1a\u5982\u679c\u2f00\u4e2a\u5bf9\u8c61\u7684\u6784\u9020\u51fd\u6570\u6210\u529f\u6267\u2f8f\u4e86\uff0c\u90a3\u4e48\u4ee5\u540e\u4e0d\u7ba1\u53d1\u2f63\u4ec0\u4e48\u4e8b\u60c5\uff0c\u53ea\u8981\u8fd9\u4e0d\u662f\u2f00\u4e2a undefined behavior\uff0c\u90a3\u4e48\u6790\u6784\u51fd\u6570\u2f00\u5b9a\u4f1a\u88ab\u6267\u2f8f\u3002\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"assert \u662f\u2f64\u6765\u5224\u65ad\u7a0b\u5e8f\u5458\u2f83\u2f30\u7684\u9519\u8bef\uff0c\u8b6c\u5982\u8bf4\u4f20\u8fdb\u4e86\u2f00\u4e2a\u7a7a\u6307\u9488\u5566\uff0c\u6216\u8005\u7ecf\u8fc7\u5c42\u5c42\u7684\u68c0\u6d4b\u8fd8\u662f\u628a\u9519\u8bef\u7684\u6570\u636e\u6f0f\u8fdb\u6765\u7b49\u7b49\u3002\u2f7d\u5f02\u5e38\u901a\u5e38\u662f\u2f64\u6765\u5224\u65ad\u2f64\u2f3e\u8f93\u2f0a\u7684\u9519\u8bef\u7684\u3002\u51fa\u4e86\u5f02\u5e38\u8bc1\u660e\u7a0b\u5e8f\u4e0d\u80fd\u5b8c\u5168\u7684\u5904\u7406\u2f64\u2f3e\u7684\u6240\u6709\u9519\u8bef\u7684\u60c5\u51b5\uff08\u4e0d\u5b8c\u6574\uff09\uff0c\u2f7d assert \u547d\u4e2d\u5219\u8bc1\u660e\u7a0b\u5e8f\u672c\u2f9d\u6709\u9519\u8bef\uff08\u4e0d\u6b63\u786e\uff09\uff0c\u4e0d\u80fd\u7529\u9505\u3002\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"#include <iostream>\n#include <string>\n#include <stack>\n#include <sstream>\n\nusing namespace std;\n\nstruct Item\n{\n    char op = '\\0';\n    int number = 0;\n\n    Item() {}\n    Item(char theOp) :op{ theOp } {}\n};\n\nvoid Run(stack<Item>& items)\n{\n    auto second = items.top();\n    items.pop();\n    auto& first = items.top().number;\n    switch (second.op)\n    {\n    case '+':\n        first += second.number;\n        break;\n    case '-':\n        first -= second.number;\n        break;\n    case '*':\n        first *= second.number;\n        break;\n    case '/':\n        first /= second.number;\n        break;\n    }\n}\n\nint Pop(stack<Item>& items)\n{\n    while (/*3*/items.top().op != '\\0')\n    {\n        Run(items);\n    }\n    /*4*/\n    auto number = items.top().number;\n    items.pop();\n    return number;\n}\n\nvoid Push(stack<Item>& items, int number)\n{\n    /*5*/\n    items.top().number = number;\n    switch (/*6*/items.top().op)\n    {\n    case '*':case '/':\n        Run(items);\n    }\n}\n\nint Calculate(string text)\n{\n    stringstream ss(text);\n    stack<Item> items;\n    items.push({});\n\n    while (true)\n    {\n        char op = ss.peek();\n        switch (op)\n        {\n        case '(':\n            /*1*/\n                items.push({});\n            break;\n        case ')':\n            Push(items, Pop(items));\n            break;\n        case '+':case '-':case '*':case '/':\n            /*2*/\n                items.push({op});\n            break;\n        }\n\n        if (isdigit(op))\n        {\n            int number;\n            ss >> number;\n            Push(items, number);\n        }\n        else if (ss.eof())\n        {\n            return Pop(items);\n        }\n        else\n        {\n            ss.ignore();\n        }\n    }\n}\n\nint main()\n{\n    cout << Calculate(\"1\") << endl;\n    cout << Calculate(\"1+2\") << endl;\n    cout << Calculate(\"1+2*3+4\") << endl;\n    cout << Calculate(\"(11+22)*(33+44)\") << endl;\n    return 0;\n}\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328182411421",src:e(55093).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328181913511",src:e(71982).Z})),(0,r.kt)("p",null,".*\u4f18\u5148\u7ea7\u6bd4()\u66f4\u9ad8"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328181506470",src:e(2865).Z})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"\u8fd9\u5f53\u7136\u662f\u552f\u2f00\u7684\u505a\u6cd5\u3002\u5982\u679c operator* \u5b9a\u4e49\u5728\u7c7b\u2fa5\u2faf\u7684\u8bdd\uff0c\u90a3\u4e48\u7b2c\u2f00\u4e2a\u53c2\u6570\u5c31\u662f\u7c7b\u2f83\u2f30\uff0c\u663e\n\u7136 operator+ \u662f\u4e0d\u80fd\u6709\u4e09\u4e2a\u53c2\u6570\u7684\u3002\u8fd8\u6709\u2f00\u70b9\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u7c7b\u7684\u8fd0\u7b97\u7b26\u4e0d\u80fd\u5b9a\u4e49\u4e3a\u2f00\u4e2a\u9759\u6001\u51fd\n\u6570\u3002\u8fd9\u2f00\u70b9\u6070\u597d\u8ddfC#\u662f\u76f8\u53cd\u7684\u3002\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328174813841",src:e(73449).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328174417771",src:e(7024).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328173359309",src:e(72354).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328170447235",src:e(2756).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328164441763",src:e(27324).Z})),(0,r.kt)("p",null,"B:3 C:3 D:3"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328163244337",src:e(764).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328162402833",src:e(91080).Z})),(0,r.kt)("p",null,"reinterpret_cast \u7684\u610f\u601d\u662f\uff0c\u4e0d\u7ba1\u7c7b\u578b\u4e4b\u95f4\u7684\u5173\u7cfb\uff0c\u5f3a\u2f8f\u5c06\u2f00\u4e2a\u6307\u9488\u91cd\u65b0\u89e3\u91ca\u6210\u53e6 \u2f00\u4e2a\u7c7b\u578b"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328143953987",src:e(81714).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328140321327",src:e(140).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328140234757",src:e(77518).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328134426730",src:e(17308).Z})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"\u6790\u6784\u51fd\u6570\u5199\u6210 private \uff0c\u6216\u8005\u5199\u6210 =delete \uff0c\u90a3\u4e48\u8fd9\u4e2a\u7c7b\u5c31\u4e0d\u80fd\u88ab\u7ee7\u627f\u4e86\uff0c\u56e0\u4e3a\u2f26\u7c7b\u7684\u6790\u6784\u51fd\u6570\u2f46\u6cd5\u8c03\u2f64\u2f57\u7c7b\u7684\u6790\u6784\u51fd\u6570\u3002\n\u5982\u679c\u2f57\u7c7b\u6709\u865a\u6790\u6784\u51fd\u6570\uff0c\u90a3\u4e48\u2f26\u7c7b\u7684\u6790\u6784\u51fd\u6570\u2f00\u5b9a\u662f\u865a\u7684\uff0c\u4e0d\u9700\u8981\u5199 virtual \u5173\u952e\u5b57\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"\u7f16\u8bd1\u5668\u2f63\u6210\u9ed8\u8ba4\u7684\u590d\u5236\u6784\u9020\u51fd\u6570\u548c\u8d4b\u503c\u64cd\u4f5c\u7b26\u91cd\u8f7d\u7684\u89c4\u5219\u5417\uff1f\u5982\u679c\u2f57\u7c7b\u4e0d\u5b58\u5728\u8fd9\u4e9b\u51fd\u6570\u7684\u8bdd\uff0c\u90a3\u4e48\n\u2f26\u7c7b\u9ed8\u8ba4\u4e5f\u4e0d\u4f1a\u2f63\u6210\u3002\u90a3\u4e48\u6700\u7b80\u5355\u7684\u505a\u6cd5\u5c31\u662f\u8ba9 Student \u53bbprivate\u7ee7\u627f\u2f83 NotCopyable \u3002\nclass NotCopyable {\n public : \n    NotCopyable() = default;\n   NotCopyable(const NotCopyable &) = delete; \n   NotCopyable(NotCopyable &&) = delete; \n    NotCopyable & operator=(const NotCopyable &) = delete;\n    NotCopyable & operator=(NotCopyable &&) = delete;\n};\n\nstruct Student : private NotCopyable\n{\n    string name;\n    time_t birtyday;\n};\n\n")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328104738963",src:e(85273).Z})),(0,r.kt)("p",null,"\u5982\u679c X \u662f Y \u7684\u5185\u90e8\u7c7b\uff0c\u90a3\u4e48 Y \u80fd\u770b\u5230\u4ec0\u4e48\uff0c X \u5c31\u80fd\u770b\u5230\u4ec0\u4e48\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u4e0d \u53d7\u4e0a\u2faf\u7684\u89c4\u5219\u7684\u7ea6\u675f"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328112212375",src:e(5339).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328112141838",src:e(14485).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210328111426831",src:e(36604).Z})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"dynamic_cast \u548c visitor \u6a21\u5f0f\u5176\u5b9e\u5404\u6709\u5229\u5f0a\u3002\ndynamic_cast \u7684\u597d\u5904\uff1a\nA\uff1a\u4ee3\u7801\u5199\u8d77\u6765\u76f4\u63a5\u3002\nB\uff1a\u6bcf\u6b21\u6dfb\u52a0\u65b0\u7684\u2f26\u7c7b\uff0c\u8fd9\u4e2a\u7c7b\u548c\u5173\u4e8e\u5b83\u7684\u2f00\u7ec4\u4e0d\u540c\u7684\u903b\u8f91\uff0c\u53ef\u4ee5\u901a\u8fc7\u62bd\u53d6\u51fd\u6570\u6765\u7ec4\u7ec7\u5230\u540c\u2f00\u4e2a\n\u2f42\u4ef6\u2fa5\u3002\ndynamic_cast \u7684\u574f\u5904\uff1a\nC\uff1a\u5f53\u4f60\u9700\u8981\u56e0\u4e3a\u591a\u4e2a\u7c7b\u578b\u7684\u4e0d\u540c\u2f7d\u505a\u4e0d\u540c\u7684\u4e8b\u60c5\u7684\u65f6\u5019\uff0c\u591a\u4e2a if \u548c dynamic_cast \u4f1a\u5bfc\u81f4\n\u6027\u80fd\u4f4e\u4e0b\uff08\u867d\u7136\u5176\u5b9e\u4e0d\u662f\u5f88\u4e25\u91cd\uff09\uff0c\u4ee3\u7801\u7ed3\u6784\u4e5f\u4f1a\u76f8\u5f53\u6df7\u4e71\u3002\nD\uff1a\u5f53\u4f60\u6dfb\u52a0\u2f00\u4e2a\u65b0\u7684\u2f26\u7c7b\u7684\u65f6\u5019\uff0c\u4f60\u8981\u627e\u5230\u6240\u6709\u9700\u8981\u6dfb\u52a0\u65b0\u5206\u2f40\u7684 if \uff0c\u54ea\u6015\u4f60\u6d4b\u8bd5\u2f9c\u591f\uff0c\u4e5f\n\u5f88\u5bb9\u6613\u51fa\u9519\u3002\nE\uff1a\u6dfb\u52a0\u5173\u4e8e\u6240\u6709\u7c7b\u7684\u2f00\u4e2a\u65b0\u903b\u8f91\u7684\u65f6\u5019\uff0c\u4f60\u2f1c\u8981\u5199\u2f00\u2f24\u5806 if \uff0c\u4e0d\u4ec5\u6df7\u4e71\uff0c\u2f7d\u4e14\u7f16\u8bd1\u5668\u8fd8\u2f46\u6cd5\n\u67e5\u6f0f\u8865\u7f3a\uff0c\u5f88\u5bb9\u6613\u72af\u9519\u8bef\u3002\nvisitor \u6a21\u5f0f\u7684\u597d\u5904\uff1a\nC\uff1a\u56e0\u4e3a\u8fd9\u6bd5\u7adf\u662f\u2f00\u4e2aO(1)\u8df3\u8f6c\uff0c\u4e0d\u540c\u7684\u7c7b\u53ea\u9700\u8981\u8df3\u8f6c\u2f00\u6b21\u5c31\u53ef\u4ee5\u8fd0\u2f8f\u76f8\u5e94\u7684\u51fd\u6570\uff08\u2f7d\u4e0d\u662f\n\u2f64 if \u2f00\u4e2a\u2f00\u4e2a\u5c1d\u8bd5\uff09\uff0c\u6027\u80fd\u2fbc\u3002\nD\uff1a\u5f53\u4f60\u6dfb\u52a0\u2f00\u4e2a\u65b0\u7684\u2f26\u7c7b\u7684\u65f6\u5019\uff0c\u53ea\u8981\u4f60 visitor \u63a5\u2f1d\u7684\u6210\u5458\u90fd\u662f\u7eaf\u865a\u7c7b\uff0c\u4f60\u5f88\u5bb9\u6613\u901a\u8fc7\u9605\u8bfb\n\u6240\u6709\u7f16\u8bd1\u9519\u8bef\u6765\u627e\u51fa\u6240\u6709\u9700\u8981\u4fee\u6539\u3002\nE\uff1a\u6dfb\u52a0\u5173\u4e8e\u6240\u6709\u7684\u7c7b\u7684\u2f00\u4e2a\u65b0\u7684\u903b\u8f91\u5f88\u5bb9\u6613\uff0c\u5c31\u662f\u7ee7\u627f\u2f83\u63a5\u2f1d\uff0c\u4e95\u4e95\u6709\u6761\u3002\nvisitor \u6a21\u5f0f\u7684\u574f\u5904\uff1a\nA\uff1a\u4ee3\u7801\u5199\u8d77\u6765\u2f50\u8f83\u66f2\u6298\u3002\nB\uff1a\u6bcf\u6b21\u6dfb\u52a0\u65b0\u7684\u2f26\u7c7b\uff0c\u90fd\u4f1a\u4fee\u6539\u5f88\u591a\u76f8\u5173\u7684\u2f42\u4ef6\u3002\u4f46\u662f\u5728\u7f16\u8bd1\u5668\u7684\u7f16\u8bd1\u9519\u8bef\u7684\u5e2e\u52a9\u4e0b\uff0c\u5176\u5b9e\u8fd9\n\u5e76\u4e0d\u662f\u2f00\u4e2a\u4ee4\u2f08\u6050\u6016\u7684\u95ee\u9898\uff0c\u53ea\u662f\u770b\u8d77\u6765\u6050\u6016\u3002\n\u2f24\u5bb6\u53ef\u4ee5\u770b\u51fa\uff0c\u8fd9\u4e24\u79cd\u2f45\u6cd5\u4e92\u6709\u5229\u5f0a\uff0c\u2f7d\u4e14\u5229\u5f0a\u662f\u5b8c\u5168\u76f8\u53cd\u7684\u3002 dynamic_cast \u7684\u505a\u6cd5\u6269\u5c55\u65b0\n\u7684\u7c7b\u5bb9\u6613\uff0c\u6269\u5c55\u65b0\u7684\u903b\u8f91\u56f0\u96be\u3002\u2f7d visitor \u6a21\u5f0f\u7684\u505a\u6cd5\uff0c\u6269\u5c55\u65b0\u7684\u7c7b\u56f0\u96be\uff0c\u6269\u5c55\u65b0\u7684\u903b\u8f91\u5bb9\u6613\u3002\n\u5f53\u7136\uff0c\u54ea\u6015 visitor \u6a21\u5f0f\u4e0d\u597d\u2f64\uff0c\u2f24\u5bb6\u4e5f\u4e0d\u8981\u2f74\u523b\u5c31\u4f7f\u2f64 dynamic_cast \u6765\u641e\u4e71\u2f83\u2f30\u7684\u4ee3\u7801\uff0c\u2f06\n\u2f17\u56db\u4e2a\u8bbe\u8ba1\u6a21\u5f0f\u2fa5\u2faf\u8fd8\u6709\u5f88\u591a\u5176\u4ed6\u7684\u5185\u5bb9\u53ef\u4f9b\u9009\u62e9\u3002\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c++"},"static_cast \u3002\u5b83\u8ddf dynamic_cast \u7684\u533a\u522b\u5c31\u662f\uff0c\u4ed6\u4e0d\u56de\u53bb\u68c0\u67e5 pAnimal \u5230\u5e95\u662f\u4e0d\n\u662f Cat \uff0c\u5c31\u76f4\u63a5\u8f6c\u6362\u7ed9\u4f60\u3002\u5982\u679c\u4e0d\u662f\u7684\u8bdd\uff0c\u4f60\u5c31\u4f1a\u62ff\u5230\u2f00\u4e2a\u91ce\u6307\u9488\uff0c\u4f7f\u2f64\u5b83\u5c31\u4f1a\n\u53d1\u2f63 undefined behavior\u3002\n\u53e6\u5916\u8981\u63d0\u5230\u7684\u662f\uff0c dynamic_cast \u4e5f\u53ef\u4ee5\u5728\u2f57\u7c7b\u7684\u2f0f\u4e2a\u2f26\u7c7b\u4e0b\u8f6c\u6362\uff0c\u5982\u679c\u4e0d\u8fd4\n\u56de nullptr \u5c31\u4ee3\u8868\u4f60\u7684\u8f6c\u6362\u6210\u529f\u4e86\uff0c\u8fd9\u4e2a\u6307\u9488\u6307\u5411\u7684\u7684\u786e\u662f\u4f60\u9700\u8981\u7684\u7c7b\u578b\u7684\u5bf9\u8c61\u3002\n\u2f7d static_cast \u8fd9\u6837\u505a\u4f1a\u6709\u8bed\u6cd5\u9519\u8bef\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\u8c01\u6784\u9020\u8c01\u91ca\u653e\n\n\u6211\u4eec\u5728\u8ba8\u8bba\u7ee7\u627f\u7684\u65f6\u5019\uff0c\u8111\u2f26\u2fa5\u8981\u60f3\u7684\u662f\uff1aa cat \u2208 {animal}\u3002\n\n\u2fa5\u2f52\u4ee3\u6362\u539f\u5219\u7684\u5185\u5bb9\u53ea\u6709\u2f00\u53e5\u8bdd\uff1a\u2f26\u7c7b\u7684\u5bf9\u8c61\u80fd\u591f\u66ff\u6362\u5176\u57fa\u7c7b\u7684\u5bf9\u8c61\u88ab\u4f7f\u2f64\u3002\u4e3e \u4e2a\u4f8b\u2f26\uff0c\u4efb\u4f55\u4f7f\u2f64 Animal \u7684\u5730\u2f45\uff0c\u6211\u4eec\u90fd\u53ef\u4ee5\u653e Cat \u8fdb\u53bb\uff0c\u2f7d\u5b8c\u5168\u4e0d\u6270\u4e71\u7a0b\u5e8f\u7684\u903b \u8f91\u3002\u2f7d\u4e14\u7a0b\u5e8f\u2fa5\u2faf\u5173\u4e8e Animal \u7684\u5047\u8bbe\uff0c Cat \u90fd\u4e0d\u80fd\u6253\u7834\u3002\n\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"struct cmp {\n    bool operator()(int &a, int &b) {\n        return a > b;\n    }\n};\n\npriority_queue<int, vector<int>, cmp> que;\n\n")),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/"},"https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/")),(0,r.kt)("p",null,"\u5f53\u7a0b\u5e8f\u8fd0\u884cfuncA\u4e4b\u524d\uff0cj\u7684\u503c\u5c31\u786e\u5b9a\u4e86\uff0c\u800ck\u7684\u503c\u662f\u4e0d\u786e\u5b9a\u7684\u3002k\u7684\u503c\u53ea\u6709\u5728funcA\u51fd\u6570\u91cc\u9762\u771f\u6b63\u8c03\u7528lambda\u8868\u8fbe\u5f0f\u7684\u65f6\u5019\u624d\u786e\u5b9a\u3002\u8fd9\u4e2a\u7a0b\u5e8f\u8fd8\u53ef\u4ee5\u6362\u4e00\u79cd\u66f4\u52a0\u660e\u786e\u7684\u5199\u6cd5\u3002"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void fun()\n{\n      int i=1;\n      int j=2;\n      function<bool(int)> f=[j](int k)(return k>j;);\n      funcA(i, f);\n}\n")),(0,r.kt)("p",null,"\u5f53\u7a0b\u5e8f\u8fd0\u884c\u5230\u521b\u5efaf\u5bf9\u8c61\u65f6\uff0cj\u7684\u503c\u662f\u786e\u5b9a\u7684\uff08\u5b83\u5176\u5b9e\u88ab\u4f5c\u4e3af\u7684\u4e00\u4e2a\u6210\u5458\u53d8\u91cf\u521d\u59cb\u5316\u4e86\uff09\uff0c\u800ck\u7684\u503c\u662f\u4e0d\u786e\u5b9a\u7684\u3002\u6ce8\u610flambda\u8868\u8fbe\u5f0f\u662f\u4e00\u79cd\u7279\u6b8a\u7684\u6570\u636e\u7c7b\u578b\uff08\u5373\u4f7f\u5b83\u548c\u67d0\u51fd\u6570\u5177\u6709\u76f8\u540c\u53c2\u6570\u7c7b\u578b\u548c\u8fd4\u56de\u503c\u7c7b\u578b\uff0c\u5b83\u4eec\u4e5f\u5c5e\u4e8e\u4e0d\u540c\u6570\u636e\u7c7b\u578b\uff09\uff0c\u7f16\u8bd1\u5668\u5728\u7f16\u8bd1\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u6839\u636e\u6211\u4eec\u6240\u5199\u7684lambda\u8868\u8fbe\u5f0f\u81ea\u52a8\u4ea7\u751f\u4e00\u4e2a\u6570\u636e\u7c7b\u578b\u3002\u6240\u4ee5\u58f0\u660ef\u5bf9\u8c61\u7684\u65f6\u5019\u6211\u4eec\u4e00\u822c\u53ea\u80fd\u7528auto f=","[j]","(int k)(return k>j)\uff0c\u56e0\u4e3a\u6211\u4eec\u4e0d\u77e5\u9053\u5b83\u662f\u4ec0\u4e48\u7c7b\u578b\u3002\u4f46\u662f\u6211\u4eec\u4e4b\u524d\u8bf4\u8fc7\u56de\u8c03\u51fd\u6570\u7684\u7c7b\u578b\u5728\u58f0\u660e\u8c03\u7528\u8005\u7684\u65f6\u5019\uff08\u4e5f\u5c31\u662f\u58f0\u660efuncA\u7684\u65f6\u5019\uff09\u5c31\u5df2\u7ecf\u786e\u5b9a\u4e86\u3002\u6240\u4ee5\u8fd9\u91cc\u6709\u70b9\u77db\u76fe\u3002\u8fd9\u4e2a\u77db\u76fe\u9700\u8981\u53e6\u4e00\u4e2a\u5e93\u6a21\u7248\u51fd\u6570\u7c7b\u578bfuncion\u6765\u89e3\u51b3\u3002\u6709\u4e86\u5b83\uff0c\u53ea\u8981\u53c2\u6570\u548c\u8fd4\u56de\u503c\u7c7b\u578b\u90fd\u76f8\u540c\u5c31\u53ef\u4ee5\u5b9a\u4e49\u4e3a\u540c\u4e00\u79cdfunction\u7c7b\u578b\u3002"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210327220916334",src:e(89954).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210327220903109",src:e(39889).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20201223214822348",src:e(68442).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20201223214345364",src:e(72632).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210327215830460",src:e(84396).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20201223214051240",src:e(44821).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210327215710837",src:e(35565).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20201223214008563",src:e(13999).Z})),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20201223213406320",src:e(18659).Z})),(0,r.kt)("p",null,"TDD\u6d4b\u8bd5\u9a71\u52a8\u7f16\u7a0b"),(0,r.kt)("p",null,"gdb assert\u65ad\u8a00"),(0,r.kt)("p",null,"\u5355\u5143\u6d4b\u8bd5\u6280\u672f"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054"},"https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054")),(0,r.kt)("h2",{id:"c\u591a\u7ebf\u7a0b"},"C++\u591a\u7ebf\u7a0b"),(0,r.kt)("h3",{id:"\u6761\u4ef6\u53d8\u91cf\u548c\u4e92\u65a5\u9501"},"\u6761\u4ef6\u53d8\u91cf\u548c\u4e92\u65a5\u9501"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u91ca\u653em_mutex")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"wait :",(0,r.kt)("strong",{parentName:"p"},"\u5df2\u7ecf\u91ca\u653e\u4e92\u65a5\u9501"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u62ff\u5230m_mutex"))),(0,r.kt)("ol",{start:4},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u62ff\u5230m_mutex")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"notify_one,",(0,r.kt)("strong",{parentName:"p"},"\u5e76\u4e0d\u91ca\u653e\u4e92\u65a5\u9501"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u91ca\u653e\u4e92\u65a5\u9501"))),(0,r.kt)("p",null,"m_cond -\u76f8\u5e94\u4e32\u884c"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"notify_one :\u901a\u77e5\u4e00\u4e2a"),(0,r.kt)("li",{parentName:"ul"},"notify_all :\u901a\u77e5\u6240\u6709"),(0,r.kt)("li",{parentName:"ul"},"wait \u7b49\u5f85\u4fe1\u53f7")),(0,r.kt)("p",null,"\u901a\u8fc7\u4e92\u65a5\u9501\u4fdd\u8bc1\u7ebf\u7a0b\u5b89\u5168,\u62a2\u5230\u4e92\u65a5\u9501,\u7136\u540e\u6536\u5230\u4fe1\u53f7\u540e\u6267\u884c "),(0,r.kt)("h3",{id:"\u7ebf\u7a0b\u5b89\u5168"},"\u7ebf\u7a0b\u5b89\u5168"),(0,r.kt)("p",null,"\u62e5\u6709\u5171\u4eab\u6570\u636e\u7684\u591a\u6761\u7ebf\u7a0b\u5e76\u884c\u6267\u884c\u7684\u7a0b\u5e8f\u4e2d\uff0c\u7ebf\u7a0b\u5b89\u5168\u7684\u4ee3\u7801\u4f1a\u901a\u8fc7\u540c\u6b65\u673a\u5236\u4fdd\u8bc1\u5404\u4e2a\u7ebf\u7a0b\u90fd\u53ef\u4ee5\u6b63\u5e38\u4e14\u6b63\u786e\u7684\u6267\u884c\uff0c\u4e0d\u4f1a\u51fa\u73b0\u6570\u636e\u6c61\u67d3\u7b49\u610f\u5916\u60c5\u51b5"),(0,r.kt)("h3",{id:"\u7ebf\u7a0b\u6c60"},"\u7ebf\u7a0b\u6c60"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u591a\u7ebf\u7a0b\u7684\u6570\u91cf")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u80fd\u6267\u884c\u51fa\u5165\u7684\u4efb\u610f\u51fd\u6570")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"\u6267\u884c\u8fc7\u7a0b,\u6309\u4f18\u5148\u7ea7\u987a\u5e8f"),(0,r.kt)("p",{parentName:"li"},"Logger\u65e5\u5fd7\u8f93\u51fa\u7c7b"))),(0,r.kt)("h2",{id:"threadstrong"},"thread+strong"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},' #ifndef _THREAD_POOL_H\n#define _THREAD_POOL_H\n\n#include <iostream>\n#include <algorithm>\n#include <thread>\n#include <queue>\n#include <condition_variable>\n#include <mutex>\n\nnamespace haizei {\n\nclass Task {\npublic :\n    template<typename Func_T, typename ...ARGS>\n    Task(Func_T f, ARGS ...args) {\n        func = std::bind(f, std::forward<ARGS>(args)...);\n    }\n    void run() {\n        func();\n    }\nprivate:\n    std::function<void()> func;\n};\n\nclass thread_pool {\npublic:        \n    thread_pool(int thread_size = 5) \n    : thread_size(thread_size),\n      is_started(false),\n      m_mutex(),\n      m_cond(),\n      m_queue_cond(),\n      m_queue_mutex(),\n      m_mutex2()\n    {}\n    void start();\n    void stop();\n    template<typename Func_T, typename ...ARGS>\n    void add_one_task(Func_T f, ARGS...args) {\n        std::unique_lock<std::mutex> lock(m_queue_mutex);\n        __add_one_task(new Task(f, std::forward<ARGS>(args)...));\n    }\n    void stop_until_empty();\n    ~thread_pool() { stop(); }\n\nprivate:\n    void thread_loop();\n    Task *get_one_task();\n    void __add_one_task(Task *);\n    void __stop_set_false();\n\n    int thread_size;\n    volatile bool is_started;\n    std::vector<std::thread *> Threads;\n    std::queue<Task *> Tasks;\n\n    std::mutex m_mutex, m_mutex2;\n    std::mutex m_queue_mutex;\n    std::condition_variable m_cond;\n    std::condition_variable m_queue_cond;\n};\n\nvoid thread_pool::start() {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    is_started = true;\n    for (int i = 0; i < thread_size; i++) {\n        Threads.push_back(new std::thread(&thread_pool::thread_loop, this));\n    }\n}\n\nvoid thread_pool::stop_until_empty() {\n    std::unique_lock<std::mutex> lock1(m_mutex2);\n    std::unique_lock<std::mutex> lock2(m_queue_mutex);\n    while (!Tasks.empty()) {\n        m_queue_cond.wait(lock1);\n    }\n    stop();\n    return ;\n}\n\nvoid thread_pool::stop() {\n    {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        is_started = false;\n        m_cond.notify_all();\n    }\n    for (int i = 0; i < Threads.size(); i++) {\n        Threads[i]->join();\n        delete Threads[i];\n    }\n    Threads.clear();\n    return ;\n}\n\nvoid thread_pool::thread_loop() {\n    while (is_started) {\n        Task *t = get_one_task();\n        if (t != nullptr) {\n            //std::cout << "thread_loop tid : " << std::this_thread::get_id() << std::endl;\n            t->run();\n        } \n    }\n    return ;\n}\n\nTask* thread_pool::get_one_task() {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    while (Tasks.empty() && is_started) {\n        m_cond.wait(lock);\n    }\n    Task *t = nullptr;\n    if (!Tasks.empty() && is_started) {\n        t = Tasks.front();\n        Tasks.pop();\n        if (Tasks.empty()) {\n            std::unique_lock<std::mutex> lock2(m_mutex2);\n            m_queue_cond.notify_all();\n        }\n    }\n    return t;\n}\n\nvoid thread_pool::__add_one_task(Task *t) {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    Tasks.push(t);\n    m_cond.notify_one();\n    return ;\n}\n\n}\n\n#endif\n\n')),(0,r.kt)("h3",{id:"logger\u65e5\u5fd7\u8f93\u51fa\u7c7b"},"Logger\u65e5\u5fd7\u8f93\u51fa\u7c7b"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#ifndef _LOGGER_HAIZEI_H\n#define _LOGGER_HAIZEI_H\n#include <iostream>\n#include <sstream>\n#include <mutex>\n\nnamespace worst {\nclass LoggerStream : public std::ostringstream {\npublic :\n    LoggerStream() {}\n    LoggerStream(const LoggerStream &ls) {}\n    ~LoggerStream() {\n        output();\n    }\nprivate:\n    void output() {\n        std::unique_lock<std::mutex> lock(m_mutex);\n        std::cout << this->str() << std::endl;\n        std::cout.flush();\n        return ;\n    }\n    std::mutex m_mutex;\n};\n\nclass Logger {\n    class LoggerStream : public std::ostringstream {\n    public :\n        LoggerStream(Logger &raw_obj) : raw_obj(raw_obj) {}\n        LoggerStream(const LoggerStream &ls) : raw_obj(ls.raw_obj) {}\n        ~LoggerStream() {\n            output();\n        }\n    private:\n        void output() {\n            std::unique_lock<std::mutex> lock(raw_obj.m_mutex);\n            std::cout << this->str() << std::endl;\n            std::cout.flush();\n            return ;\n        }\n        Logger &raw_obj;\n    };\npublic :\n    LoggerStream operator()() {\n        return LoggerStream(*this);\n    }\nprivate:\n    std::mutex m_mutex;\n};\n\n}\n\n")),(0,r.kt)("h3",{id:"thread_pool"},"thread_pool"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#ifndef _THREAD_POOL_H\n#define _THREAD_POOL_H\n\n#include <iostream>\n#include <algorithm>\n#include <thread>\n#include <queue>\n#include <condition_variable>\n#include <mutex>\nnamespace haizei {\n\nclass Task {\npublic :\n    template<typename Func_T, typename ...ARGS>\n    Task(Func_T f, ARGS ...args) {\n        func = std::bind(f, std::forward<ARGS>(args)...);\n    }\n    void run() {\n        func();\n    }\nprivate:\n    std::function<void()> func;\n};\n\nclass thread_pool {\npublic:        \n    thread_pool(int thread_size = 5) \n    : thread_size(thread_size),\n      is_started(false),\n      m_mutex(),\n      m_cond()\n    {}\n    void start();\n    void stop();\n    template<typename Func_T, typename ...ARGS>\n    void add_one_task(Func_T f, ARGS...args) {\n        __add_one_task(new Task(f, std::forward<ARGS>(args)...));\n    }\n    ~thread_pool() { stop(); }\n\nprivate:\n    void thread_loop();\n    Task *get_one_task();\n    void __add_one_task(Task *);\n    void __stop_set_false();\n\n    int thread_size;\n    volatile bool is_started;\n    std::vector<std::thread *> Threads;\n    std::queue<Task *> Tasks;\n\n    std::mutex m_mutex;\n    std::condition_variable m_cond;\n};\n\nvoid thread_pool::start() {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    is_started = true;\n    for (int i = 0; i < thread_size; i++) {\n        Threads.push_back(new std::thread(&thread_pool::thread_loop, this));\n    }\n}\n\nvoid thread_pool::__stop_set_false() {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    is_started = false;\n    m_cond.notify_all();\n    return ;\n}\n\nvoid thread_pool::stop() {\n    __stop_set_false();\n    for (int i = 0; i < Threads.size(); i++) {\n        Threads[i]->join();\n        delete Threads[i];\n    }\n    Threads.clear();\n    return ;\n}\n\nvoid thread_pool::thread_loop() {\n    while (is_started) {\n        Task *t = get_one_task();\n        if (t != nullptr) {\n            std::cout << "thread_loop tid : " << std::this_thread::get_id() << std::endl;\n            t->run();\n        } \n    }\n    return ;\n}\n\nTask* thread_pool::get_one_task() {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    while (Tasks.empty() && is_started) {\n        m_cond.wait(lock);\n    }\n    Task *t = nullptr;\n    if (!Tasks.empty() && is_started) {\n        t = Tasks.front();\n        Tasks.pop();\n    }\n    return t;\n}\n\nvoid thread_pool::__add_one_task(Task *t) {\n    std::unique_lock<std::mutex> lock(m_mutex);\n    Tasks.push(t);\n    m_cond.notify_one();\n    return ;\n}\n\n}\n\n#endif\n')),(0,r.kt)("h2",{id:"handle\u8d23\u4efb\u94fe\u6a21\u5f0f"},"handle\u8d23\u4efb\u94fe\u6a21\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'//\u4ea4\u7ed9\u5de5\u5382,\u80fd\u4e14\u53ea\u80fd\u6709\u5de5\u5382\u521b\u5efa\u5bf9\u8c61\nclass ICar {\npublic :\n    class IFactory {\n    public :\n        virtual ICar *create() = 0;    \n    };\n    class IHandler {\n    public :\n        IHandler() : next(nullptr) {}\n        virtual bool is_valid(int) = 0;\n        virtual ICar *do_it() = 0;\n        IHandler *next;\n    };\n    virtual void runc() = 0;\nprotected :\n    ICar() {}\n    ~ICar() {}\n};\n\n\nclass BenzCar : public ICar {\n    BenzCar() {}\npublic :\n    class Factory : public ICar::IFactory, public ICar::IHandler {\n    public :\n        virtual ICar *create() override {\n            return new BenzCar();\n        }\n        virtual bool is_valid(int x) override {\n            return x == 0;\n        }\n        virtual ICar *do_it() override {\n            return this->create();\n        }\n    };\n    virtual void runc() override {\n        cout << "BenzCar run" << endl;\n    }\n};\nclass BmwCar : public ICar {\n    BmwCar() {}\npublic:\n    class Factory : public ICar::IFactory, public ICar::IHandler {\n    public :\n        virtual ICar *create() override {\n            return new BmwCar();\n        }\n        virtual bool is_valid(int x) override{\n            return x == 1;\n        }\n        virtual ICar *do_it() override {\n            return this->create();\n        }\n    };\n    virtual void runc() override {\n        cout << "BmwCar run" << endl;\n    }\n};\nclass AudiCar : public ICar {\n    AudiCar() {}\npublic :\n    class Factory : public ICar::IFactory, public ICar::IHandler {\n    public :\n        virtual ICar *create() override {\n            return new AudiCar();\n        }\n        virtual bool is_valid(int x) override {\n            return x == 2;\n        }\n        virtual ICar *do_it() override {\n            return this->create();\n        }\n    };\n    virtual void runc() override {\n        cout << "AudiCar run" << endl;\n    }\n};\n\nclass ChainMaster {\npublic :\n    static ICar::IHandler *getInstance() {\n        if (head == nullptr) {\n            buildChain();\n        }\n        return head;\n    }\nprivate :\n    static ICar::IHandler *head;\n    static void buildChain() {\n        head = new BmwCar::Factory(); \n        head->next = new AudiCar::Factory();\n        head->next->next = new BenzCar::Factory();\n        return ;\n    }\n};\nICar::IHandler* ChainMaster::head = nullptr;\n\nint main() {\n    srand(time(0));\n    ICar *cars[10];\n    for (int i = 0; i < 10; ++i) {\n        int request = rand() % 3;\n        for (auto p  = ChainMaster::getInstance(); p; p = p->next) {\n            if (p->is_valid(request)) {\n                cars[i] = p->do_it();\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < 10; ++i) {\n        cars[i]->runc();\n    }\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"factory\u62bd\u8c61\u5de5\u5382\u6a21\u5f0f"},"factory\u62bd\u8c61\u5de5\u5382\u6a21\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'//\u4ea4\u7ed9\u5de5\u5382,\u80fd\u4e14\u53ea\u80fd\u6709\u5de5\u5382\u521b\u5efa\u5bf9\u8c61\nclass ICar {\npublic :\n    class IFactory {\n    public :\n        virtual ICar *create() = 0;    \n    };\n    virtual void runc() = 0;\nprotected :\n    ICar() {}\n    ~ICar() {}\n};\n\n\nclass BenzCar : public ICar {\n    BenzCar() {}\npublic :\n    class Factory : public ICar::IFactory {\n    public :\n        virtual ICar *create() {\n            return new BenzCar();\n        }\n    };\n    virtual void runc() {\n        cout << "BenzCar run" << endl;\n    }\n};\nclass BmwCar : public ICar {\n    BmwCar() {}\npublic:\n    class Factory : public ICar::IFactory {\n    public :\n        virtual ICar *create() {\n            return new BmwCar();\n        }\n    };\n    virtual void runc() {\n        cout << "BmwCar run" << endl;\n    }\n};\nclass AudiCar : public ICar {\n    AudiCar() {}\npublic :\n    class Factory : public ICar::IFactory {\n    public :\n        virtual ICar *create() {\n            return new AudiCar();\n        }\n    };\n    virtual void runc() {\n        cout << "AudiCar run" << endl;\n    }\n};\n\nICar::IFactory *fac[3] = {new BenzCar::Factory(), new BmwCar::Factory(), new BmwCar::Factory()};\n\nint main() {\n    srand(time(0));\n    ICar *cars[10];\n    for (int i = 0; i < 10; ++i) {\n        cars[i] = fac[rand() % 3]->create();\n    }\n    for (int i = 0; i < 10; ++i) {\n        cars[i]->runc();\n    }\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"singleton\u5355\u4f8b\u6a21\u5f0f"},"singleton\u5355\u4f8b\u6a21\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class HttpServer {\npublic :\n    static HttpServer *getInstance() {\n        //\u591a\u7ebf\u7a0b\u6709\u5185\u5b58\u6cc4\u6f0f,\u52a0\u9501\n        //\u53cc\u91cd\u9a8c\u8bc1,\u53ef\u4ee5\u5141\u8bb8\u8bfb,\u89e3\u51b3\u6548\u7387\u95ee\u9898\n        if (instance == nullptr) { //\u9632\u6b62\u65e0\u610f\u4e49\u7684\u91cd\u590d\u52a0\u9501\n            std::unique_lock<std::mutex> lock(m_mutex);\n            if (instance == nullptr) { //\u9632\u6b62\u5185\u5b58\u6cc4\u9732\n                instance = new HttpServer();\n            } \n        }\n        return instance;\n    }\n\nprivate :\n    static HttpServer *instance;\n    static std::mutex m_mutex;\n    HttpServer() {}\n    HttpServer(const HttpServer &) = delete;\n    ~HttpServer() {}\n};\n\n//HttpServer *HttpServer::instance = new HttpServer(); //\u6076\u6c49\u6a21\u5f0f,\u76f4\u63a5\u521d\u59cb\u5316\nHttpServer *HttpServer::instance = nullptr; //\u61d2\u6c49\u6a21\u5f0f,\u52a0\u9501,\u5224\u65ad,\u9700\u8981\u65f6\u5728\u521d\u59cb\u5316\nstd::mutex HttpServer::m_mutex;\n\nint main() {\n    /*\n    HttpServer h1;\n    HttpServer h2(h1);\n    HttpServer h3 = h1;\n    */\n    HttpServer *t1 = HttpServer::getInstance();\n    HttpServer *t2 = HttpServer::getInstance();\n    cout << t1 << " " << t2 << endl;\n    return 0;\n}\n\n')),(0,r.kt)("h2",{id:"visitor\u8bbf\u95ee\u8005\u6a21\u5f0f"},"visitor\u8bbf\u95ee\u8005\u6a21\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class B;\nclass C;\nclass D;\nclass E;\nclass F;\n\nclass A {\npublic :\n    class IVisitor {\n    public : \n        virtual void visit(A *) = 0;\n        virtual void visit(B *) = 0;\n        virtual void visit(C *) = 0;\n    };\n    //virtual void Accept(IVisitor *) = 0;\n    virtual void Accept(IVisitor *vis) {\n           vis->visit(this); \n    }\n    virtual ~A() {}\n};\n\nclass B : public A {\npublic :\n    void Accept(IVisitor *vis) {\n        vis->visit(this);\n    }\n};\nclass C : public A {\npublic :\n    void Accept(IVisitor *vis) {\n        vis->visit(this);\n    }\n};\n\nclass OutputVisitor : public A::IVisitor {\n    virtual void visit(A *obj) {\n        cout << "this is a class A father" << endl;\n    }\n    virtual void visit(B *obj) {\n        cout << "this is a class B object" << endl;\n    }\n    virtual void visit(C *obj)  {\n        cout << "this is a class C object" << endl;\n    }\n};\n\nclass CalcVisitor : public A::IVisitor {\n    virtual void visit(A *obj) {\n        cout << ans << endl;\n    }\n    virtual void visit(B *obj) {\n        ans += 5;\n        cout << "+5 : " << " " << ans << endl;\n    }\n    virtual void visit(C *obj)  {\n        ans *= 2;\n        cout << "*2 : " << " " << ans << endl;\n    }\npublic :\n    //static int ans;\n    CalcVisitor(int ans = 1) : ans(ans) {}\n    int ans;\n};\n\n//int CalcVisitor::ans = 0;\n\n\nint main() {\n    A *arr[10];\n    for (int i  = 0; i < 10; ++i) {\n        switch (rand() % 4) {\n            case 0 : arr[i] = new B(); break;        \n            case 1 : arr[i] = new C(); break;        \n            case 2 : arr[i] = new D(); break;        \n            case 3 : arr[i] = new E(); break;        \n        }\n    }\n\n    //dynamic_cast : \u8fd8\u539f\u539f\u5bf9\u8c61\u7684\u5730\u5740,\u901a\u8fc7\u865a\u51fd\u6570\u8868\u5730\u5740\u5224\u65ad,\u6240\u4ee5\u539f\u6709\u57fa\u7c7b\u4e00\u5b9a\u662f\u62bd\u8c61\u7c7b(virtual)\n    //\u6709\u7236\u7c7b\u6307\u9488\u5230\u5b50\u7c7b\u6307\u9488\u6839\u636e\u4e0d\u540c\u7c7b\u578b\u505a\u4e0d\u540c\u529f\u80fd\u6620\u5c04\n    //\u5982\u679c\u5c11\u52a0\u4e00\u4e2a\u6d3e\u751f\u7c7b\u7684\u6761\u4ef6\u5206\u652fif-else\u5c31\u4f1a\u51fa\u9519\n    //visitor\u8bbf\u95ee\u8005\u6a21\u5f0f,\u89e3\u51b3\u529f\u80fd\u6620\u5c04\n    OutputVisitor vis1;\n    CalcVisitor vis2;\n    for (int i = 0; i < 10; ++i) {\n        arr[i]->Accept(&vis1);\n        arr[i]->Accept(&vis2);\n    }\n//    cout << CalcVisitor::ans << endl;\n    cout << vis2.ans << endl;\n    return 0;\n}\n')),(0,r.kt)("h3",{id:"\u8bbf\u95ee\u8005\u6a21\u5f0f"},"\u8bbf\u95ee\u8005\u6a21\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class A {\npublic :\n    virtual ~A() {}\n};\n\nclass B : public A {};\nclass C : public A {};\nclass D : public A {};\nclass E : public A {};\n\nint main() {\n    A *arr[10];\n    for (int i  = 0; i < 10; ++i) {\n        switch (rand() % 4) {\n            case 0 : arr[i] = new B(); break;        \n            case 1 : arr[i] = new C(); break;        \n            case 2 : arr[i] = new D(); break;        \n            case 3 : arr[i] = new E(); break;        \n            default : arr[i] = new A(); break;\n        }\n    }\n\n    //dynamic_cast : \u8fd8\u539f\u539f\u5bf9\u8c61\u7684\u5730\u5740,\u901a\u8fc7\u865a\u51fd\u6570\u8868\u5730\u5740\u5224\u65ad,\u6240\u4ee5\u539f\u6709\u57fa\u7c7b\u4e00\u5b9a\u662f\u62bd\u8c61\u7c7b(virtual) \u7236\u7c7b\u6307\u9488->\u5b50\u7c7b\u6307\u9488\n    \n    //\u6790\u6784\u51fd\u6570\u8bbe\u4e3avirtual \u4e3a\u4e86\u6790\u6784\u548cdynamic_cast\n    \n    //\u6709\u7236\u7c7b\u6307\u9488\u5230\u5b50\u7c7b\u6307\u9488\u6839\u636e\u4e0d\u540c\u7c7b\u578b\u505a\u4e0d\u540c\u529f\u80fd\u6620\u5c04\n    //\u6dfb\u52a0\u4e00\u4e2a\u6d3e\u751f\u7c7b\uff0c\u5982\u679c\u5c11\u52a0\u4e00\u4e2a\u6d3e\u751f\u7c7b\u7684\u6761\u4ef6\u5206\u652fif-else\u5c31\u4f1a\u51fa\u9519\n    //visitor\u8bbf\u95ee\u8005\u6a21\u5f0f,\u89e3\u51b3\u529f\u80fd\u6620\u5c04\n    \n    //\u5b9e\u73b0\u6dfb\u52a0\u4e00\u4e2a\u6d3e\u751f\u7c7b\uff0c\u800c\u5fd8\u4e86\u6dfb\u52a0\u67d0\u4e2a\u529f\u80fd\u65f6\uff0c\u7f16\u8bd1\u5668\u62a5\u9519\n    \n    for (int i = 0; i < 10; ++i) {\n        if(dynamic_cast<B *>(arr[i])) {\n            cout << "this is a class B object" << endl;\n        } else if (dynamic_cast<C *> (arr[i])) {\n            cout << "this is a class C object" << endl;\n        } else if (dynamic_cast<D *> (arr[i])) {\n            cout << "this is a class D object" << endl;\n        } else {\n            cout << "this is a error class pointer" << endl;\n        }\n    }\n    return 0;\n}\n\n')),(0,r.kt)("h2",{id:"\u8bbe\u8ba1\u6a21\u5f0f"},"\u8bbe\u8ba1\u6a21\u5f0f"),(0,r.kt)("p",null,"\u9762\u5411\u5bf9\u8c61\u7684\u7f16\u7a0b\u8303\u5f0f\uff0c\u6307\u5bfc\u7a0b\u5e8f\u8bbe\u8ba1\u7684\u65b9\u5f0f\u65b9\u6cd5"),(0,r.kt)("h2",{id:"\u503c\u7684\u7c7b\u578b\u548c\u79fb\u52a8\u6784\u9020"},"\u503c\u7684\u7c7b\u578b\u548c\u79fb\u52a8\u6784\u9020"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void judge2(int &x) {\n    cout << " int function 2 " << x << " is left value" << endl;\n    return ;\n}\n\nvoid judge2(int &&x) {\n    cout << " int function 2 " << x << " is right value" << endl;\n    return ;\n}\n\nvoid judge(int &x) {\n    cout << x << " is left value" << endl;\n    //judge2(x); // x\u662f\u5de6\u503c\n    judge2(move(x));\n    return ;\n}\n\nvoid judge(int &&x) {\n    cout << x << " is right value" << endl;\n   // judge2(x); // x\u867d\u7136\u662f\u53f3\u503c\u5f15\u7528\u4f46\u662f\u5de6\u503c\n    judge2(forward<int &&>(x));\n    return ;\n}\n\nclass A {\npublic :\n    A(int n  = 10) : n(n) {\n        arr = new int[n];\n        for (int i = 0; i < n; ++i) arr[i] = i;\n        cout << "constructor" << endl;\n    }\n    A(const A &obj) : n(obj.n) { //\u62f7\u8d1d\u6784\u9020:\u5de6\u503c\u5f15\u7528\n        this->arr = new int[n];\n        for (int i = 0; i < n; ++i) this->arr[i] = obj.arr[i];\n        cout << "copy constructor" << endl;\n    }\n    A(A &&obj) : n(obj.n), arr(obj.arr) { //\u79fb\u52a8\u6784\u9020:\u53f3\u503c\u5f15\u7528\n        cout << "move constructor" << endl;\n        obj.arr = nullptr;\n    }\n    A operator+(const A &obj) {\n        A temp(this->n + obj.n);\n        for (int i = 0; i < this->n; ++i) temp.arr[i] = this->arr[i];\n        for (int i = 0; i < obj.n; ++i) temp.arr[i + this->n] = obj.arr[i];\n        return temp;\n    }\n    void output() {\n        for (int i = 0; i < n; ++i) {\n            cout << arr[i] << " ";\n        }\n        cout << endl;\n        return ;\n    }\n    ~A() {\n        cout << "destructor" << endl;\n        delete[] arr;\n    }\n\nprivate:\n    int *arr, n;\n};\n\nint main() {\n    int n = 123;\n    //\u8d8a\u8fc7\u8be5\u884c\u4ee3\u7801,\u8fd8\u80fd\u5426\u76f8\u5173\u7684\u503c,\u80fd\u5de6\u503c,\u4e0d\u80fd\u53f3\u503c\n    cout << (n++) << endl; //\u53f3\u503c,\u7b80\u5355\u7406\u89e3:\u4e34\u65f6\u7684\u53d8\u91cf,\u4e0d\u53ef\u4ee5\u4fee\u6539\u7684\n    cout << (++n) << endl; //\u5de6\u503c,\u7b80\u5355\u7406\u89e3:\u53ef\u4ee5\u64cd\u4f5c\u7684\u53d8\u91cf,\u53ef\u5f15\u7528\n    //\u7ed3\u5408\u91cd\u8f7d++\u8fd0\u7b97\u7b26\u7406\u89e3\n    cout << (++n)++ << endl;\n    //cout << (n++)++ << endl;\n    cout << "++n ";\n    judge(++n);\n    cout << "n++ ";\n    judge(n++);\n    /*\n     * ++n 128 is left value\n     * int function 2 128 is left value\n     * n++ 128 is right value\n     * int function 2 128 is left value \n    */\n    //move\u5f3a\u5236\u53d8\u53f3\u503c\n    //forward\u53d8\u6210\u4efb\u610f\u7c7b\u578b\u7684\u503c\uff0c\u5411\u524d\u4f20\u9012\n    //\u4e3a\u4e86\u89e3\u51b3\u5b8c\u7f8e\u4f20\u503c\u8fc7\u7a0b\n    \n    A *p = new A();\n    A a = move(*p); //\u8282\u7ea6\u5f00\u8f9f\u5bf9\u8c61\u7a7a\u95f4,\u6df1\u62f7\u8d1d,\u76f4\u63a5\u79fb\u52a8\u76f8\u5173\u5b58\u50a8\u533a\u7684\u6307\u5411 O(n)->O(1)\n    delete p;\n    a.output();\n    return 0;\n}\n\n')),(0,r.kt)("h2",{id:"lambda"},"lambda"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"/*************************************************************************\n   > File Name: 16.lambda.cpp\n   > Author: hug\n   > Mail:   hug@haizeix.com\n   > Created Time: \u516d 11/ 9 20:12:26 2019\n ************************************************************************/\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nauto add = [](int a, int b) -> long long {\n    return a + b;\n};\n\nauto Data = [](int a, int b) {\n    return [=](auto func) {\n        return func(a, b);\n    };\n};\n\nauto First = [](int a, int b) {\n    return a;\n};\n\nauto Second = [](int a, int b) {\n    return b;\n};\n\nauto Add = [](int a, int b) {\n    return a + b;\n};\n\nauto Max = [](int a, int b) {\n    return max(a, b);\n};\n\nauto is_in = [](int a, int b) {\n    return [=](int x) {\n        return a <= x && x <= b;\n    };\n};\n\nauto OR = [](auto u, auto v) {\n    return [=](int x) {\n        return u(x) || v(x);\n    };\n};\n\nauto NOT = [](auto u) {\n    return [=](int x) {\n        return !u(x);\n    };\n};\n\nauto is_little = is_in('a', 'z');\nauto is_upper = is_in('A', 'Z');\nauto is_digit = is_in('0', '9');\nauto is_alpha = OR(is_little, is_upper);\nauto other = NOT(is_alpha);\n\nfunction<int()> Temp_Func() {\n    int a = 23;\n    return [=]() -> int {\n        return a;\n    };\n}\n\nint main() {\n    cout << is_little('A') << endl;\n    cout << is_little('a') << endl;\n    cout << is_alpha('a') << endl;\n    cout << is_alpha('A') << endl;\n    cout << other('A') << endl;\n    cout << other('9') << endl;\n    cout << add(2, 4) << endl;\n    auto func = Temp_Func();\n    cout << func() << endl;\n    auto a = Data(rand() % 1000, rand() % 1000);\n    cout << a(First) << endl;\n    cout << a(Second) << endl;\n    cout << a(Add) << endl;\n    cout << a(Max) << endl;\n    return 0;\n}\n")),(0,r.kt)("h2",{id:"1-const-\u5e38\u91cf\u7684\u5224\u522b\u51c6\u5219"},"1 const \u5e38\u91cf\u7684\u5224\u522b\u51c6\u5219"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\u53ea\u6709\u7528\u5b57\u9762\u91cf\u521d\u59cb\u5316\u7684 const \u5e38\u91cf\u624d\u4f1a\u8fdb\u5165\u7b26\u53f7\u8868"),(0,r.kt)("li",{parentName:"ul"},"\u4f7f\u7528\u5176\u4ed6\u53d8\u91cf\u521d\u59cb\u5316\u7684 const \u5e38\u91cf\u4ecd\u7136\u662f\u53ea\u8bfb\u53d8\u91cf"),(0,r.kt)("li",{parentName:"ul"},"\u88ab volatile \u4fee\u9970\u7684 const \u5e38\u91cf\u4e0d\u4f1a\u8fdb\u5165\u7b26\u53f7\u8868")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"\u300ac++primer\u300b\u91cc\u9762\u8bf4\u5728\u7c7b\u5916\u5b9a\u4e49\u548c\u521d\u59cb\u5316\u662f\u4fdd\u8bc1static\u6210\u5458\u53d8\u91cf\u53ea\u88ab\u5b9a\u4e49\u4e00\u6b21\u7684\u597d\u65b9\u6cd5\u3002 \u4f46\u4e3a\u4ec0\u4e48static const int\u5c31\u53ef\u4ee5\u5728\u7c7b\u91cc\u9762\u521d\u59cb\u5316\u5462\uff1f"),"\n",(0,r.kt)("strong",{parentName:"p"},"\u60f3\u8d77C\u4e2d\u4e00\u4e2a\u51fd\u6570\u91cc\u5b9a\u4e49\u4e00\u4e2astatic\u53d8\u91cf\u662f\u4e3a\u4e86\u4fdd\u8bc1\u53ea\u521d\u59cb\u5316\u4e00\u6b21\u3002")),(0,r.kt)("p",null,"\u201c\u7c7b\u7684\u9759\u6001\u6210\u5458\u5fc5\u987b\u5728\u7c7b\u5916\u521d\u59cb\u5316\u201d\u8fd9\u4e00\u8bed\u6cd5\u662f\u53d7\u7ee7\u627f\u81ea C \u7684\u7f16\u8bd1\u6a21\u578b\u6240\u9650\u3002\u5728 C \u7684\u7ecf\u5178\u60ef\u4f8b\u4e2d\uff0c\u5934\u6587\u4ef6\u4e2d\u53ea\u653e\u58f0\u660e\uff08\u5305\u62ec\u51fd\u6570\u58f0\u660e\u3001extern \u5f15\u5bfc\u7684\u5916\u90e8\u53d8\u91cf\u58f0\u660e\u7b49\uff09\uff0c\u4e0d\u653e\u5b9e\u73b0\uff08\u5305\u62ec\u5b9e\u73b0\u51fd\u6570\u7684\u51fd\u6570\u4f53\uff0c\u4ee5\u53ca\u53d8\u91cf\u7684\u521d\u59cb\u5316\u7b49\uff09\uff0c\u800c\u6e90\u6587\u4ef6\u4e2d\u7ed9\u51fa\u5b9e\u73b0\u3002\u6bcf\u4e2a\u6e90\u6587\u4ef6\u6784\u6210\u4e00\u4e2a\u57fa\u672c\u7684\u7f16\u8bd1\u5355\u5143\uff0c\u5404\u4e2a\u7f16\u8bd1\u5355\u5143\u4e4b\u95f4\u5728\u7f16\u8bd1\u65f6\u6ca1\u6709\u4efb\u4f55\u7684\u4fe1\u606f\u5171\u4eab\u3002"),(0,r.kt)("p",null,"\u4e3e\u4e2a\u6817\u5b50\uff0cb.c \u60f3\u7528\u5230 a.c \u4e2d\u7684\u51fd\u6570 void fun() / \u5168\u5c40\u53d8\u91cf\uff0c\u5b83\u53ef\u4ee5\u5728\u81ea\u5df1\u7684\u6587\u4ef6\u5f00\u5934\u5199\u4e0b\u58f0\u660e\u8bed\u53e5 void fun(); / extern int x; \u4f46\u662f\uff0c\u66f4\u4f73\u7684\u5b9e\u73b0\u65b9\u5f0f\u662f a \u6a21\u5757\u63d0\u4f9b\u4e00\u4e2a\u5934\u6587\u4ef6 a.h\uff0c\u5728\u91cc\u9762\u7ed9\u51fa\u672c\u6a21\u5757\u6240\u6709\u5bf9\u5916\u66b4\u9732\u7684\u51fd\u6570/\u5168\u5c40\u53d8\u91cf\u7684\u58f0\u660e\uff0c\u7ed9 b.c \u53bb include\u3002\u4f46\u662f\uff0c\u5982\u679c b.c \u65e2\u4e0d\u662f\u81ea\u5df1\u5199\u58f0\u660e\u8bed\u53e5\uff0c\u4e5f\u4e0d include \u522b\u7684\u5934\u6587\u4ef6\u91cc\u5199\u7684\u58f0\u660e\u8bed\u53e5\uff0c\u800c\u662f\u5728\u81ea\u5df1\u5185\u90e8\u5199\u51fa void fun \u7684\u51fd\u6570\u4f53\uff0c\u6216\u8005\u662f int x; \u6216\u8005 int x = 0; \u8fd9\u79cd\u5b9a\u4e49\u8bed\u53e5\uff0c\u90a3\u4e48\uff0c\u5c3d\u7ba1 b.c \u5728\u88ab\u7f16\u8bd1\u4e3a b.o \u7684\u8fc7\u7a0b\u4e2d\u4e0d\u4f1a\u51fa\u7f16\u8bd1\u9519\u8bef\uff0c\u4f46\u662f\u5728 b.o \u4e0e a.o \u94fe\u63a5\u65f6\uff0c\u5c31\u4f1a\u51fa\u73b0\u7b26\u53f7\u51b2\u7a81\u3002"),(0,r.kt)("h2",{id:"constexpr"},"constexpr"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"constexpr int f(int i) {\n    return 2 * i;\n}\n\nstruct A {\n    constexpr A(int x, int y) : x(x), y(y) {}\n    int x, y;\n};\n\nint main() {\n    int n;\n    cin >> n;\n    const int a = n + 3;\n    constexpr int b = f(123) + 567;\n    cout << f(n) << endl;\n    constexpr A c(2, 3);\n    A d(n, 4);\n    return 0;\n}\n")),(0,r.kt)("h2",{id:"nullptr"},"nullptr"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"void f(int x) {\n    cout << x << endl;\n    return ;\n}\n\nvoid f(int *p) {\n    cout << p << endl;\n    return ;\n}\n\nint main() {\n    int n = 123;\n    f(n);\n    f(&n);\n    f(nullptr);\n    return 0;\n}\n")),(0,r.kt)("h2",{id:"auto\u548c\u968f\u673a\u79cd\u5b50\u539f\u7406"},"auto\u548c\u968f\u673a\u79cd\u5b50\u539f\u7406"),(0,r.kt)("p",null,"\u8ba1\u7b97\u673a\u65f6\u95f4\u662f\u53d8\u91cf\uff0c\u6bcf\u6b21\u7a0b\u5e8f\u8fd0\u884c\u90fd\u4e00\u5b9a\u4e0d\u540c\uff0c\u4f5c\u4e3a\u968f\u673a\u79cd\u5b50\uff0c\u786e\u5b9a\u968f\u673a\u5e8f\u5217\u521d\u59cb\u503c"),(0,r.kt)("p",null,"\u968f\u673a\u51fd\u6570\u66f4\u52a0\u590d\u6742\uff0c\u4f46\u4e5f\u662f\u4e00\u7cfb\u5217\u516c\u5f0f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'string randstring(int n) {\n    string ret = "";\n    for (int i =0; i < n; i++) {\n        char ch = rand() % 26 + \'A\';\n        ret += ch;\n    }\n    return ret;\n}\n\nint my_seed = 1;\nvoid my_srand(int seed) {\n    my_seed = seed;\n}\n\nint my_rand() {\n    my_seed = my_seed * 3 % 101;\n    return my_seed;\n}\n\nint main() {\n    my_srand(time(0));\n    for (int i = 0; i < 100; i++) {\n        cout << my_rand() << endl;\n    }\n    srand(time(0));\n    map<string, int> ind;\n    for (int i = 0; i < 10; i++) {\n        ind[randstring(rand() % 10 + 3)] = rand();\n    }\n    auto iter = ind.begin();\n    for (; iter != ind.end(); iter++) {\n        cout << iter->first << " " << iter->second << endl;\n    }\n    for (auto x : ind) {\n        cout << x.first << " " << x.second << endl;\n    }\n    return 0;\n} \n')),(0,r.kt)("h2",{id:"hash_table"},"hash_table"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <cmath>\n#include "9.hash_table.h"\nusing namespace std;\n\nnamespace haizei {\n    template<typename T, typename U>\n    struct pair {\n        pair() : first(), second() {}\n        pair(const T &a) : first(a), second() {}\n        pair(const T &a, const U &b) : first(a), second(b) {}\n        T first;\n        U second;\n    };\n    template<typename K> struct hash;\n    template<>\n    struct hash<int> {\n        size_t operator()(int x) {\n            return x;\n        }\n    };\n    \n    template<>\n    struct hash<double> {\n        size_t operator()(double x) {\n            return *((size_t *)(&x));\n        }\n    };\n\n    template<typename K, typename T, typename HashT = haizei::hash<K>>\n    class unordered_map {\n    public:\n        unordered_map(size_t size = 100) : size(size) {\n            this->data = new pair<K, T> *[size];\n            this->map = new bool[size];\n            for (int i = 0; i < size; i++) {\n                this->data[i] = nullptr;\n                this->map[i] = false;\n            }\n        }\n        T &operator[](const K &a) {\n            size_t ind;\n            T *value = this->find(a, ind);\n            if (ind == -1) return *this->end();\n            if (value == this->end()) {\n                this->data[ind] = new pair<K, T>(a);\n                this->map[ind] = true;\n            }\n            return this->data[ind]->second;\n        }\n        T *end() { return (T *)(0); }\n        T *find(const K &a, size_t &ind) {\n            ind = hash_func(a);\n            ind %= this->size;\n            size_t times = 1;\n            while (this->map[ind] && !(this->data[ind]->first == a)) {\n                ind += times * times;\n                ind %= this->size;\n                times += 1;\n                if (times == this->size) {\n                    ind = -1;\n                    return this->end();\n                }\n            }\n            if (this->map[ind]) return &(this->data[ind]->second);\n            return this->end();\n        }\n    private:\n        size_t size;\n        pair<K, T> **data;\n        bool *map;\n        HashT hash_func;\n    };\n}\nstruct A {\n    A(int x, int y) : x(x), y(y) {}\n    int x, y;\n    bool operator==(A const &a) const {\n        return this->x == a.x && this->y == a.y;\n    }\n};\n\nstruct myhash {\n    int operator()(A const &a) const {\n        return a.x + a.y;\n    }\n};\n\nint main() {\n    A a(0, 9), b(10, 12);\n    unordered_map<A, int, myhash> arr;\n    arr[a] = 1;\n    arr[b] = 2;\n    cout << arr[a] << endl;\n    cout << arr[b] << endl;\n    haizei::unordered_map<int, int> arr2;\n    arr2[129883] = 65;\n    arr2[623] = 23;\n    cout << arr2[129883] << endl;\n    cout << arr2[623] << endl;\n\n    haizei::unordered_map<A, int, myhash> arr3;\n    arr3[a] = 1;\n    arr3[b] = 2;\n    cout << arr3[a] << endl;\n    cout << arr3[b] << endl;\n    return 0;\n}\n\n')),(0,r.kt)("h2",{id:"\u4e8c\u53c9\u6392\u5e8f\u6811"},"\u4e8c\u53c9\u6392\u5e8f\u6811"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'#ifndef _BSTREE_H\n#define _BSTREE_H\n\n#include <memory>\n#include <iostream>\n\nnamespace haizei {\n\ntemplate<typename T>\nclass BSNode {\npublic :\n    BSNode(const T &data) \n    : data(data), lchild(nullptr), rchild(nullptr), father() {\n        std::cout << "Node constuctor" << std::endl;\n    }\n    bool operator<(const BSNode<T> &obj) {\n        return this->data < obj.data;\n    }\n    bool operator>(const BSNode<T> &obj) {\n        return obj.data < this->data;\n    }\n    bool operator!=(const BSNode<T> &obj) {\n        return (this->data < obj.data) || (obj.data < this->data);\n    }\n    bool operator==(const BSNode<T> &obj) {\n        return !(*this != obj);\n    }\n    std::weak_ptr<BSNode<T> > father;\n    std::shared_ptr<BSNode<T>> lchild, rchild;\n    ~BSNode() {\n        std::cout << "destructor" << std::endl;\n    }\n    T data;\n};\n\ntemplate<typename T>\nclass BSTree_helper {\npublic :\n    static std::shared_ptr<BSNode<T> > get_next(std::shared_ptr<BSNode<T> > p) {\n        if (p->rchild != nullptr) {\n            p = p->rchild;\n            while (p->lchild != nullptr) p = p->lchild;\n            return p;\n        }\n        while (p->father.lock() != nullptr && p->father.lock()->rchild == p) p = p->father.lock();\n        if (p->father.lock() == nullptr) return p;\n        return p->father.lock();\n    }\n};\n\ntemplate<typename T>\nclass BSTree_iterator {\n    using helper = BSTree_helper<T>;\npublic :\n    BSTree_iterator() : node(nullptr) {}\n    BSTree_iterator(std::shared_ptr<BSNode<T> > node) : node(node) {}\n    BSTree_iterator<T> &operator++() {\n        node = helper::get_next(node);\n        return *this;\n    }\n    BSTree_iterator<T> operator++(int) {\n        BSTree_iterator iter(*this);\n        node = helper::get_next(node);\n        return iter;\n    }\n    bool operator==(const BSTree_iterator<T> &iter) {\n        return this->node == iter.node;\n    }\n    bool operator!=(const BSTree_iterator<T> &iter) {\n        return this->node != iter.node;\n    }\n    T &operator*() {\n        return node->data;\n    }\n\nprivate:\n    std::shared_ptr<BSNode<T> > node;\n};\n\ntemplate<typename T>\nstruct BSTree {\npublic :\n    typedef BSTree_iterator<T> iterator;\n    BSTree() : root(std::make_shared<BSNode<T> >(T())) {}\n    void insert(const T &data) {\n        std::shared_ptr<BSNode<T> > p = this->root;\n        std::shared_ptr<BSNode<T> > new_node = std::make_shared<BSNode<T> >(data);\n        if (p->lchild == nullptr) {\n            p->lchild = new_node;\n            new_node->father = p;\n            return ;\n        }\n        p = p->lchild;\n        while (*p != *new_node) {\n            if (*p > *new_node) {\n                if (p->lchild == nullptr) {\n                    p->lchild = new_node;\n                    new_node->father = p;\n                    break;\n                }\n                p = p->lchild;\n            } else {\n                if (p->rchild == nullptr) {\n                    p->rchild = new_node;\n                    new_node->father = p;\n                    break;\n                }\n                p = p->rchild;\n            }\n        }\n        return ;\n    }\n    iterator begin() {\n        if (root->lchild == nullptr) return iterator(root);\n        return iterator(root->lchild);\n    }\n    iterator end() {\n        return iterator(root);\n    }\n\nprivate:\n    std::shared_ptr<BSNode<T> > root;\n};\n\n}\n\n#endif\n')),(0,r.kt)("h2",{id:"bind"},"bind"),(0,r.kt)("p",null,"\u9ad8\u7aef\u5e93,\u591a\u7ebf\u7a0b,\u7f51\u7edc\u6a21\u5757\u5e93;"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'void func(int x, int y, int z) {\n    cout << x + y << " is a number" << endl;\n    cout << z << " is a number" << endl;\n}\n\nstruct A {\n    void say() {\n        cout << this << " : saying" << endl;\n    }\n    void run() {\n        cout << "hello world" << endl;\n    }\n};\n\nvoid count_function_times(function<void()> &p, int &cnt) {\n    p();\n    cnt += 1;\n    return ;\n}\n\nint main() {\n    function<void(int, int)> f1 = bind(func, 123, std::placeholders::_2, std::placeholders::_1);\n    f1(100, 456);\n    f1(200, 789);\n    A a;\n    cout << &a << endl;\n    function<void()> f2 = bind(&A::say, ref(a));\n    f2();\n    int cnt = 0;\n    function<void()> f3 = bind(&A::run, ref(a));\n    function<void()> f4 = bind(count_function_times, ref(f3), ref(cnt));\n    for (int i = 0; i < rand() % 10; i++) f4();\n    cout << cnt << endl;\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u6a21\u677f\u7684\u56fe\u7075\u5b8c\u5907\u6027"},"\u6a21\u677f\u7684\u56fe\u7075\u5b8c\u5907\u6027"),(0,r.kt)("p",null,"\u6a21\u677f\u662f\u7f16\u8bd1\u671f\u4e4b\u524d\uff0c\u53ef\u7406\u89e3\u4e3a\u7f16\u8bd1\u671f\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template<int x>\nstruct IsOdd {\n    constexpr static int r = x % 2;\n};\n\ntemplate<int i, int x>\nstruct getNextK {\n    constexpr static int r = (i * i > x ? 0 : (x % i == 0 ? 1 : 2));\n};\n\ntemplate<int i, int x, int k>\nstruct Test {\n    constexpr static int r = Test<i + 1, x, getNextK<i, x>::r >::r;\n};\n\ntemplate<int i, int x>\nstruct Test<i, x, 0> {\n    constexpr static int r = 1;\n};\n\ntemplate<int i, int x>\nstruct Test<i, x, 1> {\n    constexpr static int r = 0;\n};\n\ntemplate<int x>\nstruct is_prime {\n    constexpr static int r = Test<2, x, 2>::r;\n};\n\ntemplate<int i, int x>\nstruct getNextK2 {\n    constexpr static int r = (i > x ? 0 : 1);\n};\n\ntemplate<int i, int x, int k>\nstruct __calc_count_prime {\n    constexpr static int r = i * is_prime<i>::r + __calc_count_prime<i + 1, x, getNextK2<i + 1, x>::r >::r;\n};\n\ntemplate<int i, int x>\nstruct __calc_count_prime<i, x, 0> {\n    constexpr static int r = 0;\n};\n\ntemplate<int x>\nstruct count_prime {\n    constexpr static int r = __calc_count_prime<2, x, 1>::r;\n};\n\ntemplate<int i, int x, int k>\nstruct __calc_count_odd {\n    constexpr static int r = i * IsOdd<i>::r + __calc_count_odd<i + 1, x, getNextK2<i + 1, x>::r >::r;\n};\n\ntemplate<int i, int x>\nstruct __calc_count_odd<i, x, 0> {\n    constexpr static int r = 0;\n};\n\ntemplate<int x>\nstruct count_odd {\n    constexpr static int r = __calc_count_odd<1, x, 1>::r;\n};\n\ntemplate<int x>\nstruct print_prime {\n    template<int i, int k>\n    struct __output {\n        static void run() {\n            if (is_prime<i>::r) {\n                cout << i << endl;\n            }\n            print_prime<x>::__output<i + 1, getNextK2<i + 1, x>::r >::run();\n        }\n    };\n    template<int i>\n    struct __output<i, 0> {\n        static void run() {\n            return ;\n        }\n    };\n    static void output() {\n        print_prime<x>::__output<2, 1>::run();\n        return ;\n    }\n};\n\ntemplate<int x, int k>\nstruct __get_next_prime {\n    constexpr static int r = __get_next_prime<x + 1, is_prime<x + 1>::r >::r;\n};\n\ntemplate<int x>\nstruct __get_next_prime<x, 1> {\n    constexpr static int r = x;\n};\n\ntemplate<int x>\nstruct get_next_prime {\n    constexpr static int r = __get_next_prime<x + 1, is_prime<x + 1>::r >::r;\n};\n\ntemplate<int n>\nstruct print_trangle {\n    template<int i, int m, int k>\n    struct __output_line {\n        static void run() {\n            cout << "-";\n            __output_line<i + 1, m, getNextK2<i + 1, m>::r >::run();\n        }\n    };\n    template<int i, int m>\n    struct __output_line<i, m, 0> {\n        static void run() {\n            cout << endl;\n        }\n    };\n    template<int i, int k>\n    struct __output {\n        static void run() {\n            __output_line<1, i, 1>::run();\n            __output<i + 1, getNextK2<i + 1, n>::r >::run();\n        }\n    };\n    template<int i>\n    struct __output<i, 0> {\n        static void run() {\n            return ;\n        }\n    };\n    \n    static void output() {\n        __output<1, 1>::run();\n    }\n};\n\nint main() {\n    cout << IsOdd<5>::r << endl;\n    cout << IsOdd<6>::r << endl;\n    cout << is_prime<9973>::r << endl;\n    cout << is_prime<10000>::r << endl;\n    cout << count_prime<100>::r << endl;\n    cout << count_prime<10>::r << endl;\n    cout << count_odd<10>::r << endl;\n    print_prime<100>::output();\n    cout << get_next_prime<5>::r << endl; \n    cout << get_next_prime<12>::r << endl;\n    print_trangle<4>::output(); \n    print_trangle<6>::output(); \n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u5f15\u7528\u6298\u53e0"},"\u5f15\u7528\u6298\u53e0"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210321223517051",src:e(68146).Z})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template<typename T>\nvoid my_swap(T &&a, T &&b) {\n    typename remove_reference<T>::type c;\n    c = a;\n    a = b;\n    b = c;\n    return ;\n}\n\ntemplate<typename T>\nvoid add(T &&a, T &&b) {\n    a += 3;\n    b += 4;\n    return ;\n}\n\nvoid func(void (*p)(int &, int &), int &a, int &b) {\n    p(a, b);\n    return ;\n}\n\ntemplate<typename T>\ntypename remove_reference<T>::type &&my_move(T &&a) {\n    return static_cast<typename remove_reference<T>::type &&>(a);\n}\n\ntemplate<typename T> \nstruct my_remove_reference {\n    typedef T type;  \n};\n\ntemplate<typename T> \nstruct my_remove_reference<T &> {\n    typedef T type;  \n};\n\ntemplate<typename T> \nstruct my_remove_reference<T &&> {\n    typedef T type; \n};\n\nvoid func(int &a) {\n    cout << "left value" << endl;\n}\n\nvoid func(int &&a) {\n    cout << "right value" << endl;\n}\n\nint main() {\n    int a = 123, b = 456;\n    cout << a << " " << b << endl;\n    my_swap(a, b);\n    cout << a << " " << b << endl;\n    my_swap(move(a), move(b));\n    cout << a << " " << b << endl;\n    func(add, a, b);\n    cout << a << " " << b << endl;\n    my_swap(my_move(a), my_move(b));\n    func(a);\n    func(my_move(a));\n    typename my_remove_reference<int>::type c;\n    typename my_remove_reference<int &>::type d;\n    typename my_remove_reference<int &&>::type e;\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u53f3\u503c"},"\u53f3\u503c"),(0,r.kt)("h2",{id:"\u53ef\u53d8\u53c2\u6570\u6a21\u677f"},"\u53ef\u53d8\u53c2\u6570\u6a21\u677f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template<typename T>\nvoid print(const T &a) {\n    cout << a << endl;\n}\n\ntemplate<typename T, typename ...ARGS>\nvoid print(const T &a, ARGS ...args) {\n    cout << a << " ";\n    print(args...);\n    return ;\n}\n\ntemplate<int n, typename T, typename ...ARGS>\nstruct ARG {\n    typedef typename ARG<n - 1, ARGS...>::getT getT;\n    typedef ARG<n - 1, ARGS...> N;\n};\n\ntemplate<typename T, typename ...ARGS>\nstruct ARG<0, T, ARGS...> {\n    typedef T getT;\n};\n\ntemplate<typename T>\nstruct ARG<0, T> {\n    typedef T getT;\n    typedef T finalT;\n};\n\ntemplate<typename T, typename ...ARGS> class Test;\ntemplate<typename T, typename ...ARGS>\nclass Test<T(ARGS...)> {\npublic :\n    T operator()(typename ARG<0, ARGS...>::getT a, typename ARG<1, ARGS...>::N::finalT b) {\n        return a + b;\n    }\n};\n\nint main() {\n    print(123, 23.5, "hello world", \'o\');\n    Test<int(double, float)> d;\n    cout << d(2.3, 4.5) << endl;\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u53ef\u53d8\u53c21"},"\u53ef\u53d8\u53c21"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"image-20210321202920432",src:e(44231).Z})),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template<typename T, typename ...ARGS>\nstruct ARG {\n    typedef T getT;  \n    typedef ARG<ARGS...> rest;\n};\n\ntemplate<typename T>\nstruct ARG<T> {\n    typedef T getT;\n    typedef T finalT;\n};\n\ntemplate<typename T, typename ...ARGS> class Test; //\u504f\u7279\u5316\u7248\u672c\ntemplate<typename T, typename ...ARGS> \nclass Test<T(ARGS...)> {\n//template<typename T, typename ...ARGS>\n//class Test {\n//    Test<int, double, float> d;\npublic :\n    T operator()(typename ARG<ARGS...>::getT a, typename ARG<ARGS...>::rest::finalT b) {\n        return a + b;\n    }\n};\n\nint main(){\n    print(123, "hello world", 78.9, \'0\');\n    cout << sizeof(ARG<int,double, char>::getT) << endl;\n    cout << sizeof(ARG<int,double, char>::rest::getT) << endl;\n    cout << sizeof(ARG<int,double, char>::rest::rest::getT) << endl;\n    ARG<int, double, char>::getT a = 1;\n    ARG<int, double, char>::rest::getT b = 1.112;\n    ARG<int, double, char>::rest::rest::getT c = \'a\';\n    cout << a << " " << b << " " << c << endl;\n//    Test<int, double, float> d;\n    Test<int(double, float)> d;\n    //Test<int(double, float, char)> e;\n    //Test<int(double)> f;\n    //ARG<int, double, double, float, int>::rest::rest::rest::rest::getT g;\n    //ARG<4, int, double, int, int, int>\n    cout << d(2.3, 4.5) << endl;\n    return 0;\n}\n\n')),(0,r.kt)("p",null,"\u5bf9\u8c61\u6587\u4ef6\uff1a\u5b58\u51fd\u6570\u4ee3\u7801\uff0c\u6a21\u677f\u4e0d\u51fa\u73b0\u5728\u5bf9\u8c61\u6587\u4ef6\u4e2d"),(0,r.kt)("p",null,"\u6a21\u677f\u4f1a\u81ea\u52a8\u63a8\u5bfc\u53c2\u6570\u7c7b\u578b\uff0c\u8fdb\u884c\u5b9e\u4f8b\u5316\uff0c\u5728\u7f16\u8bd1\u4e4b\u524d\u3002"),(0,r.kt)("h2",{id:"\u6a21\u677farray"},"\u6a21\u677fArray"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'template<typename T, typename ...ARGS>\nstruct ARG {\n    typedef T getT;  \n    typedef ARG<ARGS...> rest;\n};\n\ntemplate<typename T>\nstruct ARG<T> {\n    typedef T getT;\n    typedef T finalT;\n};\n\ntemplate<typename T, typename ...ARGS> class Test; //\u504f\u7279\u5316\u7248\u672c\ntemplate<typename T, typename ...ARGS> \nclass Test<T(ARGS...)> {\n//template<typename T, typename ...ARGS>\n//class Test {\n//    Test<int, double, float> d;\npublic :\n    T operator()(typename ARG<ARGS...>::getT a, typename ARG<ARGS...>::rest::finalT b) {\n        return a + b;\n    }\n};\n\nint main(){\n    print(123, "hello world", 78.9, \'0\');\n    cout << sizeof(ARG<int,double, char>::getT) << endl;\n    cout << sizeof(ARG<int,double, char>::rest::getT) << endl;\n    cout << sizeof(ARG<int,double, char>::rest::rest::getT) << endl;\n    ARG<int, double, char>::getT a = 1;\n    ARG<int, double, char>::rest::getT b = 1.112;\n    ARG<int, double, char>::rest::rest::getT c = \'a\';\n    cout << a << " " << b << " " << c << endl;\n//    Test<int, double, float> d;\n    Test<int(double, float)> d;\n    //Test<int(double, float, char)> e;\n    //Test<int(double)> f;\n    //ARG<int, double, double, float, int>::rest::rest::rest::rest::getT g;\n    //ARG<4, int, double, int, int, int>\n    cout << d(2.3, 4.5) << endl;\n    return 0;\n}\n\n')),(0,r.kt)("h2",{id:"\u54c8\u5e0c\u51fd\u6570"},"\u54c8\u5e0c\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class Node {\npublic :\n    Node() : flag(false), str(nullptr) {}\n    void clear() {\n        this->flag = false;\n        if (this->str) free(this->str);\n        this->str = nullptr;\n        return ;\n    }\n    void insert(const char *str) {\n        this->clear();\n        this->flag = true;\n        this->str = strdup(str);\n        return ;\n    }\n    bool empty() { return this->flag == false; }\n    bool operator!=(const char *str) {\n        if (this->str == nullptr) return true;\n        return strcmp(this->str, str) != 0;\n    }\n    bool operator==(const char *str) {\n        return !((*this) != str);\n    }\n    ~Node() {\n        if (this->str) free(this->str);\n        this->str = nullptr;\n    }\nprivate :\n    bool flag;\n    char *str;\n};\n\nclass HashFunc {\npublic :\n    virtual int operator()(const char *str) const = 0;\n};\n\nclass HashTable {\npublic :\n    typedef function<int(const char *)> HashFunc_T;\n    HashTable(HashFunc_T func);\n    bool insert(const char *str);\n    bool find(const char *str);\n    ~HashTable();\nprivate:\n    Node &find_position(const char *str);\n    int _size;\n    Node *data;\n    HashFunc_T p_func;\n};\n\nclass BKDRHash : public HashFunc {\npublic :\n    int operator()(const char *str) const {\n        int seed = 31;\n        int hash_value = 0;\n        for (int i = 0; str[i]; i++) {\n            hash_value = hash_value * seed + str[i];\n        }\n        return hash_value & 0x7fffffff;\n    }\n};\n\nint APHash(const char *str) {\n    int hash = 0;\n    for (int i = 0; str[i]; i++) {\n        if (i % 2) {\n            hash = (hash << 3) ^ str[i] ^ (hash >> 5);\n        } else {\n            hash = ~((hash << 7) ^ str[i] ^ (hash >> 11));\n        }\n    }\n    return hash & 0x7fffffff;\n}\n\nint main() {\n    BKDRHash bkdr_func;\n    HashTable h1(bkdr_func), h2(APHash);\n    int op;\n    char str[100];\n    while (cin >> op >> str) {\n        switch (op) {\n            case 0: {\n                cout << "insert " << str << " to hash table 1= ";\n                cout << h1.insert(str) << endl;\n                cout << "insert " << str << " to hash table 2= ";\n                cout << h2.insert(str) << endl;\n            } break;\n            case 1: {\n                cout << "search " << str << " from hash table 1= ";\n                cout << h1.find(str) << endl;\n                cout << "search " << str << " from hash table 2= ";\n                cout << h2.find(str) << endl;\n            } break;\n        }\n    }\n    return 0;\n}\n\nHashTable::HashTable(HashFunc_T func) : p_func(func) {\n    this->_size = 100;\n    this->data = new Node[this->_size];\n}\n\nbool HashTable::insert(const char *str) {\n    Node &d = find_position(str);\n    if (!d.empty()) return false;\n    d.insert(str);\n    return true;\n}\n\nbool HashTable::find(const char *str) {\n    Node &d = find_position(str);\n    return !d.empty();\n}\n\nNode &HashTable::find_position(const char *str) {\n    int ind = p_func(str) % this->_size;\n    int times = 1;\n    while (!data[ind].empty() && data[ind] != str) {\n        ind += times * times;\n        ind %= this->_size;\n    }\n    return data[ind];\n}\n\nHashTable::~HashTable() {\n    delete[] this->data;\n}\n')),(0,r.kt)("p",null,"\u63a5\u53e3\u7684\u7406\u89e3:\u5b9a\u4e49\u4e86\u63a5\u53e3\u7684\u5f62\u72b6,\u4f46\u8fde\u63a5\u63a5\u53e3\u7684\u5de5\u5177\u4e0d\u786e\u5b9a"),(0,r.kt)("h2",{id:"array\u7ec3\u4e60"},"Array\u7ec3\u4e60"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class IntArray {\npublic :\n    IntArray(int n) : n(n) {\n        this->arr = new int[n];\n    }\n    IntArray(const IntArray &obj) : n(obj.n) {\n        this->arr = new int[n];\n        for (int i = 0; i < n; i++) {\n            this->arr[i] = obj.arr[i];\n        }\n    }\n    int &operator[](int ind) {\n        if (ind >= 0) {\n            return this->arr[ind];\n        }\n        return this->arr[n + ind];\n    }\n    void operator+=(int x) {\n        for (int i = 0; i < n; i++) {\n            this->arr[i] += x;\n        }\n        return ;\n    }\n    IntArray &operator++() {\n        for (int i = 0; i < n; i++) {\n            this->arr[i] += 1;\n        }\n        return *this;\n    }\n    IntArray operator++(int x) {\n        IntArray ret = (*this);\n        for (int i = 0; i < n; i++) {\n            this->arr[i] += 1;\n        }\n        return ret;\n    }\n    ~IntArray() {\n        delete[] this->arr;\n    }\n    friend ostream &operator<<(ostream &, const IntArray &);\nprivate :\n    int *arr, n;\n};\n\nostream &operator<<(ostream &out, const IntArray &a) {\n    out << "<Class IntArray> : ";\n    for (int i = 0; i < a.n; i++) {\n        out << a.arr[i] << " ";\n    }\n    return out;\n}\n\nint main() {\n    srand(time(0));\n    IntArray a(10);\n    for (int i = 0; i < 10; i++) {\n        a[i] = rand() % 100;\n    }\n    cout << a[4] << endl;\n    cout << a[-2] << endl; // \u8f93\u51fa\u5012\u6570\u7b2c 2 \u4f4d\u7684\u503c\n    cout << a << endl; // \u8f93\u51fa\u6574\u4e2a\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\n    a += 5; // \u7ed9\u6570\u7ec4\u4e2d\u6240\u6709\u5143\u7d20\u90fd\u52a05\n    cout << a << endl; // \u8f93\u51fa\u6574\u4e2a\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\n    cout << (a++) << endl; // \u7ed9\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u90fd\u52a0 1\n    cout << (++a) << endl; // \u7ed9\u6570\u7ec4\u4e2d\u7684\u6240\u6709\u5143\u7d20\u90fd\u52a0 1\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u865a\u51fd\u6570\u8868"},"\u865a\u51fd\u6570\u8868"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'class Animal {\npublic :\n    Animal() {\n        x = 8827, y = 65123;\n    }\n    virtual void say(int x) {\n        cout << "I don\'t know how to say" << endl;\n    }\n    virtual void run() {\n        cout << "I don\'t know how to run" << endl;\n    }\nprotected :\n    int x, y;\n};\n\nclass Cat : public Animal {\npublic :\n    void say(int x) override {\n        cout << this << endl;\n        cout << this->x  << " " << this->y << endl;\n        cout << x << endl;\n        cout << "miao~ miao~ miao~" << endl;\n    }\n    void run() override {\n        cout << "I can run with four legs" << endl;\n    }\n};\n\nvoid output_raw_data(void *q, int n) {\n    printf("%p : ", q);\n    unsigned char *p = (unsigned char *)q;\n    for (int i = 0; i < n; i++) {\n        printf("%02X ", p[i]);\n    }\n    printf("\\n");\n    return ;\n}\n\ntypedef void (*func)(void *, int x);\n\nint main() {\n    Cat a, b;\n    output_raw_data(&a, sizeof(a));\n    output_raw_data(&b, sizeof(b));\n    ((func **)(&a))[0][0](&a, 123);\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u865a\u51fd\u6570"},"\u865a\u51fd\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'string rand_name(int n) {\n    string name = "";\n    for (int i = 0; i < n; i++) {\n        name = name + (char)(rand() % 26 + \'A\');\n    }\n    return name;\n}\n\nclass Animal {\npublic :\n    Animal(string name) : name(name) {}\n    string tell_me_your_name() { return this->name; }\n    virtual void run() {\n        cout << "I don\'t know how to run" << endl;\n    }\n    virtual void say() = 0;\n    virtual void func0() {}\n    virtual ~Animal() {\n        cout << "Animal destructor" << endl;\n    }\nprivate :\n    string name;\n};\n\nclass Cat : public Animal {\npublic :\n    Cat() : Animal(rand_name(5) + " Cat") {}\n    void run() override {\n        cout << "I can run with four legs" << endl;\n    }\n    void func0() override {\n        cout << "this is funco" << endl;\n    }\n    void say() override {\n        cout << "miao~ miao~ miao~" << endl;\n    }\n    ~Cat() {\n        cout << "Cat destructor" << endl;\n    }\n};\n\nclass Bat : public Animal {\npublic :\n    Bat() : Animal(rand_name(5) + " Bat") {}\n    void run() override {\n        cout << "I can fly" << endl;\n    }\n    void say() override {\n        cout << "zzz~ zzz~ zzz~" << endl;\n    }\n    ~Bat() {\n        cout << "Bat destructor" << endl;\n    }\n};\n\nint main() {\n    Cat a;\n    Bat b;\n    cout << a.tell_me_your_name() << endl;\n    a.run();\n    cout << b.tell_me_your_name() << endl;\n    b.run();\n    Animal ** arr = new Animal*[10];\n    for (int i = 0; i < 10; i++) {\n        if (rand() % 2) {\n            arr[i] = new Cat();\n        } else {\n            arr[i] = new Bat();\n        }\n    }\n    for (int i = 0; i < 10; i++) {\n        cout << arr[i]->tell_me_your_name() << endl;\n        arr[i]->run();\n        arr[i]->say();\n    }\n    for (int i = 0; i < 10; i++) {\n        delete arr[i];\n    }\n    delete[] arr;\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"cout\u7b80\u7248\u5b9e\u73b0"},"cout\u7b80\u7248\u5b9e\u73b0"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'namespace haizei {\n    class ostream {\n    public :\n        ostream &operator<<(int x) {\n            printf("%d", x);\n            return *this;\n        }\n        ostream &operator<<(const std::string &str) {\n            printf("%s", str.c_str());\n            return *this;\n        }\n        ostream &operator<<(const char &ch) {\n            printf("%c", ch);\n            return *this;\n        }\n        ostream &operator<<(const double &a) {\n            printf("%g", a);\n            return *this;\n        }\n        //\u6d88\u9664\u540e0\n          ostream &operator<<(const double &a) {\n            char e_str[20];\n            int e_num, temp;\n            sprintf(e_str, "%.5e", a);\n            scanf(e_str, "%d.%de%d", &temp, &temp, &e_num);\n            if (e_num >= 6 || e_num <= -5) {\n                printf("%s", e_str);\n            } else {\n                temp = 5 - e_num;\n                sprintf(e_str, "%%.%dlf", temp);\n                printf(e_str, a);\n            }\n            return *this;\n        }\n\n    };\n    char endl = \'\\n\';\n    ostream cout;\n}\n\nint main() {\n    haizei::cout << "hello world" << haizei::endl;\n    haizei::cout << 123 << haizei::endl;\n    haizei::cout << 123.567 << haizei::endl;\n    haizei::cout << 123.56 << haizei::endl;\n    haizei::cout << 123. << 123. <<  haizei::endl;\n    std::cout << 123. << 123. <<  std::endl;\n    haizei::cout << 123.78787878 << haizei::endl;\n    haizei::cout << 3.78787878 << haizei::endl;\n    double a = 3787878787878780.;\n    for (int i = 0; i < 20; i++) {\n        a /= 10;\n        haizei::cout << i << " " << a << haizei::endl;\n    }\n    printf("%lf\\n", 123.567);\n    printf("%lf\\n", 123.56);\n    printf("%lf\\n", 123.);\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u7ee7\u627f"},"\u7ee7\u627f"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'define P_ADD(obj, a) cout << #obj "." #a " = " << &(obj.a)\n\nclass Animal {\npublic:\n    Animal(string name) : __name(name) {\n        cout << "Animal constructor " << this << endl;\n    }\n    string name() { return this->__name; }\n\n    int x, y;\n    string __name;\n    ~Animal() {\n        cout << "Animal destructor " << this << endl;\n    }\n};\n\nclass Cat : public Animal {\npublic :\n    Cat() : Animal("hello kitty") {\n        arr = new int[100];\n        cout << "Cat constructor " << this << endl;\n    }\n    void say() {\n        cout << "my name is " << this->name() << endl;\n    }\n    int z;\n    int *arr;\n    ~Cat() {\n        delete[] arr;\n        cout << "Cat destructor " << this << endl;\n    }\n};\n\nostream &operator<<(ostream &out, const Animal &a) {\n    out << "<class Animal> " << &a << endl;\n    P_ADD(a, x) << endl;\n    P_ADD(a, y) << endl;\n    P_ADD(a, __name) << endl;\n    return out;\n}\n')),(0,r.kt)("h2",{id:"\u6790\u6784"},"\u6790\u6784"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},'struct A {\n    A() : next(nullptr) {\n        cout << this << " default constructor" << endl;\n    }\n    A(A *obj) {\n        this->next = obj;\n        this->next->arr = new int[1000];\n    }\n    A(int n) : next(nullptr) {\n        cout << this << " an int constructor" << endl;\n        x = n, y = n;\n    }\n    A(const A &obj) : next(nullptr) {\n        cout << this << " copy constructor" << endl;\n        this->x = obj.x, this->y = obj.y;\n    }\n    void output() {\n        cout << this->x << " " << this->y << endl;\n    }\n    int x, y;\n    int *arr;\n    A *next;\n    ~A() {\n        if (this->next) {\n            delete this->next->arr;\n        }\n        cout << this << " destructor" << endl;\n    }\n};\n\nvoid func(int &x) {\n    x += 5;\n}\n\nA aa;\nA bb(&aa);\nA cc(&bb);\n\nint main() {\n    int n = 7;\n    func(n);\n    cout << n << endl;\n    cout << "pre position" << endl;\n    A a;\n    A b = 8;\n    A c(a);\n    cout << "a = " << &a << endl;\n    cout << "b = " << &b << endl;\n    cout << "c = " << &c << endl;\n    cout << "aa = " << &aa << endl;\n    cout << "bb = " << &bb << endl;\n    cout << "cc = " << &cc << endl;\n    b.output();\n    b = 6;\n    b.output();\n    cout << "next position" << endl;\n    return 0;\n}\n')),(0,r.kt)("h2",{id:"\u8fdb\u5236\u8f6c\u6362"},"\u8fdb\u5236\u8f6c\u6362"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"auto in_range = [](int b, int e) {\n    return [=](int x) {\n        return (x <= e && x >= b);\n    };\n};\n\nauto is_digit = in_range('0', '9');\nauto is_upper = in_range('A', 'Z');\nauto is_lower = in_range('a', 'z');\n\nclass BigInt {\npublic :\n    BigInt(int base, int x) {\n        this->base = base;\n        this->data.push_back(x);\n        this->proccess_digit();\n    }\n    BigInt() : BigInt(10, 0) {}\n    BigInt(int base, const string &num_str) {\n        this->base = base;\n        for (int i = num_str.size() - 1; i >= 0; --i) {\n            this->data.push_back(BigInt::decode(num_str[i]));\n        }\n    }\n\n    BigInt &operator*=(int x) {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < vec.size(); i++) {\n            vec[i] *= x;\n        }\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator+=(int x) {\n        vector<int> &vec = this->data;\n        vec[0] += x;\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator+=(const BigInt &x) {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < x.data.size(); i++) {\n            if (i + 1 >= vec.size()) vec.push_back(x.data[i]);\n            vec[i] += x.data[i];\n        }\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator/=(int x) {\n        vector<int> &vec = this->data;\n        int i = vec.size() - 1, temp = 0;\n        while (i >= 0 && temp * base + vec[i] < x) {\n            temp = temp * base + vec[i];\n            vec.erase(vec.begin() + (i--));\n        }\n        if (i == -1) { \n            vec.push_back(0); \n            return *this;\n        }\n        while (i >= 0) {\n            temp = temp * base + vec[i];\n            vec[i--] = temp / x;\n            temp %= x;\n        }\n        return *this;\n    }\n    int operator%(int x) {\n        vector<int> &vec = this->data;\n        int temp = 0;\n        for (int i = vec.size() - 1; i >= 0; i--) {\n            temp = temp * base + vec[i];\n            temp %= x;\n        }\n        return temp;\n    }\n    BigInt &convert_to(int to_base) {\n        if (to_base == this->base) return *this;\n        vector<int> result;\n        BigInt &num = *this;\n        do {\n            result.push_back(num % to_base);\n            num /= to_base;\n        } while (num != 0);\n        num.data[0] = result[0];\n        for (int i = 1; i < result.size(); i++) {\n            num.data.push_back(result[i]);\n        }\n        return num;\n    }\n    bool operator!=(int x){\n        return !(this->operator==(x));\n    }\n    bool operator!=(const BigInt &x){\n        return !(this->operator==(x));\n    }\n    bool operator==(int x) {\n        BigInt a(this->base, x);\n        return ((*this) == a);\n    }\n    bool operator==(const BigInt &a) {\n        int now_base = this->base;\n        if (a.base - this->base) this->convert_to(a.base);\n        int flag = 1;\n        if (a.data.size() - this->data.size()) flag = 0;\n        for (int i = 0; i < a.data.size() && flag; i++) {\n            if (a.data[i] - this->data[i]) flag = 0;\n        }\n        this->convert_to(now_base);\n        return flag;\n    }\n\nprivate:\n    vector<int> data;\n    int base;\n    void proccess_digit() {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < vec.size(); i++) {\n            if (vec[i] < base) continue;\n            if (i + 1 == vec.size()) vec.push_back(vec[i] / base);\n            else vec[i + 1] += vec[i] / base;\n            vec[i] %= base;\n        }\n        return ;\n    }\n    static int decode(char ch) {\n        if (is_digit(ch)) return ch - '0';\n        if (is_upper(ch)) return ch - 'A' + 10;\n        return ch - 'a' + 36;\n    }\n    static char encode(int x) {\n        if (x < 10) return x + '0';\n        if (x < 36) return x - 10 + 'A';\n        return x - 36 + 'a';\n    }\n    \nfriend ostream &operator<<(ostream &, const BigInt &);\n};\n\nostream &operator<<(ostream &out, const BigInt &a) {\n    for (int i = a.data.size() - 1; i >= 0; i--) {\n        out << BigInt::encode(a.data[i]);\n    }\n    return out;\n}\n\nint main() {\n    int base_a, base_b;\n    string str;\n    cin >> base_a >> base_b >> str;\n    BigInt num(base_a, str);\n    cout << base_a << \" \" << num << endl;\n    num.convert_to(base_b);\n    cout << base_b << \" \" << num << endl;\n    return 0;\n}\n")),(0,r.kt)("h2",{id:"\u5927\u6d6e\u70b9\u6570"},"\u5927\u6d6e\u70b9\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\n#include <deque>\nusing namespace std;\n\nstruct BigFloat {\n    BigFloat(int x) {\n        lpart.push_back(x);\n        proccess_digit();\n    }\n    void operator*=(int x) {\n        for (int i = 0; i < lpart.size(); i++) lpart[i] *= x;\n        for (int i = 0; i < rpart.size(); i++) rpart[i] *= x;\n        proccess_digit();\n        return ;\n    }\n    void operator<<=(int x) {\n        while (x--) {\n            if (lpart.size()) {\n                rpart.push_front(lpart[lpart.size() - 1]);\n                lpart.pop_back();\n            } else {\n                rpart.push_front(0);\n            }\n        }\n        if (lpart.size() == 0) lpart.push_front(0);\n        trim();\n        return ;\n    }\n    void trim() {\n        while (lpart.size() > 1 && lpart[0] == 0) lpart.pop_front();\n        while (rpart.size() && rpart[rpart.size() - 1] == 0) rpart.pop_back();\n        return ;\n    }\n    void proccess_digit() {\n        for (int i = rpart.size() - 1; i >= 0; --i) {\n            if (rpart[i] < 10) continue;\n            if (i == 0) {\n                lpart[lpart.size() - 1] += rpart[i] / 10;\n            } else {\n                rpart[i - 1] += rpart[i] / 10;\n            }\n            rpart[i] %= 10;\n        }\n        for (int i = lpart.size() - 1; i >= 0; --i) {\n            if (lpart[i] < 10) continue;\n            if (i == 0) lpart.push_front(0), ++i;\n            lpart[i - 1] += lpart[i] / 10;\n            lpart[i] %= 10;\n        }\n        trim();\n        return ;\n    }\n    deque<int> lpart, rpart;\n};\n\nostream &operator<<(ostream &out, const BigFloat &a) {\n    for (int i = 0; i < a.lpart.size(); i++) {\n        out << a.lpart[i];\n    }\n    if (a.rpart.size() == 0) return out;\n    out << \".\";\n    for (int i = 0; i < a.rpart.size(); i++) {\n        out << a.rpart[i];\n    }\n    return out;\n}\n\nint main() {\n    int n, p[4];\n    string str;\n    cin >> n;\n    cin >> str;\n    BigFloat ans = 1;\n    for (int i = 0; i < n; i++) {\n        char ch;\n        for (int j = 0; j < 4; j++) {\n            cin >> p[j] >> ch;\n        }\n        ans *= p[str[i] - 'A'];\n        ans <<= 2;\n    }\n    cout << ans << endl;\n    return 0;\n}\n")),(0,r.kt)("h1",{id:"56-\u56fd\u738b\u6e38\u620f"},"56. \u56fd\u738b\u6e38\u620f"),(0,r.kt)("p",null,"\u5fae\u6270+\u5927\u6574\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\nstruct Data {\n    int a, b;\n    bool operator<(const Data &obj) const {\n        return a * b < obj.a * obj.b;\n    }\n};\nvector<Data> arr;\n\nstruct BigInt {\n    BigInt(int x) {\n        num.push_back(x);\n        process_digit();\n    }\n    bool operator>(const BigInt &obj) {\n        if (num.size() - obj.num.size()) return num.size() > obj.num.size();\n        for (int i = 0; i < num.size(); ++i) {\n            if (num[i] == obj.num[i]) continue;\n            return num[i] > obj.num[i];\n        }\n        return false;\n    }\n    void operator*=(int x) {\n        for (int i = 0; i < num.size(); ++i) {\n            num[i] *= x;\n        }\n        process_digit();\n    }\n    BigInt(vector<int> &ret) : num(ret) {}\n    BigInt operator/(int x) {\n        //i:\u5546\u5728\u54ea\u4e00\u4f4d, temp:\u4f59\u6570\n        int i = num.size(), temp = 0;\n        while (i && temp * 10 + num[i - 1] < x) temp = temp * 10 + num[i - 1], i--;\n        if (i == 0) return BigInt(0);\n        vector<int> ret(i);\n        while (i) {\n            temp = temp * 10 + num[i - 1];\n            ret[i - 1] = temp / x;\n            temp %= x;\n            i--;\n        }\n        return BigInt(ret);\n    }\n    void process_digit() {\n        for (int i = 0; i < num.size(); ++i) {\n            if (num[i] < 10) continue;\n            if (i + 1 == num.size()) num.push_back(0);\n            num[i + 1] += num[i] / 10;\n            num[i] %= 10;\n        }\n        return ;\n    }\n    vector<int> num;\n};\n\nostream &operator<<(ostream &out, const BigInt &obj) {\n    for (int i = obj.num.size() - 1; i >= 0; i--) {\n        out << obj.num[i];\n    }\n    return out;\n}\n\nint main() {\n    int n, a, b;\n    cin >> n;\n    for (int i = 0; i <= n; ++i) {\n        cin >> a >> b;\n        arr.push_back((Data){a, b});\n    }\n    sort(arr.begin() + 1, arr.end());\n    BigInt p = arr[0].a, ans = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (p / arr[i].b > ans) ans = p / arr[i].b;\n        p *= arr[i].a;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n")),(0,r.kt)("h2",{id:"\u5927\u6574\u6570"},"\u5927\u6574\u6570"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <cmath>\nusing namespace std;\n\nauto in_range = [](int b, int e) {\n    return [=](int x) {\n        return (x <= e && x >= b);\n    };\n};\n\nauto is_digit = in_range('0', '9');\nauto is_upper = in_range('A', 'Z');\nauto is_lower = in_range('a', 'z');\n\nclass BigInt {\npublic :\n    BigInt(int base, int x) {\n        this->base = base;\n        this->data.push_back(x);\n        this->proccess_digit();\n    }\n    BigInt() : BigInt(10, 0) {}\n    BigInt(int base, const string &num_str) {\n        this->base = base;\n        for (int i = num_str.size() - 1; i >= 0; --i) {\n            this->data.push_back(BigInt::decode(num_str[i]));\n        }\n    }\n\n    BigInt &operator*=(int x) {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < vec.size(); i++) {\n            vec[i] *= x;\n        }\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator+=(int x) {\n        vector<int> &vec = this->data;\n        vec[0] += x;\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator+=(const BigInt &x) {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < x.data.size(); i++) {\n            if (i + 1 >= vec.size()) vec.push_back(x.data[i]);\n            vec[i] += x.data[i];\n        }\n        this->proccess_digit();\n        return *this;\n    }\n    BigInt &operator/=(int x) {\n        vector<int> &vec = this->data;\n        int i = vec.size() - 1, temp = 0;\n        while (i >= 0 && temp * base + vec[i] < x) {\n            temp = temp * base + vec[i];\n            vec.erase(vec.begin() + (i--));\n        }\n        if (i == -1) { \n            vec.push_back(0); \n            return *this;\n        }\n        while (i >= 0) {\n            temp = temp * base + vec[i];\n            vec[i--] = temp / x;\n            temp %= x;\n        }\n        return *this;\n    }\n    int operator%(int x) {\n        vector<int> &vec = this->data;\n        int temp = 0;\n        for (int i = vec.size() - 1; i >= 0; i--) {\n            temp = temp * base + vec[i];\n            temp %= x;\n        }\n        return temp;\n    }\n    BigInt &convert_to(int to_base) {\n        if (to_base == this->base) return *this;\n        vector<int> result;\n        BigInt &num = *this;\n        do {\n            result.push_back(num % to_base);\n            num /= to_base;\n        } while (num != 0);\n        num.data[0] = result[0];\n        for (int i = 1; i < result.size(); i++) {\n            num.data.push_back(result[i]);\n        }\n        return num;\n    }\n    bool operator!=(int x){\n        return !(this->operator==(x));\n    }\n    bool operator!=(const BigInt &x){\n        return !(this->operator==(x));\n    }\n    bool operator==(int x) {\n        BigInt a(this->base, x);\n        return ((*this) == a);\n    }\n    bool operator==(const BigInt &a) {\n        int now_base = this->base;\n        if (a.base - this->base) this->convert_to(a.base);\n        int flag = 1;\n        if (a.data.size() - this->data.size()) flag = 0;\n        for (int i = 0; i < a.data.size() && flag; i++) {\n            if (a.data[i] - this->data[i]) flag = 0;\n        }\n        this->convert_to(now_base);\n        return flag;\n    }\n\nprivate:\n    vector<int> data;\n    int base;\n    void proccess_digit() {\n        vector<int> &vec = this->data;\n        for (int i = 0; i < vec.size(); i++) {\n            if (vec[i] < base) continue;\n            if (i + 1 == vec.size()) vec.push_back(vec[i] / base);\n            else vec[i + 1] += vec[i] / base;\n            vec[i] %= base;\n        }\n        return ;\n    }\n    static int decode(char ch) {\n        if (is_digit(ch)) return ch - '0';\n        if (is_upper(ch)) return ch - 'A' + 10;\n        return ch - 'a' + 36;\n    }\n    static char encode(int x) {\n        if (x < 10) return x + '0';\n        if (x < 36) return x - 10 + 'A';\n        return x - 36 + 'a';\n    }\n    \nfriend ostream &operator<<(ostream &, const BigInt &);\n};\n\nostream &operator<<(ostream &out, const BigInt &a) {\n    for (int i = a.data.size() - 1; i >= 0; i--) {\n        out << BigInt::encode(a.data[i]);\n    }\n    return out;\n}\n\nint main() {\n    int base_a, base_b;\n    string str;\n    cin >> base_a >> base_b >> str;\n    BigInt num(base_a, str);\n    cout << base_a << \" \" << num << endl;\n    num.convert_to(base_b);\n    cout << base_b << \" \" << num << endl;\n    return 0;\n}\n")))}d.isMDXComponent=!0},18659:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20201223213406320-1623668427119-f6aa76c3be3af5a7861c518ad02748d7.png"},13999:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20201223214008563-1623668427119-95e24a898be42bdccc8bf29997dfa5ad.png"},44821:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20201223214051240-1623668427118-a2f57e7ab06b2da28a91e920ccc91ee3.png"},72632:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20201223214345364-1623668427118-b43cc7d1e5c6c2c2d1f76f9e546411c4.png"},68442:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20201223214822348-1623668427118-8c35931d4822a5d1090452750113f105.png"},44231:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210321202920432-5351a28ae72b7cf6186ee6fbac8238e4.png"},68146:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210321223517051-1623668427119-47b96fb40113b70db1e729aee840478c.png"},35565:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210327215710837-1623668427118-066af4607aa2517ec74f776bccf23f2e.png"},84396:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210327215830460-1623668427118-014e276567934fa75a1aff4dd9acfa6f.png"},39889:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210327220903109-1623668427118-150d6a7e9e44c1e29a77de946fd9f534.png"},89954:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210327220916334-1623668427118-eee94d8b3d7677d1478f94c630776e32.png"},85273:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328104738963-1623668427118-fb53cb338d1065c225688f324626d2d7.png"},36604:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328111426831-1623668427118-db34a77be36376d00dd273ab0f1ac040.png"},14485:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328112141838-1623668427118-9840c28100d3087916c4b297267c2fc0.png"},5339:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328112212375-1623668427118-b4457cb53a72c867a52456fad03ee08a.png"},17308:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328134426730-1623668427118-6c0ed841bb622315f86336be0ae519d2.png"},77518:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328140234757-1623668427118-4ed6e04c3d64843ec7b1d54e968e98b0.png"},140:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328140321327-1623668427118-e17754692248314a2e27ea218356f2a2.png"},81714:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328143953987-1623668427118-805aee913949baadfc92f042e1cc704e.png"},91080:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328162402833-1623668427118-f1bd2f52469dbad8976e3d67c76d2c25.png"},764:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328163244337-1623668427118-1cda42099cb41a377c3d55cd64804f48.png"},27324:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328164441763-1623668427118-ff110ae556e8e2dbf8d9ac00b9e95b2e.png"},2756:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328170447235-1623668427118-2464b9e9bc89510977b621c99ca18ba6.png"},72354:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328173359309-1623668427118-e7acf1312505f6cafad63dbdefb0b1cc.png"},7024:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328174417771-1623668427118-792a7b9de326a3894064341fcfa3b69a.png"},73449:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328174813841-1623668427118-f7b8e4ca8f8436459c97262cbfe98902.png"},2865:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328181506470-1623668427118-686a355223f568f83b3152f70f215795.png"},71982:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328181913511-1623668427118-12af9e2c1be735a08541208f27a80e53.png"},55093:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210328182411421-1623668427118-68910c0be72947047ea947734d7dd4fe.png"},57766:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210329130326086-1623668427118-ed4dc5a157acf90adb4ed30cfe90b8d1.png"},88415:function(n,t,e){"use strict";t.Z=e.p+"assets/images/image-20210329132620508-1623668427117-b11cdaf7b7f70220bf6ce5eb9e3601d2.png"}}]);