(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[5137],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return o},kt:function(){return _}});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var m=r.createContext({}),d=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},o=function(e){var n=d(e.components);return r.createElement(m.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},c=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,m=e.parentName,o=u(e,["components","mdxType","originalType","parentName"]),c=d(t),_=a,h=c["".concat(m,".").concat(_)]||c[_]||p[_]||s;return t?r.createElement(h,i(i({ref:n},o),{},{components:t})):r.createElement(h,i({ref:n},o))}));function _(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,i=new Array(s);i[0]=c;var u={};for(var m in n)hasOwnProperty.call(n,m)&&(u[m]=n[m]);u.originalType=e,u.mdxType="string"==typeof e?e:a,i[1]=u;for(var d=2;d<s;d++)i[d]=t[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}c.displayName="MDXCreateElement"},55314:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return u},metadata:function(){return m},toc:function(){return d},default:function(){return p}});var r=t(22122),a=t(19756),s=(t(67294),t(3905)),i=["components"],u={id:"B5.IPC",title:"B5.IPC","typora-root-url":"../"},m={unversionedId:"Operating_system/B5.IPC",id:"Operating_system/B5.IPC",isDocsHomePage:!1,title:"IPC\uff1a\u8fdb\u7a0b\u95f4\u901a\u4fe1",description:"1.\u5171\u4eab\u5185\u5b58",source:"@site/docs/5.Operating_system/B5.IPC.md",sourceDirName:"5.Operating_system",slug:"/Operating_system/B5.IPC",permalink:"/Operating_system/B5.IPC",editUrl:"https://github.com/worst0/wiki_note/edit/main/docs/5.Operating_system/B5.IPC.md",version:"current",frontMatter:{id:"B5.IPC",title:"B5.IPC","typora-root-url":"../"},sidebar:"Document\ud83d\udcbb",previous:{title:"\u591a\u7ebf\u7a0b\u7ebf\u7a0b",permalink:"/Operating_system/B4.\u591a\u7ebf\u7a0b"},next:{title:"B6.IO",permalink:"/Operating_system/B6.IO"}},d=[{value:"1.\u5171\u4eab\u5185\u5b58",id:"1\u5171\u4eab\u5185\u5b58",children:[]},{value:"2.\u7ebf\u7a0b\u9501",id:"2\u7ebf\u7a0b\u9501",children:[{value:"\u5171\u4eab\u5185\u5b58\uff1a\u7d2f\u52a0",id:"\u5171\u4eab\u5185\u5b58\uff1a\u7d2f\u52a0",children:[]},{value:"\u5171\u4eab\u5185\u5b58\uff1a\u5b50\u8fdb\u7a0b\u8f93\u5165\uff0c\u7236\u8fdb\u7a0b\u8f93\u51fa",id:"\u5171\u4eab\u5185\u5b58\uff1a\u5b50\u8fdb\u7a0b\u8f93\u5165\uff0c\u7236\u8fdb\u7a0b\u8f93\u51fa",children:[]}]},{value:"3.signal\u4fe1\u53f7",id:"3signal\u4fe1\u53f7",children:[{value:"\u804a\u5929\u5ba4\u7684\u5b9e\u73b0",id:"\u804a\u5929\u5ba4\u7684\u5b9e\u73b0",children:[]}]},{value:"4.\u6761\u4ef6\u53d8\u91cf",id:"4\u6761\u4ef6\u53d8\u91cf",children:[{value:"\u804a\u5929\u5ba42",id:"\u804a\u5929\u5ba42",children:[]}]},{value:"5.\u7ba1\u9053",id:"5\u7ba1\u9053",children:[{value:"my_popen\u7684\u5b9e\u73b0",id:"my_popen\u7684\u5b9e\u73b0",children:[]}]},{value:"\u7ebf\u7a0b\u6c60",id:"\u7ebf\u7a0b\u6c60",children:[{value:"\u6d4b\u8bd5\u6587\u4ef6",id:"\u6d4b\u8bd5\u6587\u4ef6",children:[]},{value:"\u5934\u6587\u4ef6",id:"\u5934\u6587\u4ef6",children:[]},{value:"\u6e90\u6587\u4ef6",id:"\u6e90\u6587\u4ef6",children:[]},{value:"\u7ebf\u7a0b\u6c60-\u589e\u5220",id:"\u7ebf\u7a0b\u6c60-\u589e\u5220",children:[]}]},{value:"6.\u6d88\u606f\u961f\u5217",id:"6\u6d88\u606f\u961f\u5217",children:[]},{value:"7.\u4fe1\u53f7\u91cfPV\u64cd\u4f5c",id:"7\u4fe1\u53f7\u91cfpv\u64cd\u4f5c",children:[]}],o={toc:d};function p(e){var n=e.components,t=(0,a.Z)(e,i);return(0,s.kt)("wrapper",(0,r.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("h2",{id:"1\u5171\u4eab\u5185\u5b58"},"1.\u5171\u4eab\u5185\u5b58"),(0,s.kt)("h4",{id:"synopsis"},"synopsis"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"       key_t ftok(const char *pathname, int proj_id);\n        //\u9879\u76ee\u81ea\u5b9a\u4e49\u7684\u7ea6\u5b9aid\n       int shmget(key_t key, size_t size, int shmflg);\n        //\u9a8c\u8bc1\u5171\u4eab\u5185\u5b58\u6bb5\u662f\u5426\u5b58\u5728,\u83b7\u53d6\u5185\u5b58\u6bb5\uff0c\u8fd4\u56deshmid\n       void *shmat(int shmid, const void *shmaddr, int shmflg);\n        //\u6839\u636eshmid\u6355\u83b7\u5185\u5b58\u6bb5\n       int shmdt(const void *shmaddr);\n\n")),(0,s.kt)("h4",{id:"example"},"example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'struct Num {\n    int now, sum;\n    pthread_mutex_t mutex;\n};\n\nstruct Num *share_memory;\n\n    key_t key = ftok(".", 2009);\n    //0666\u6240\u6709\u4eba\u53ef\u8bfb\u53ef\u5199\n    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include "head.h"\n\nstruct Num {\n    int now, sum;\n    pthread_mutex_t mutex;\n};\n\nstruct Num *share_memory;\nvoid do_add(int max, int x) {\n    while(1) {\n        //\u5148\u5224\u65ad,\u52a0\u89e3\u9501\n        //lock\n        pthread_mutex_lock(&share_memory->mutex);\n        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\\n", x, share_memory->now, share_memory->sum);\n\n        if (share_memory->now > max) {\n            //unlock\n            pthread_mutex_unlock(&share_memory->mutex);\n            break;\n        }\n        share_memory->sum += share_memory->now;\n        share_memory->now++;\n\n        //unlock\n        pthread_mutex_unlock(&share_memory->mutex);\n    }\n}\n\n\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        fprintf(stderr, "Usage : %s max ints\\n", argv[0]);\n    }\n    int max = atoi(argv[1]);\n    int ins = atoi(argv[2]);\n    pid_t pid;\n    int shmid;\n    key_t key = ftok(".", 2009);\n    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n    \n    memset(share_memory, 0, sizeof(struct Num));\n    //\u9501\u5c5e\u6027\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    \n    //\u5bf9\u9501\u5c5e\u6027\u66f4\u6539,\u8ba9\u7ebf\u7a0b\u9501\u53ef\u4ee5\u5728\u8fdb\u7a0b\u95f4\u5171\u4eab\n    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);\n\n    //\u521d\u59cb\u5316\u9501\n    pthread_mutex_init(&share_memory->mutex, &attr);\n    \n    int x = 0;\n    for (int i = 0; i < ins; ++i) {\n        if (pid = fork() < 0) {\n            perror("fork()");\n            exit(1);\n        }\n        x = i;\n        if (pid == 0) break;\n    }\n    if (pid == 0) {\n        do_add(max, x);\n        exit(0);\n    }\n    \n    while (ins--) {\n        wait(NULL);\n    }\n\n    return 0;\n}\n\n')),(0,s.kt)("h2",{id:"2\u7ebf\u7a0b\u9501"},"2.\u7ebf\u7a0b\u9501"),(0,s.kt)("h4",{id:"synopsis-1"},"synopsis"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"\n\n   int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,\n                                        int pshared);\n            pthread_mutex_init();\n             pthread_mutex_lock();\n             pthread_mutex_unlock();\n")),(0,s.kt)("h4",{id:"example-1"},"example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"struct Num {\n    int now, sum;\n    pthread_mutex_t mutex;\n};\n\nstruct Num *share_memory;\n        \n\n//lock\n        pthread_mutex_lock(&share_memory->mutex);\n\n        //unlock\n        pthread_mutex_unlock(&share_memory->mutex);\n\n\n//\u9501\u5c5e\u6027\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    \n    //\u5bf9\u9501\u5c5e\u6027\u66f4\u6539,\u8ba9\u7ebf\u7a0b\u9501\u53ef\u4ee5\u5728\u8fdb\u7a0b\u95f4\u5171\u4eab\n    pthread_mutexattr_setpshared(&attr,     PTHREAD_PROCESS_SHARED);\n\n    //\u521d\u59cb\u5316\u9501\n    pthread_mutex_init(&share_memory->mutex, &attr);\n\n")),(0,s.kt)("h3",{id:"\u5171\u4eab\u5185\u5b58\uff1a\u7d2f\u52a0"},"\u5171\u4eab\u5185\u5b58\uff1a\u7d2f\u52a0"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include "head.h"\n\nstruct Num {\n    int now, sum;\n    pthread_mutex_t mutex;\n};\n\nstruct Num *share_memory;\n\n\nvoid do_add(int max, int x) {\n    while(1) {\n        //\u5148\u5224\u65ad,\u52a0\u89e3\u9501\n        //lock\n        pthread_mutex_lock(&share_memory->mutex);\n        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\\n", x, share_memory->now, share_memory->sum);\n\n        if (share_memory->now > max) {\n            //unlock\n            pthread_mutex_unlock(&share_memory->mutex);\n            break;\n        }\n        share_memory->sum += share_memory->now;\n        share_memory->now++;\n\n        //unlock\n        pthread_mutex_unlock(&share_memory->mutex);\n    }\n}\n\n\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        fprintf(stderr, "Usage : %s max ints\\n", argv[0]);\n    }\n    int max = atoi(argv[1]);\n    int ins = atoi(argv[2]);\n    pid_t pid;\n    int shmid;\n    key_t key = ftok(".", 2009);\n    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n    \n    memset(share_memory, 0, sizeof(struct Num));\n    //\u9501\u5c5e\u6027\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    \n    //\u5bf9\u9501\u5c5e\u6027\u66f4\u6539,\u8ba9\u7ebf\u7a0b\u9501\u53ef\u4ee5\u5728\u8fdb\u7a0b\u95f4\u5171\u4eab\n    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);\n\n    //\u521d\u59cb\u5316\u9501\n    pthread_mutex_init(&share_memory->mutex, &attr);\n    \n    int x = 0;\n    for (int i = 0; i < ins; ++i) {\n        if (pid = fork() < 0) {\n            perror("fork()");\n            exit(1);\n        }\n        x = i;\n        if (pid == 0) break;\n    }\n    \n    if (pid == 0) {\n        \n        do_add(max, x);\n        exit(0);\n    }\n    \n    while (ins--) {\n        wait(NULL);\n    }\n\n    return 0;\n}\n\n')),(0,s.kt)("h3",{id:"\u5171\u4eab\u5185\u5b58\uff1a\u5b50\u8fdb\u7a0b\u8f93\u5165\uff0c\u7236\u8fdb\u7a0b\u8f93\u51fa"},"\u5171\u4eab\u5185\u5b58\uff1a\u5b50\u8fdb\u7a0b\u8f93\u5165\uff0c\u7236\u8fdb\u7a0b\u8f93\u51fa"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include "head.h"\n\nstruct Num {\n    int now, sum;\n    pthread_mutex_t mutex;\n};\n\nstruct Num *share_memory;\n\n\nvoid do_add(int max, int x) {\n    while(1) {\n        //\u5148\u5224\u65ad,\u52a0\u89e3\u9501\n        //lock\n        pthread_mutex_lock(&share_memory->mutex);\n        DBG(GREEN"<Debug>"NONE " : <%d> now = %d, sum = %d\\n", x, share_memory->now, share_memory->sum);\n\n        if (share_memory->now > max) {\n            //unlock\n            pthread_mutex_unlock(&share_memory->mutex);\n            break;\n        }\n        share_memory->sum += share_memory->now;\n        share_memory->now++;\n\n        //unlock\n        pthread_mutex_unlock(&share_memory->mutex);\n    }\n}\n\n\nint main(int argc, char **argv) {\n    if (argc != 3) {\n        fprintf(stderr, "Usage : %s max ints\\n", argv[0]);\n    }\n    int max = atoi(argv[1]);\n    int ins = atoi(argv[2]);\n    pid_t pid;\n    int shmid;\n    key_t key = ftok(".", 2009);\n    if ((shmid =shmget(key, sizeof(struct Num), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = (struct Num *)shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n    \n    memset(share_memory, 0, sizeof(struct Num));\n    //\u9501\u5c5e\u6027\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    \n    //\u5bf9\u9501\u5c5e\u6027\u66f4\u6539,\u8ba9\u7ebf\u7a0b\u9501\u53ef\u4ee5\u5728\u8fdb\u7a0b\u95f4\u5171\u4eab\n    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);\n\n    //\u521d\u59cb\u5316\u9501\n    pthread_mutex_init(&share_memory->mutex, &attr);\n    \n    int x = 0;\n    for (int i = 0; i < ins; ++i) {\n        if (pid = fork() < 0) {\n            perror("fork()");\n            exit(1);\n        }\n        x = i;\n        if (pid == 0) break;\n    }\n    \n    if (pid == 0) {\n        \n        do_add(max, x);\n        exit(0);\n    }\n    \n    while (ins--) {\n        wait(NULL);\n    }\n\n    return 0;\n}\n\n')),(0,s.kt)("h2",{id:"3signal\u4fe1\u53f7"},"3.signal\u4fe1\u53f7"),(0,s.kt)("h4",{id:"synopsis-2"},"synopsis"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"        //\u63a5\u6536\u4fe1\u53f7       \n\n        sighandler_t signal(int signum, sighandler_t handler);\n        //handler \uff1atypedef void (*sighandler_t)(int);\n        //\u4f8b\u5982void *func(int signum)\u7c7b\u578b\uff0c\u8868\u660e\u662f\u4fe1\u53f7\u5904\u7406\u51fd\u6570\n\n        //pause()\u4f1a\u4ee4\u76ee\u524d\u7684\u8fdb\u7a0b\u6682\u505c(\u8fdb\u5165\u7761\u7720\u72b6\u6001), \u76f4\u5230\u88ab\u4fe1\u53f7(signal)\u6240\u4e2d\u65ad\u3002\n         pause();\n\n\n        //\u53d1\u4fe1\u53f7\n        int kill(pid_t pid, int sig);\n        \n")),(0,s.kt)("h4",{id:"example-2"},"example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'   if (pid == 0) {\n       while (1) {\n            DBG(GREEN"<Debug>"NONE " : locked in child\\n");\n            scanf("%[^\\n]s", share_memory->str);\n            getchar(); \n            printf(YELLOW"<child>"NONE " : %s\\n ", share_memory->str);\n            kill(getppid(), SIGUSR1);\n\n       }\n   }  else {\n       signal(SIGUSR1, (void *)do_print);\n       wait(NULL);\n   }\n\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include "head.h"\nstruct Data {\n    char str[1000];\n    pthread_mutex_t mutex;\n};\n\nstruct Data *share_memory;\n\nvoid *do_print(int signum) {\n    printf(RED"<Parent>"NONE " : %s\\n ", share_memory->str);\n    memset(share_memory->str, 0, sizeof(share_memory->str));\n    return NULL;\n}\n\nint main(int argc, char **argv) {\n    pid_t pid;\n    int shmid;\n    key_t key = ftok(".", 209);\n    if ((shmid =shmget(key, sizeof(struct Data), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = (struct Data *)shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n\n    memset(share_memory->str, 0, sizeof(share_memory->str));\n    if ((pid = fork()) < 0) {\n        perror("fork()");\n        exit(1);\n    }\n\n   if (pid == 0) {\n       while (1) {\n            DBG(GREEN"<Debug>"NONE " : locked in child\\n");\n            scanf("%[^\\n]s", share_memory->str);\n            getchar(); \n            printf(YELLOW"<child>"NONE " : %s\\n ", share_memory->str);\n            kill(getppid(), SIGUSR1);\n\n       }\n   }  else {\n       signal(SIGUSR1, (void *)do_print);\n       wait(NULL);\n   }  \n    return 0;\n}\n')),(0,s.kt)("h3",{id:"\u804a\u5929\u5ba4\u7684\u5b9e\u73b0"},"\u804a\u5929\u5ba4\u7684\u5b9e\u73b0"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"// File Name: chat.h\n\n#ifndef _CHAT_H\n#define _CHAT_H\n\nstruct Message {\n    char name[20];\n    char msg[1024];\n    pid_t pid;\n    pthread_mutex_t mutex;\n};\n\n#endif\n\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'//file Name: 1.server.c\n\n#include "head.h"\n#include "chat.h"\n\nstruct Message *share_memory = NULL;\n\nvoid *print(int signum) {\n    pthread_mutex_lock(&share_memory->mutex);\n    printf(RED"<%s>"NONE " : %s\\n", share_memory->name, share_memory->msg);\n    memset(share_memory->name, 0, sizeof(share_memory->name));\n    memset(share_memory->msg, 0, sizeof(share_memory->msg));\n    pthread_mutex_unlock(&share_memory->mutex);\n}\n\nint main() {\n    int shmid;\n    key_t key = ftok(".", 2011);\n\n    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = (struct Message *)shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n\n    memset(share_memory, 0, sizeof(struct Message));\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);\n    pthread_mutex_init(&share_memory->mutex, &attr);\n    \n    share_memory->pid = getpid();\n    while (1) {\n        signal(SIGUSR2, (void *)print);\n        //pause()\u4f1a\u4ee4\u76ee\u524d\u7684\u8fdb\u7a0b\u6682\u505c(\u8fdb\u5165\u7761\u7720\u72b6\u6001), \u76f4\u5230\u88ab\u4fe1\u53f7(signal)\u6240\u4e2d\u65ad\u3002\n        pause();\n    }\n    return 0;\n}\n\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'//file Name: 2.client.c\n\n#include "head.h"\n#include "chat.h"\n\nstruct Message *share_memory = NULL;\n\nint main(int argc, char **argv) {\n    struct Message tmp;\n    int opt;\n    //"n:" \u4ee3\u8868\u6709\u53c2\n    //optarg\u662fgetopt\u7684\u4e09\u4e2a\u5168\u5c40\u53d8\u91cf\u4e4b\u4e00,\u4ee3\u8868\u7d27\u8ddf\u53c2\u6570\n    while ((opt = getopt(argc, argv, "n:")) != -1) {\n        switch (opt) {\n            case \'n\' :\n                strcpy(tmp.name, optarg);\n                break;\n            default :\n                fprintf(stderr, "Usage : %s -n name!\\n", argv[0]);\n                exit(1);\n                break;\n        }\n    }\n    \n    if (argc < 3) {\n        fprintf(stderr, "Usage : %s -n name!\\n", argv[0]);\n        exit(1);\n    }\n\n    int shmid;\n    key_t key = ftok(".", 2011);\n    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n    \n    //\u810f\u6570\u636e,pid <= 0\u4e00\u5b9a\u6ca1\u8d77\u6765\n    if (share_memory->pid <= 0) {\n        fprintf(stderr, "Please run server first!\\n");    \n        exit(1);\n    }\n    \n    while(1) {\n        scanf("%[^\\n]s", tmp.msg);\n        getchar();\n        if (!strlen(tmp.msg)) continue;\n        while (1) {\n            //\u9690\u6027bug msg\u4e3a\u7a7a,\u591a\u4e2aclient\u7aef\u540c\u65f6\u4e0a\u9501\n            if (!strlen(share_memory->msg)) {\n                //\u6301\u6709\u9501\u53ef\u80fd\u963b\u585e\n                pthread_mutex_lock(&share_memory->mutex);\n                break;\n            }\n        }\n        strcpy(share_memory->name, tmp.name);\n        strcpy(share_memory->msg, tmp.msg);\n        pthread_mutex_unlock(&share_memory->mutex);\n        kill(share_memory->pid, SIGUSR2);\n        memset(tmp.msg, 0, sizeof(tmp.msg));\n    }\n\n}\n\n\n')),(0,s.kt)("h2",{id:"4\u6761\u4ef6\u53d8\u91cf"},"4.\u6761\u4ef6\u53d8\u91cf"),(0,s.kt)("h4",{id:"synopsis-3"},"synopsis"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"extern int pthread_cond_init (pthread_cond_t *__restrict __cond,\n                  const pthread_condattr_t *__restrict __cond_attr)\n     __THROW __nonnull ((1));\n\n/* Destroy condition variable COND.  */\nextern int pthread_cond_destroy (pthread_cond_t *__cond)\n     __THROW __nonnull ((1));\n\n/* Wake up one thread waiting for condition variable COND.  */\nextern int pthread_cond_signal (pthread_cond_t *__cond)\n     __THROWNL __nonnull ((1));\n\n\n/* Wait for condition variable COND to be signaled or broadcast.\n   MUTEX is assumed to be locked before.\n\n   This function is a cancellation point and therefore not marked with\n   __THROW.  */\nextern int pthread_cond_wait (pthread_cond_t *__restrict __cond,\n                  pthread_mutex_t *__restrict __mutex)\n     __nonnull ((1, 2))\n")),(0,s.kt)("h4",{id:"example-3"},"example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"    //\u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\n    pthread_condattr_t cond_attr;\n    pthread_condattr_init(&cond_attr);\n    pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED);\n    pthread_cond_init(&share_memory->cond, &cond_attr);\n    \n    //\u7b49\u5f85\u4fe1\u53f7\n    pthread_cond_wait(&share_memory->cond, &share_memory->mutex);\n\n    //\u53d1\u9001\u4fe1\u53f7\n    pthread_cond_signal(&share_memory->cond);\n\n\npthread_cond_wait\u5fc5\u987b\u653e\u5728pthread_mutex_lock\u548cpthread_mutex_unlock\u4e4b\u95f4\uff0c\n    \u56e0\u4e3a\u4ed6\u8981\u6839\u636e\u5171\u4eab\u53d8\u91cf\u7684\u72b6\u6001\u6765\u51b3\u5b9a\u662f\u5426\u8981\u7b49\u5f85\uff0c\u800c\u4e3a\u4e86\u4e0d\u6c38\u8fdc\u7b49\u5f85\u4e0b\u53bb\u6240\u4ee5\u5fc5\u987b\u8981\u5728lock/unlock\u961f\u4e2d\n\u5171\u4eab\u53d8\u91cf\u7684\u72b6\u6001\u6539\u53d8\u5fc5\u987b\u9075\u5b88lock/unlock\u7684\u89c4\u5219\npthread_cond_signal\u5373\u53ef\u4ee5\u653e\u5728pthread_mutex_lock\u548cpthread_mutex_unlock\u4e4b\u95f4\uff0c\u4e5f\u53ef\u4ee5\u653e\u5728pthread_mutex_lock\u548cpthread_mutex_unlock\u4e4b\u540e\uff0c\u4f46\u662f\u5404\u6709\u4f18\u7f3a\u70b9\u3002\n")),(0,s.kt)("h3",{id:"\u804a\u5929\u5ba42"},"\u804a\u5929\u5ba42"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include "head.h"\n#include "chat.h"\n\nstruct Message *share_memory = NULL;\n\nvoid *print(int signum) {\n    pthread_mutex_lock(&share_memory->mutex);\n    printf(RED"<%s>"NONE " : %s\\n", share_memory->name, share_memory->msg);\n    memset(share_memory->name, 0, sizeof(share_memory->name));\n    memset(share_memory->msg, 0, sizeof(share_memory->msg));\n    pthread_mutex_unlock(&share_memory->mutex);\n}\n\nint main() {\n    int shmid;\n    key_t key = ftok(".", 2011);\n\n    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = (struct Message *)shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n\n    memset(share_memory, 0, sizeof(struct Message));\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);\n    pthread_mutex_init(&share_memory->mutex, &attr);\n    \n    pthread_condattr_t cond_attr;\n    pthread_condattr_init(&cond_attr);\n    pthread_condattr_setpshared(&cond_attr, PTHREAD_PROCESS_SHARED);\n    pthread_cond_init(&share_memory->cond, &cond_attr);\n\n    //share_memory->pid = getpid();\n    while (1) {\n        //signal(SIGUSR2, (void *)print);\n        //pause()\u4f1a\u4ee4\u76ee\u524d\u7684\u8fdb\u7a0b\u6682\u505c(\u8fdb\u5165\u7761\u7720\u72b6\u6001), \u76f4\u5230\u88ab\u4fe1\u53f7(signal)\u6240\u4e2d\u65ad\u3002\n       // pause();\n        pthread_mutex_lock(&share_memory->mutex);\n        DBG(GREEN"<Debug>"NONE " : wait before\\n");\n        pthread_cond_wait(&share_memory->cond, &share_memory->mutex);\n        DBG(GREEN"<Debug>"NONE " : wait after\\n");\n        printf(RED"<%s>"NONE " : %s\\n", share_memory->name, share_memory->msg);\n        memset(share_memory->name, 0, sizeof(share_memory->name));\n        memset(share_memory->msg, 0, sizeof(share_memory->msg));\n        pthread_mutex_unlock(&share_memory->mutex);\n    }\n    return 0;\n}\n\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include "head.h"\n#include "chat.h"\n\nstruct Message *share_memory = NULL;\n\nint main(int argc, char **argv) {\n    struct Message tmp;\n    int opt;\n    //"n:" \u4ee3\u8868\u6709\u53c2\n    //optarg\u662fgetopt\u7684\u4e09\u4e2a\u5168\u5c40\u53d8\u91cf\u4e4b\u4e00,\u4ee3\u8868\u7d27\u8ddf\u53c2\u6570\n    while ((opt = getopt(argc, argv, "n:")) != -1) {\n        switch (opt) {\n            case \'n\' :\n                strcpy(tmp.name, optarg);\n                break;\n            default :\n                fprintf(stderr, "Usage : %s -n name!\\n", argv[0]);\n                exit(1);\n                break;\n        }\n    }\n    \n    if (argc < 3) {\n        fprintf(stderr, "Usage : %s -n name!\\n", argv[0]);\n        exit(1);\n    }\n\n    int shmid;\n    key_t key = ftok(".", 2011);\n    if ((shmid = shmget(key, sizeof(struct Message), IPC_CREAT | 0666)) < 0) {\n        perror("shmget()");\n        exit(1);\n    }\n\n    if ((share_memory = shmat(shmid, NULL, 0)) == NULL) {\n        perror("shmat()");\n        exit(1);\n    }\n    \n    while(1) {\n        scanf("%[^\\n]s", tmp.msg);\n        getchar();\n        if (!strlen(tmp.msg)) continue;\n        while (1) {\n            //\u9690\u6027bug msg\u4e3a\u7a7a,\u591a\u4e2aclient\u7aef\u540c\u65f6\u4e0a\u9501\n            if (!strlen(share_memory->msg)) {\n                pthread_mutex_lock(&share_memory->mutex);\n                break;\n            }\n        }\n        strcpy(share_memory->name, tmp.name);\n        strcpy(share_memory->msg, tmp.msg);\n        pthread_mutex_unlock(&share_memory->mutex);\n        //kill(share_memory->pid, SIGUSR2);\n        pthread_cond_signal(&share_memory->cond);\n        DBG(GREEN"<Debug>"NONE" : AFTER signal\\n");\n        memset(tmp.msg, 0, sizeof(tmp.msg));\n    }\n\n}\n\n\n')),(0,s.kt)("h2",{id:"5\u7ba1\u9053"},"5.\u7ba1\u9053"),(0,s.kt)("h4",{id:"synopsis-4"},"synopsis"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"int pipe(int pipefd[2]);\nFILE *popen(const char *command, const char *type);\n  int pclose(FILE *stream);\npipefd[0] refers to the read end of the pipe.  \n pipefd[1] refers to the write end of the pipe.\n")),(0,s.kt)("h4",{id:"example-4"},"example"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'            int pipefd[2];\n            if (cpid == 0) {    /* Child reads from pipe */\n               close(pipefd[1]);          /* Close unused write end */\n\n               while (read(pipefd[0], &buf, 1) > 0)\n                   write(STDOUT_FILENO, &buf, 1);\n\n               write(STDOUT_FILENO, "\\n", 1);\n               close(pipefd[0]);\n               _exit(EXIT_SUCCESS);\n\n           } else {            /* Parent writes argv[1] to pipe */\n               close(pipefd[0]);          /* Close unused read end */\n               write(pipefd[1], argv[1], strlen(argv[1]));\n               close(pipefd[1]);          /* Reader will see EOF */\n               wait(NULL);                /* Wait for child */\n               exit(EXIT_SUCCESS);\n           }\n\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'pid_t pid;\n    int pipefd[2];\n    char buffer[1024];\n    if ((pid = fork()) < 0) {\n        perror("fork()");\n        exit(1);\n    }\n    \n    if (pid == 0) {\n        close(pipefd[0]);\n        while (1) {\n            memset(buffer, 0, sizeof(buffer));\n            scanf("%s", buffer);\n            write(pipefd[1], buffer, strlen(buffer));\n        }\n    } else {\n        close(pipefd[1]);\n        while (1) {\n            read(pipefd[0], buffer, sizeof(buffer));\n            printf("%s\\n", buffer);\n            memset(buffer, 0, sizeof(buffer));\n        }\n    }\n    \n\n\n    FILE *fp;\n    char buff[1024] = {0};\n    //\u62a5\u9519512 \u548c 2\u7684\u5173\u7cfb \n    if ((fp = popen("ls /etc", "r")) == NULL) {\n        perror("m_open()");\n        exit(1);\n    }\n\n    while (fgets(buff, sizeof(buff), fp) != NULL) {\n        printf("%s", buff);\n        bzero(buff, sizeof(buff));\n    } \n    \n    int status = pclose(fp);\n\n')),(0,s.kt)("h3",{id:"my_popen\u7684\u5b9e\u73b0"},"my_popen\u7684\u5b9e\u73b0"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},"#include \"head.h\"\nstatic pid_t *childpid = NULL;\nstatic int max;\n\nFILE *m_popen(const char *cmd, const char *type) {\n    int pfd[2];\n    FILE *fp;\n    pid_t pid;\n    if ((type[0] != 'r' || type[0] != 'w') && type[1] != '\\0') {\n        errno = EINVAL;\n        return NULL;\n    }\n    if (childpid == NULL) {\n        max = sysconf(_SC_OPEN_MAX);\n        if ((childpid = (pid_t *)calloc(max, sizeof(pid_t))) == NULL)\n            return NULL;\n    }\n\n    if (pipe(pfd) < 0) {\n        return NULL;\n    }\n\n    if ((pid = fork()) < 0) {\n        return NULL;\n    }\n\n    if (pid == 0) {\n        if (type[0] == 'r'){\n            close(pfd[0]);\n            if (pfd[1] != STDOUT_FILENO) {\n                dup2(pfd[1], STDOUT_FILENO);\n                close(pfd[1]);\n            }\n        } else {\n            close(pfd[1]);\n            if (pfd[0] != STDIN_FILENO) {\n                dup2(pfd[0], STDIN_FILENO);\n                close(pfd[0]);\n            }\n        }\n        for (int i = 0; i < max; i++) {\n            if (childpid[i] > 0)\n                close(i);\n        }\n\n        execl(\"/bin/sh\", \"sh\", \"-c\", cmd, NULL);\n        exit(0);\n    }\n\n    if (type[0] == 'r') {\n        close(pfd[1]);\n        if ((fp = fdopen(pfd[0], type)) == NULL)\n            return NULL;\n    } else {\n        close(pfd[0]);\n        if ((fp = fdopen(pfd[1], type)) == NULL)\n            return NULL;\n    }\n    childpid[fileno(fp)] = pid;\n    return fp;\n}\n\nint m_pclose(FILE *fp) {\n    int status, fd, pid;\n    if (childpid == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    fd = fileno(fp);\n    pid = childpid[fd];\n    if (pid == 0) {\n        errno = EINVAL;\n        return -1;\n    }\n    childpid[fd] = 0;\n    close(fd);\n    waitpid(pid, &status, 0);\n    return status;\n}\n")),(0,s.kt)("h2",{id:"\u7ebf\u7a0b\u6c60"},"\u7ebf\u7a0b\u6c60"),(0,s.kt)("h3",{id:"\u6d4b\u8bd5\u6587\u4ef6"},"\u6d4b\u8bd5\u6587\u4ef6"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include "head.h"\n#include "thread_pool.h"\n\n#define SIZE 5 \n#define THREADNUM 5 \n#define BUFFSIZE 512\n\nint main() {\n    pthread_t tid[THREADNUM];\n    struct task_queue taskQueue;\n    taskQueue = *task_queue_init(&taskQueue, SIZE);\n    DBG(GREEN"<Debug>"NONE " :head = %d. tail = %d, cnt = %d, size = %d\\n", taskQueue.head, taskQueue.tail ,taskQueue.cnt, taskQueue.size);\n    \n    for (int i = 0; i < THREADNUM; ++i) {\n         int id =  pthread_create(&tid[i], NULL, thread_run, (void *)&taskQueue);\n        //DBG(GREEN"<Debug>"NONE " : Created = %d\\n", id);\n    }\n        DBG(GREEN"<Debug>"NONE " : Created success\\n");\n\n    while (1) {\n        FILE *fp = fopen("./thread_pool.c", "r");\n        if (fp == NULL) {\n            perror("fopen()");\n            exit(1);\n        }\n\n        char buff[BUFFSIZE] = {0};\n        \n        while (fgets(buff, BUFFSIZE, fp) != NULL) {\n            task_queue_push(&taskQueue, buff);\n            memset(buff, 0, sizeof(buff));\n            usleep(1);\n        }\n        \n        fclose(fp);\n        //break;\n        /*\n        scanf("%[^\\n]s", buff);\n        getchar();\n        DBG(GREEN"<stdin>"NONE "before : %s\\n", buff);\n        task_queue_push(&taskQueue, buff);\n        DBG(GREEN"<stdin>"NONE "after : %s\\n", buff);\n        */\n    }\n    //task_queue_clear(&taskQueue);\n    for (int i = 0; i < THREADNUM; ++i) {\n        pthread_join(tid[i], NULL);\n    }\n    return 0;\n}\n\n')),(0,s.kt)("h3",{id:"\u5934\u6587\u4ef6"},"\u5934\u6587\u4ef6"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#ifndef _THREAD_POOL_H\n#define _THREAD_POOL_H\n\n#include "head.h"\n\nstruct task_queue {\n    int head;\n    int tail;\n    int size;\n    int cnt;\n    char **data;\n    pthread_mutex_t mutex;\n    pthread_cond_t cond;\n};\n\nstruct task_queue * task_queue_init(struct task_queue *taskQueue, int size);\n\nint task_queue_push(struct task_queue *taskQueue, char *str);\nchar *task_queue_pop(struct task_queue *taskQueue);\nvoid task_queue_clear(struct task_queue *taskQueue);\nvoid *thread_run(void *arg);\n\n#endif\n\n')),(0,s.kt)("h3",{id:"\u6e90\u6587\u4ef6"},"\u6e90\u6587\u4ef6"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'#include "thread_pool.h" \n#include "head.h"\n\nstruct task_queue * task_queue_init(struct task_queue *taskQueue, int size) {\n    taskQueue = (struct task_queue *)malloc(sizeof(struct task_queue));\n    taskQueue->data = (char **)calloc( size, sizeof(char *));\n    taskQueue->head = taskQueue->tail = 0;\n    taskQueue->cnt = 0;\n    taskQueue->size = size;\n    DBG(BLUE"<init>"NONE "head = %d, tail = %d, cnt = %d, size = %d\\n", taskQueue->head, taskQueue->tail ,taskQueue->cnt, taskQueue->size);\n\n    if (pthread_mutex_init(&(taskQueue->mutex), NULL) != 0) {\n        printf("mutex init error");\n        return NULL;\n    }\n    if (pthread_cond_init(&(taskQueue->cond), NULL) != 0) {\n        printf("cond init error");\n        return NULL;\n    }\n    return taskQueue;\n}\n\nint task_queue_push(struct task_queue *taskQueue, char *str) {\n    pthread_mutex_lock(&taskQueue->mutex);\n    if (taskQueue == NULL)  {\n        DBG(BLUE"<PUSH>"NONE " NULL");\n        pthread_mutex_unlock(&taskQueue->mutex);\n        return -1;\n    }\n    if (taskQueue->cnt > taskQueue->size) {\n        DBG(BLUE"<PUSH Full>"NONE " cnt = %d, size = %d\\n", taskQueue->cnt, taskQueue->size);\n        pthread_mutex_unlock(&taskQueue->mutex);\n        return 0;\n    } \n    //DBG(BLUE"<PUSH>"NONE " %s\\n", str);\n    (taskQueue->data)[taskQueue->tail] = strdup(str);\n    taskQueue->tail++;\n    DBG(BLUE"<PUSH>"NONE "%s\\n", taskQueue->data[taskQueue->tail - 1]);\n    if (taskQueue->tail == taskQueue->size) taskQueue->tail -= taskQueue->size;\n    taskQueue->cnt += 1;\n\n    //pthread_cond_broadcast(&(taskQueue->cond));\n    pthread_mutex_unlock(&taskQueue->mutex);\n    pthread_cond_signal(&(taskQueue->cond));\n    return 1;\n}\n\nchar *task_queue_pop(struct task_queue *taskQueue) {\n    //pthread_mutex_lock(&taskQueue->mutex);\n    if (taskQueue == NULL || taskQueue->cnt == 0) {\n        pthread_mutex_unlock(&taskQueue->mutex);\n        return NULL;\n    }\n    int idx = taskQueue->head++;\n    DBG(BLUE"<POP>"NONE "%s\\n", taskQueue->data[taskQueue->head - 1]);\n    if (taskQueue->head == taskQueue->size) taskQueue->head -= taskQueue->size;\n    taskQueue->cnt -= 1;\n    //pthread_cond_broadcast(&(taskQueue->cond);\n    //pthread_mutex_unlock(&taskQueue->mutex);\n    return taskQueue->data[idx];\n}\n\nvoid task_queue_clear(struct task_queue *taskQueue) {\n    \n    if (taskQueue == NULL) return ;\n    free(taskQueue->data);\n    free(taskQueue);\n    return ;\n}\n\nvoid *thread_run(void *arg) {\n    printf("thread_run ready\\n");\n    pthread_detach(pthread_self());\n    struct task_queue *taskQueue = (struct task_queue *)arg;\n    while (1) {\n        pthread_mutex_lock(&taskQueue->mutex);\n        if (taskQueue->cnt == 0)  {\n            DBG(YELLOW"thread <%ld> "NONE" waiting\\n", pthread_self());\n            pthread_cond_wait(&(taskQueue->cond), &(taskQueue->mutex));\n            //pause();\n        }\n        //DBG(BLUE"<run>"NONE"thread_run_lock\\n");\n        char *str = task_queue_pop(taskQueue);\n        printf(RED"<%ld>"NONE"%s\\n", pthread_self(), str);\n        if (str != NULL) free(str);\n        pthread_mutex_unlock(&taskQueue->mutex);\n        //sleep(1);\n    }\n}\n\n')),(0,s.kt)("h3",{id:"\u7ebf\u7a0b\u6c60-\u589e\u5220"},"\u7ebf\u7a0b\u6c60-\u589e\u5220"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-c"},'struct task_queue * task_queue_init(struct task_queue *taskQueue, int size) {\n    taskQueue = (struct task_queue *)malloc(sizeof(struct task_queue));\n    taskQueue->data = (char **)calloc(size, sizeof(void *));\n    taskQueue->head = taskQueue->tail = 0;\n    taskQueue->cnt = 0;\n    taskQueue->size = size;\n    DBG(BLUE"<init>"NONE "head = %d, tail = %d, cnt = %d, size = %d\\n", taskQueue->head, taskQueue->tail ,taskQueue->cnt, taskQueue->size);\n\n    if (pthread_mutex_init(&(taskQueue->mutex), NULL) != 0) {\n        printf("mutex init error");\n        return NULL;\n    }\n    if (pthread_cond_init(&(taskQueue->cond), NULL) != 0) {\n        printf("cond init error");\n        return NULL;\n    }\n    return taskQueue;\n}\n\nint task_queue_push(struct task_queue *taskQueue, char *str) {\n    pthread_mutex_lock(&taskQueue->mutex);\n    if (taskQueue == NULL)  {\n        DBG(BLUE"<PUSH>"NONE " : NULL");\n        pthread_mutex_unlock(&taskQueue->mutex);\n        return -1;\n    }\n    if (taskQueue->cnt >= taskQueue->size) {\n        DBG(BLUE"<PUSH Full>"NONE " : cnt = %d, size = %d\\n", taskQueue->cnt, taskQueue->size);\n        pthread_mutex_unlock(&taskQueue->mutex);\n        return 0;\n    } \n    //DBG(BLUE"<PUSH>"NONE " %s\\n", str);\n    taskQueue->data[taskQueue->tail] = str;\n    taskQueue->tail++;\n    DBG(BLUE"<PUSH>"NONE " : %s\\n", taskQueue->data[taskQueue->tail - 1]);\n    if (taskQueue->tail == taskQueue->size) taskQueue->tail = 0;\n    taskQueue->cnt += 1;\n\n    pthread_cond_signal(&(taskQueue->cond));\n    pthread_mutex_unlock(&taskQueue->mutex);\n    return 1;\n}\n\nchar *task_queue_pop(struct task_queue *taskQueue) {\n    pthread_mutex_lock(&taskQueue->mutex);\n    if (taskQueue == NULL) {\n        pthread_mutex_unlock(&taskQueue->mutex);\n        return NULL;\n    }\n\n    DBG(BLUE"<POP>"NONE "in pop!");\n    //\u60ca\u7fa4\u6548\u5e94 while \u800c\u975e if\n    while (taskQueue->cnt == 0) {\n        DBG(YELLOW"thread <%ld> "NONE" waiting\\n", pthread_self());\n        pthread_cond_wait(&taskQueue->cond, &taskQueue->mutex);\n    }\n    char *str = taskQueue->data[taskQueue->head++];\n    taskQueue->cnt -= 1;\n    DBG(BLUE"<POP>"NONE "%s cnt = %d\\n", str, taskQueue->cnt);\n    if (taskQueue->head == taskQueue->size) taskQueue->head = 0;\n    //pthread_cond_broadcast(&(taskQueue->cond);\n    pthread_mutex_unlock(&taskQueue->mutex);\n    return str;\n}\n\nvoid task_queue_clear(struct task_queue *taskQueue) {\n    \n    if (taskQueue == NULL) return ;\n    free(taskQueue->data);\n    free(taskQueue);\n    return ;\n}\n\nvoid *thread_run(void *arg) {\n    printf("thread_run ready\\n");\n    pthread_detach(pthread_self());\n    struct task_queue *taskQueue = (struct task_queue *)arg;\n    while (1) {\n        //DBG(BLUE"<run>"NONE"thread_run_lock\\n");\n        char *str = task_queue_pop(taskQueue);\n        printf(RED"<%ld>"NONE"%s\\n", pthread_self(), str);\n        //sleep(1);\n    }\n}\n')),(0,s.kt)("h2",{id:"6\u6d88\u606f\u961f\u5217"},"6.\u6d88\u606f\u961f\u5217"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"\u975e\u4eb2\u7f18\u901a\u8fc7key_t ftok(path, id);"),(0,s.kt)("li",{parentName:"ol"},"\u516c\u5171\u5934\u6587\u4ef6key"),(0,s.kt)("li",{parentName:"ol"},"\u4eb2\u7f18\u8fdb\u7a0b")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/ipc.h>\n#include <sys/msg.h>\n\nstruct msgbuf {\n    long mtype;\n    char mtext[80];\n};\n\nstatic void\nusage(char *prog_name, char *msg)\n{\n    if (msg != NULL)\n    fputs(msg, stderr);\n\n    fprintf(stderr, "Usage: %s [options]\\n", prog_name);\n    fprintf(stderr, "Options are:\\n");\n    fprintf(stderr, "-s        send message using msgsnd()\\n");\n    fprintf(stderr, "-r        read message using msgrcv()\\n");\n    fprintf(stderr, "-t        message type (default is 1)\\n");\n    fprintf(stderr, "-k        message queue key (default is 1234)\\n");\n    exit(EXIT_FAILURE);\n}\n\nstatic void\nsend_msg(int qid, int msgtype)\n{\n    struct msgbuf msg;\n    time_t t;\n\n    msg.mtype = msgtype;\n\n    time(&t);\n    snprintf(msg.mtext, sizeof(msg.mtext), "a message at %s",\n             ctime(&t));\n\n    if (msgsnd(qid, (void *) &msg, sizeof(msg.mtext),\n               IPC_NOWAIT) == -1) {\n                   perror("msgsnd error");\n                   exit(EXIT_FAILURE);\n               }\n    printf("sent: %s\\n", msg.mtext);\n}\n\nstatic void\nget_msg(int qid, int msgtype)\n{\n    struct msgbuf msg;\n\n    if (msgrcv(qid, (void *) &msg, sizeof(msg.mtext), msgtype,\n               MSG_NOERROR | IPC_NOWAIT) == -1) {\n                   if (errno != ENOMSG) {\n                       perror("msgrcv");\n                       exit(EXIT_FAILURE);\n                   }\n                   printf("No message available for msgrcv()\\n");\n               } else\n    printf("message received: %s\\n", msg.mtext);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int qid, opt;\n    int mode = 0;               /* 1 = send, 2 = receive */\n    int msgtype = 1;\n    int msgkey = 1234;\n\n    while ((opt = getopt(argc, argv, "srt:k:")) != -1) {\n        switch (opt) {\n            case \'s\':\n            mode = 1;\n            break;\n            case \'r\':\n            mode = 2;\n            break;\n            case \'t\':\n            msgtype = atoi(optarg);\n            if (msgtype <= 0)\n            usage(argv[0], "-t option must be greater than 0\\n");\n            break;\n            case \'k\':\n            msgkey = atoi(optarg);\n            break;\n            default:\n            usage(argv[0], "Unrecognized option\\n");\n        }\n    }\n\n    if (mode == 0)\n    usage(argv[0], "must use either -s or -r option\\n");\n\n    qid = msgget(msgkey, IPC_CREAT | 0666);\n\n    if (qid == -1) {\n        perror("msgget");\n        exit(EXIT_FAILURE);\n    }\n\n    if (mode == 2)\n    get_msg(qid, msgtype);\n    else\n    send_msg(qid, msgtype);\n\n    exit(EXIT_SUCCESS);\n}\n\n')),(0,s.kt)("h2",{id:"7\u4fe1\u53f7\u91cfpv\u64cd\u4f5c"},"7.\u4fe1\u53f7\u91cfPV\u64cd\u4f5c"),(0,s.kt)("p",null,"POSIX \u4fe1\u53f7\u91cf\u4e0eSYSTEM V\u4fe1\u53f7\u91cf\u7684\u6bd4\u8f83\n\u5bf9POSIX\u6765\u8bf4\uff0c\u4fe1\u53f7\u91cf\u662f\u4e2a\u975e\u8d1f\u6574\u6570\u3002\u5e38\u7528\u4e8e\u7ebf\u7a0b\u95f4\u540c\u6b65\u3002\n\u800cSYSTEM V\u4fe1\u53f7\u91cf\u5219\u662f\u4e00\u4e2a\u6216\u591a\u4e2a\u4fe1\u53f7\u91cf\u7684\u96c6\u5408\uff0c\u5b83\u5bf9\u5e94\u7684\u662f\u4e00\u4e2a\u4fe1\u53f7\u91cf\u7ed3\u6784\u4f53\uff0c\u8fd9\u4e2a\u7ed3\u6784\u4f53\u662f\u4e3aSYSTEM V IPC\u670d\u52a1\u7684\uff0c\u4fe1\u53f7\u91cf\u53ea\u4e0d\u8fc7\u662f\u5b83\u7684\u4e00\u90e8\u5206\u3002\u5e38\u7528\u4e8e\u8fdb\u7a0b\u95f4\u540c\u6b65\u3002"),(0,s.kt)("p",null,"POSIX\u4fe1\u53f7\u91cf\u7684\u5f15\u7528\u5934\u6587\u4ef6\u662f",(0,s.kt)("inlineCode",{parentName:"p"},"<semaphore.h>"),"\uff0c\u800cSYSTEM V\u4fe1\u53f7\u91cf\u7684\u5f15\u7528\u5934\u6587\u4ef6\u662f",(0,s.kt)("inlineCode",{parentName:"p"},"<sys/sem.h>")),(0,s.kt)("p",null,"\u4ece\u4f7f\u7528\u7684\u89d2\u5ea6\uff0cSystem V\u4fe1\u53f7\u91cf\u662f\u590d\u6742\u7684\uff0c\u800cPosix\u4fe1\u53f7\u91cf\u662f\u7b80\u5355\u3002\u6bd4\u5982\uff0cPOSIX\u4fe1\u53f7\u91cf\u7684\u521b\u5efa\u548c\u521d\u59cb\u5316\u6216PV\u64cd\u4f5c\u5c31\u5f88\u975e\u5e38\u65b9\u4fbf\u3002"),(0,s.kt)("p",null,"\u539f\u5b50:\u4e0d\u53ef\u518d\u5206"),(0,s.kt)("p",null,"\u94f6\u884c\u5bb6\u7b97\u6cd5"),(0,s.kt)("p",null,"\u8bfb\u5199\u8005\u95ee\u9898"),(0,s.kt)("p",null,"\u751f\u4ea7\u8005\u6d88\u8d39\u8005\u95ee\u9898"),(0,s.kt)("p",null,"PV\u64cd\u4f5c\u81ea\u5e26\u9501"))}p.isMDXComponent=!0}}]);