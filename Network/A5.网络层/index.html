<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.0">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Wiki Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Wiki Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">A5.网络层 | My Wiki</title><meta data-react-helmet="true" property="og:url" content="https://worst0.github.io/Network/A5.网络层"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="A5.网络层 | My Wiki"><meta data-react-helmet="true" name="description" content="概述"><meta data-react-helmet="true" property="og:description" content="概述"><meta data-react-helmet="true" property="og:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://worst0.github.io/Network/A5.网络层"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Network/A5.网络层" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Network/A5.网络层" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.060912d8.css">
<link rel="preload" href="/assets/js/runtime~main.8bd170ed.js" as="script">
<link rel="preload" href="/assets/js/main.30834e93.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div><a href="#main" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle" type="button" tabindex="0"><svg aria-label="Menu" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a><a class="navbar__item navbar__link navbar__link--active" href="/intro">Document💻</a><a class="navbar__item navbar__link" href="/blog">Blog🤓</a><a class="navbar__item navbar__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a><a class="navbar__item navbar__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">本站源码</a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled" role="button" tabindex="-1"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">🌙</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><strong class="navbar__title">My Wiki</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/intro">Document💻</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog🤓</a></li><li class="menu__list-item"><a class="menu__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a></li><li class="menu__list-item"><a class="menu__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></li><li class="menu__list-item"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li><li class="menu__list-item"><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="menu__link">本站源码</a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><div class="docSidebarContainer_3Kbt" role="complementary"><div class="sidebar_15mo"><div class="menu menu--responsive thin-scrollbar menu_Bmed"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">intro</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/intro">Readme</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">1.Linux</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Linux 命令</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A1.linux基础">A1.linux基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A2.Linux命令">A2.Linux命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A3.编译环境">A3.编译环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A4.数据提取">数据提取</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A5.Linux命令补充">Linux命令</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">shell脚本</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/B1.shell脚本语法">shell脚本语法</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">ubuntu</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C1.ubuntu相关">C1.ubuntu相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C2.ubuntu常用软件">ubuntu常用软件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C3.语言环境">语言环境</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">2.Algorithm</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">数据结构</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A1.DataStructure">数据结构和算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A2.数组和链表">数组和链表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A3.栈和队列">栈,队列</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A4.堆和优先队列">堆和优先队列</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A5.哈夫曼树">哈弗曼树与哈弗曼编码</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A6.哈希表">哈希表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.排序">排序</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.树">树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A8.字符串匹配">字符串匹配</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.字典树">字典树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.树状数组和线段树">树状数组和线段树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.平衡树">平衡树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.并查集">并查集</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A12.图论">图论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A15.位图和跳表">位图和跳表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A99.实现ADT">实现ADT</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">算法设计</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B1.算法分析">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B10.数论">数论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B11.位运算">位运算</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B12.计算几何">计算几何</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B13.网络流">网络流</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B2.贪心">贪心</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B3.递推到递归">递推</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B4.动态规划">==动态规划==</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B5.分治">分而治之（divide-and-conquer）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B6.减治和双指针">B6.减治和双指针</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B7.回溯">回溯法（backtracking）</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B8.搜索">B8.搜索</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B9.数学">数学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B98.字符串">字符串</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B99.专题">专题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.Algorithm">算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.算法技巧">算法技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C2.编程珠玑">编程珠玑</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">Think</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/D1.ACM模板">ACM模板</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E1.concrete">concrete</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E2.Combinatorics">组合数学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/G1.逻辑思考">逻辑思考</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/H1.算法谜题">算法谜题</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">3.Online_Judge</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/A1.Leetcode">Leetcode</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/B1.HZOJ">HZOJ</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/C1.nowcoder">Nowcoder</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/D1.EP">欧拉EP</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/E1.编程技巧">编程技巧</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">4.Programming_Language</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">C</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A1.CBasic">C语言基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A2.Cimprove">C语言进阶</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A3.C语言技巧">C语言技巧</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">C++</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B1.C++-basic">C++基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B2.C++-improve">C++进阶</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B3.C++-exercise">C++-exercise</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B4.C++-others">C++ othres</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B5.C++编译">C++编译</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B6.C++-question">C++-question</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">STL</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C1.STL">STL</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C2.STL-question">STL-question</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">python</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/D1.python">python</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/E1.conda">conda命令</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">5.Programming_Stardard</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/A1.C编程规范">C编程规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.编码英文缩写">编码英文缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.计算机哲学">B1.计算机哲学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B2.英文标准缩写">英文标准缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/C1.重构">重构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/D1.Design_Pattern">Design Pattern</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">6.Operating_system</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A1.os">OS</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A2.OS概述">OS概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A2.操作系统">操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A3.进程与线程">进程管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A4.死锁">死锁</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A5.存储管理">存储管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A6.设备管理">设备管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A7.文件系统">文件系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A8.输入输出">输入输出</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A9.编译系统">编译系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/C1.计算机原理">计算机原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/D1.CSAPP">CSAPP</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!" tabindex="-1">系统编程</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A1.os">OS</a></li></ul></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">7.Network</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Network/A2.网络概论">网络概论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Network/A3.物理层">物理层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Network/A4.链路层">链路层</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/Network/A5.网络层">网络层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Network/A6.传输层">传输层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Network/A7.应用层">应用层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Network/A9.疑问">疑问</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Network/B1.HTTP">HTTP</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">8.Server</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/A1.Linux高性能服务器">Linux高性能服务器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.Linux多线程muduo">C++多线程系统编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.系统编程">系统编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B2.文件IO">文件IO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B3.文件和目录">文件和目录</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B4.标准IO库">标准IO库</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B9.命令">B9.命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络API">C1.网络API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络编程">C1.网络编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C2.高级IO函数">C2.高级IO函数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C3.程序规范">C3.程序规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C4.IO复用">C4.IO复用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C5.信号">C5.信号</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C6.定时器">C6.定时器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C7.高性能服务器框架">C7.高性能服务器框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C8.socket">网络编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C9.实现">C9.实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D1.多进程编程">D1.多进程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D2.进程">进程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D4.进程间通信">IPC：进程间通信</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E1.多线程编程">E1.多线程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E2.线程">线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/H1.网络工具">H1.网络工具</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">9.Database</a><ul class="menu__list"></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">10.Skill</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/A1.Latex数学公式">A1.Latex数学公式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/B1.Markdown语法">Markdown语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C1.git">Git</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C2.github">GitHub</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/D1.计算机英语">计算机英语</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/E1.绘图">绘图</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">11.Interview</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/A1.面试">A1.面试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/A2.interview">interview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Interview/C1.简历">简历</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">13.Project</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A1.Gtest测试框架">A1.Gtest测试框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A2.udp-football">A2.udp-football</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">14.Science</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/E3.数学认识">数学认识</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/F1.物理认识">物理认识</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">99.other</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/A1.临时">临时</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/B1.临时笔记">临时笔记</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/C1.task">task</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/D1.软件需求">软件需求</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/E1.software">E1.software</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3ufF"><div class="container padding-vert--lg docItemWrapper_3FMP"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><header><h1 class="docTitle_3a4h">网络层</h1></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="概述"></a>概述<a class="hash-link" href="#概述" title="Direct link to heading">#</a></h2><blockquote><p>负责在不同的网络之间转发数据包，基于数据包的 <code>IP</code>地址转发，每个数据包可以按照不同路径传输。网络层不负责丢包重传，以及数据包之间数据顺序的的问题。</p></blockquote><p>因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p><p> <a href="https://camo.githubusercontent.com/8583dbfe01c04f3328e2ee5e4e47f5025916b6ab7194f5fecdf5659b1187e2bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38643737396162372d666663632d343763362d393065632d6564653832363062323336382e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38643737396162372d666663632d343763362d393065632d6564653832363062323336382e706e67-dc51acaf74c698138aa88c7dbf8b917a.bin"></a> </p><p>IP（Internet Protocol，网际协议）是为计算机网络相互连接进行通信而设计的协议。</p><p>与 IP 协议配套使用的还有三个协议：</p><ul><li>地址解析协议 ARP（Address Resolution Protocol）</li><li>网际控制报文协议 ICMP（Internet Control Message Protocol）</li><li>网际组管理协议 IGMP（Internet Group Management Protocol）</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="引言"></a>引言<a class="hash-link" href="#引言" title="Direct link to heading">#</a></h3><p>IP提供的是不可靠、无连接的数据报传送服务：</p><ol><li>不可靠的意思是它不能保证IP数据报能成功地到达目的地。IP仅提供最好的传输服务。如果发生某种错误时，如某个路由器暂时用完了缓冲区，IP有一个简单的错误处理算法：丢弃该数据报，然后发送ICMP消息报给信源端。任何要求的可靠性必须由上层来提供（如TCP）。</li><li>无连接的意思是IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。这也说明，IP数据报可以不按发送顺序接收。</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="网络设备"></a>网络设备<a class="hash-link" href="#网络设备" title="Direct link to heading">#</a></h2><ul><li>路由器工作在第三层：网络层，能看到网络层的地址，进行转发数据包。   <ul><li>网关，就是路由器地址。当需要路由器转发的时候，告诉主机数据从指定网关出发。</li><li>网关一般是这个网络里第一个能用的地址，比如<code>10.0.0.1</code></li><li>路由器有个路由表，告诉路由器可以达到哪些地方。</li></ul></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="网络设备和osi模型关系"></a>网络设备和<code>OSI</code>模型关系<a class="hash-link" href="#网络设备和osi模型关系" title="Direct link to heading">#</a></h3><p>整个数据发送的准备过程如下：</p><ul><li>应用层将要发送的数据文件准备好,</li><li>传输层<ul><li>根据传输层的协议的字节限制，决定是否要将待传输的数据分段。</li><li>为每个片段数据添加上传输层的网络协议，</li><li>为每个片段数据添加要发送的目的<code>ip</code>地址和源<code>ip</code>地址。</li></ul></li><li>在数据链路层要分两种情况：<ul><li>如果要发生数据的目的ip地址和源ip地址，就会广播给同一个网络段的所有主机，来获得mac地址，使用自己的子网掩码判断自己在哪个网段使用自己的子网掩码判断目标地址在哪个网络，如果是同一个网段，用<code>ARP</code>协议广播解析目标<code>ip</code>地址的<code>mac</code>地址</li><li>如果目的<code>ip</code>地址在另一个网络段，那么数据就要通过路由器转发，那么就要通过网关地址获取路由器的<code>mac</code>地址。<br>当获取了<code>mac</code>地址，数据链路层就会为来自网络层的<code>ip</code>数据包添加上目的<code>mac</code>地址和源<code>mac</code>地址以及<code>fcs</code>校验码，就可以在链路上传输。</li></ul></li></ul><p>接受段与之相反，层层解除封装</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="设备作用"></a>设备作用<a class="hash-link" href="#设备作用" title="Direct link to heading">#</a></h4><ul><li>集线器：用于传输比特率，加强信号。</li><li>交换机：接受存储比特率，看 <strong>数据帧的目标mac地址</strong>，选择出口，决定哪个出口转发</li><li>路由器：接受存储比特流，先看目的mac地址，是不是自己，如果是，则去掉mac地址部分以及fcs校验部分，查看目的ip然后根据路由表选择出口，然后加上mac地址重新封装，转发数据</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="设备与数据流动"></a>设备与数据流动<a class="hash-link" href="#设备与数据流动" title="Direct link to heading">#</a></h4><p>  <img alt="数据发送" src="/assets/images/网络层_数据发送-a7838f076d32e00b67156e7d535b848e.png"></p><ul><li>交换机：看到的是数据帧的流动  </li><li>路由器：看到的是数据包的流动  </li><li>物理层：看到的是比特流的流动</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ip-数据报格式"></a>IP 数据报格式<a class="hash-link" href="#ip-数据报格式" title="Direct link to heading">#</a></h2><p> <img alt="IP数据报" src="/assets/images/IP数据报-e4a65a5b05dae8e5a67419be964fa90a.png"></p><p><img src="/assets/images/6.IP数据包-c919bcad8ef5dc5ee6b4a654fcc351c6.png"></p><ul><li><p><strong>版本</strong>   : 有 4（IPv4）和 6（IPv6）两个值；</p></li><li><p><strong>首部长度</strong>   : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。</p></li><li><p><strong>区分服务</strong>   : 用来获得更好的服务，一般情况下不使用。</p></li><li><p><strong>总长度</strong>   : 包括首部长度和数据部分长度。IP数据报最长可达65535字节。</p></li><li><p><strong>标识</strong>   : 唯一地标识主机发送的每一份数据报。在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。</p></li><li><p><strong>生存时间</strong>   ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，每经过一次路由器处理，值减1。当 TTL 为 0 时就丢弃数据报，并发送ICMP报文通知源主机。</p></li><li><p><strong>上层协议</strong>  ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p></li><li><p><strong>首部检验和</strong>  ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。</p></li><li><p><strong>片偏移</strong>   : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p><p><a href="https://camo.githubusercontent.com/5a2935c7e397acf88b53a3b9ff7ad79a254cc814c581d667673a55cd4387c020/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32336261383930652d653131632d343565322d613230632d3634643231376638333433302e706e67-c2901daf0a1c7f000f29c04b65594a72.bin"></a> </p></li><li><p>最后一个字段是任选项，是可变长的可选信息，定义如下：</p><ul><li>安全和处理限制</li><li>记录路径（让每个路由器都记下它的IP）</li><li>时间戳（让每个路由都记下它的IP地址和时间）</li><li>宽松/严格的源站选录</li></ul><p>传输数据之前把首部转换成网络字节序：注意大端和小端。</p></li></ul><ol><li><code>Telnet</code> 和 <code>Rlogin</code> 这两个交互应用要求最小的传输时延，因为主要用它们来传输少量的交互数据。</li><li><code>FTP</code> 文件传输则要求有最大的吞吐量。</li><li>网络管理（<span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>N</mi><mi>M</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">S N M P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mord mathnormal" style="margin-right:0.10903em">M</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span></span>）和路由选择协议要求最高可靠性</li><li>用户网络新闻（ Usenet news, NNTP）是唯一要求最小费用的应用</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ip-地址编址方式"></a>IP 地址编址方式<a class="hash-link" href="#ip-地址编址方式" title="Direct link to heading">#</a></h2><p>互联网上的每个接口必须有一个唯一的Internet地址（也称作IP地址）。IP地址长32bit。</p><p>IP 地址的编址方式经历了三个历史阶段：</p><ul><li>分类</li><li>子网划分</li><li>无分类</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-分类"></a>1. 分类<a class="hash-link" href="#1-分类" title="Direct link to heading">#</a></h3><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。</p><p><code>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</code></p><p> <a href="https://camo.githubusercontent.com/99d2502a42dff18fb88daf91406b8f1dd106bcc6b40bef500cac55e27fd9a795/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63626635306562382d323262342d343532382d613265372d6431383731343364353766372e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63626635306562382d323262342d343532382d613265372d6431383731343364353766372e706e67-3b7b01adc8b440665c5268f791fe8cad.bin"></a> </p><table><thead><tr><th>IP 地址类别</th><th>网络号</th><th>网络范围</th><th>主机号</th><th>IP 地址范围</th></tr></thead><tbody><tr><td>A 类</td><td>8bit，第一位固定为 0</td><td>0 —— 127</td><td>24bit</td><td>1.0.0.0 —— 127.255.255.255</td></tr><tr><td>B 类</td><td>16bit，前两位固定为  10</td><td>128.0 —— 191.255</td><td>16bit</td><td>128.0.0.0 —— 191.255.255.255</td></tr><tr><td>C  类</td><td>24bit，前三位固定为  110</td><td>192.0.0 —— 223.255.255</td><td>8bit</td><td>192.0.0.0 —— 223.255.255.255</td></tr><tr><td>D  类</td><td>前四位固定为 1110，后面为多播地址</td><td></td><td></td><td>224.0.0.0 - 239.255.255.255</td></tr><tr><td>E  类</td><td>前五位固定为 11110，后面保留为今后所用</td><td></td><td></td><td>240.0.0.0 - 255.255.255.255</td></tr></tbody></table><p>分配IP地址的机构是互联网络信息中心（InterNIC）。只分配网络号，管理员分配主机号。</p><p>有三类IP地址：</p><ol><li>单播地址（单个主机）</li><li>广播地址（给定网络上的所有主机）</li><li>多播地址（同一组内的所有主机）</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-子网划分"></a>2. 子网划分<a class="hash-link" href="#2-子网划分" title="Direct link to heading">#</a></h3><p>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。</p><p><code>IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}</code></p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><p>给定<code>IP</code>地址和子网掩码以后，主机就可以确定<code>IP</code>数据报的目的地是 </p><ul><li>本子网上的主机；</li><li>本网络中其他子网中的主机；</li><li>其他网络上的主机</li></ul><blockquote><p>在一般的体制中，<code>IP</code> 可以从传输层接收数据报并进行发送，或者从一个网络接口接收数据报（待转发的数据报）并进行发送。 <code>IP</code>层在内存中有一个路由表。当收到一份数据报并进行发送时，它都要对该表搜索一次。当数据报来自某个网络接口时， <code>IP</code> 首先检查目的 <code>IP</code> 地址是否为本机的 <code>IP</code>地址之一或者 <code>IP</code> 广播地址。如果确实是这样，数据报就被送到由 <code>IP</code> 首部协议字段所指定的协议模块进行处理。如果数据报的目的不是这些地址，那么（ 1）如果<code>IP</code>层被设置为路由器的功能，那么就对数据报进行转发（也就是说，像下面对待发出的数据报一样处理）；否则（ 2）数据报被丢弃</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-无分类"></a>3. 无分类<a class="hash-link" href="#3-无分类" title="Direct link to heading">#</a></h3><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。</p><p><code>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}</code></p><p>CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p>一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为   <strong>构成超网</strong>  。</p><p>在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="地址解析协议-arp"></a>地址解析协议 ARP<a class="hash-link" href="#地址解析协议-arp" title="Direct link to heading">#</a></h2><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。</p><p> <a href="https://camo.githubusercontent.com/672684df156efa916315f9e1bbcdde78539caa8ec6e8a3d0d782842687dbc113/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36363139323338322d353538622d346230352d613335642d6163346132623161393831312e6a7067" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36363139323338322d353538622d346230352d613335642d6163346132623161393831312e6a7067-d4f5daebbd0ecbc3eee8c02cc642ba96.bin"></a> </p><p>一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据48bit的以太网地址来确定目的接口的。</p><p><code>ARP</code>是为<code>IP</code>地址到对应的MAC硬件地址之间提供动态映射。动态意思是这个过程是自动完成的，<code>ARP</code>是为32位的Ip地址个数据链路层48位的MAC地址之间提供映射。</p><p> <a href="https://camo.githubusercontent.com/81c45941a689239d8a0ef8c121b17a5a82ba3a626e92a7bf5c3cf53c6035ea26/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62396437396135612d653761662d343939622d623938392d6631303438336537316238622e6a7067" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62396437396135612d653761662d343939622d623938392d6631303438336537316238622e6a7067-86183f3681640de527e0a0f950f25307.bin"></a> </p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="arp高速缓存"></a>ARP高速缓存<a class="hash-link" href="#arp高速缓存" title="Direct link to heading">#</a></h4><p>ARP高效运行的关键是由于每个主机上都有一个ARP高速缓存。这个高速缓存存放了最近Internet地址到硬件地址之间的映射记录。</p><p><code>arp</code> 命令用来检查ARP高速缓存：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly shell"><div tabindex="0" class="prism-code language-shell codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">arp -a</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">192.168</span><span class="token plain">.100.1</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> at7c:8:d9:87:e5:85 on en0 ifscope </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">ethernet</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"> </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">192.168</span><span class="token plain">.100.255</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> at</span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token plain">incomplete</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> on en0 ifscope </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">ethernet</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">_gateway </span><span class="token punctuation" style="color:rgb(199, 146, 234)">(</span><span class="token number" style="color:rgb(247, 140, 108)">172.17</span><span class="token plain">.63.253</span><span class="token punctuation" style="color:rgb(199, 146, 234)">)</span><span class="token plain"> at ee:ff:ff:ff:ff:ff </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token plain">ether</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"> on eth0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。</p><p>如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A  通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A  向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。</p><p> <a href="https://camo.githubusercontent.com/5d95edea7325dae076f51fd76cbca2ac7c72cf75a3a5f721dad16f5c5977dc13/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303036613435302d366332662d343938632d613932382d6339323766373538623164302e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38303036613435302d366332662d343938632d613932382d6339323766373538623164302e706e67-0c8c577f7b97c9d08c81c477d5bce2d9.bin"></a> </p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="arp协议的作用"></a>ARP协议的作用<a class="hash-link" href="#arp协议的作用" title="Direct link to heading">#</a></h4><p>网络层使用的是IP地址，数据链路层使用的是硬件地址。
ARP协议的用途是为了从网络层使用的IP地址，解析出数据链路层使用的硬件地址。</p><ul><li>在主机ARP高速缓存中存放一个从IP地址到硬件地址的映射表</li><li>当需要解析时，先去arp缓存表(存着ip-mac对应关系)去查找目标ip的mac地址</li><li>如果查到了，将目标ip的mac地址封装到链路层数据报</li><li>如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX，所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单播的形式将自己的mac地址回复给请求的机器 </li></ul><p><code>ARP</code>工作在网络层，当需要把一个数据从源主机发送目的主机时：</p><ul><li>如果目的主机在本地网络，那么ip数据报就可以直接送到目的主机上</li><li>如果目的主机在远程网络上，那么就通过ip选路来确定本地网络的下一跳路由器地址，并且让它转发IP数据。  </li></ul><p>在这个过程中，发送端主机必须要把32位的IP地址变成48位的MAC地址，<strong>从逻辑的IP地址到对应的物理硬件地址需要进行翻译，这就是<code>APR</code>的作用</strong>。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="arp请求应答"></a>ARP请求/应答<a class="hash-link" href="#arp请求应答" title="Direct link to heading">#</a></h4><blockquote><p>在<code>ARP</code>背后有一个基本概念，那就是网络接口有一个硬件地址。在硬件层次上进行的数据帧交换必须有正确的接口地址。但是，<code>TCP/IP</code>有自己的地址：32 bit的I P地址。知道主机的<code>IP</code>地址并不能让内核发送一帧数据给主机。内核（如以太网驱动程序）必须知道目的端的硬件地址才能发送数据。<code>ARP</code>的功能是在32 bit的<code>IP</code>地址和采用不同网络技术的硬件地址之间提供动态映射。</p></blockquote><p>  <img alt="ARP" src="/assets/images/网络层_ARP_请求应答格式-36e3970c91c84ded1e76ee4c641e5283.png"></p><ul><li><code>ARP</code> 请求<br>在确定下一条的路由器或者主机的时候，需要发送端发送一个称为“ <code>ARP</code> 请求的以太网数据帧给以太网上的每个主机”，就是广播。 <code>ARP</code> 请求数据帧，包含目的主机的 <code>IP</code> 地址，目的端的 <code>MAC</code> 地址是48位的1(<code>0XFF:FF:FF:FF:FF</code>)。意思是，同一个网络段的所有主机都处理这个 <code>APR</code> 请求，如果你是这个 <code>IP</code> 地址拥有者，请回答你的硬件地址。</li><li><code>ARP</code> 应答
目的主机的ARP接受到这份广播后，识别出这是在询问发送端在询问他的IP地址，于是发送一个ARP应答：在ARP应答中，将会包含IP地址和对应的硬件地址。收到ARP应答后，使ARP进行请求- 应答交换的IP数据报现在就可以传送了。</li></ul><p>对于一个ARP请求来说，除目的端硬件地址外的所有其他的字段都有填充值。目的端硬件地址为0XFF:FF:FF:FF:FF。当系统收到一份目的端为本机的 ARP请求报文后，它就把硬件地址填进去。</p><p>完成一次，ARP应答和ARP请求之后的IP数据包就可以在链路上进行传输，当发送和目的端不在同一个网络会重复这个过程，直到到达目的主机。如果在同一个网络，那么一次ARP应答-请求就可以到达目的主机。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="arp分组格式"></a>ARP分组格式<a class="hash-link" href="#arp分组格式" title="Direct link to heading">#</a></h4><div class="math math-display"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>R</mi><mo>←</mo><mi>α</mi><mi>R</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">R \leftarrow \alpha R + (1 - \alpha)M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mspace" style="margin-right:0.2777777777777778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.10903em">M</span></span></span></span></span></div><p>目的地址为全1的特殊地址是广播地址。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="arp代理"></a><code>ARP</code>代理<a class="hash-link" href="#arp代理" title="Direct link to heading">#</a></h4><blockquote><p><code>ARP</code> 请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作ARP代理(<code>Proxy ARP</code>)。这样可以欺骗发起ARP请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”</p></blockquote><p>ARP代理的其他用途：通过两个物理网络之间的路由器可以互相隐藏物理网络。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="小结"></a>小结<a class="hash-link" href="#小结" title="Direct link to heading">#</a></h3><p>当一台主机把以太网数据帧发送到位于同一局域网上的另一台主机时，是根据 48 bit的以太网地址来确定目的接口的。设备驱动程序从不检查 I P数据报中的目的I P地址。
地址解析为这两种不同的地址形式提供映射： 32 bit的IP地址和数据链路层使用的任何类型的地址。</p><p> <code>ARP</code> 为I P地址到对应的硬件地址之间提供动态映射。动态这个词是因为这个过程是自动完成的，一般应用程序用户或系统管理员不必关心。
<code>RARP</code> 是被那些没有磁盘驱动器的系统使用（一般是无盘工作站或 X终端），它需要系统管理员进行手工设置。</p><p>在大多数的 T C P / I P实现中， <code>ARP</code> 是一个基础协议，但是它的运行对于应用程序或系统管理员来说一般是透明的。  <code>ARP</code> 高速缓存在它的运行过程中非常关键，我们可以用  <code>arp</code> 命令对高速缓存进行检查和操作。高速缓存中的每一项内容都有一个定时器，根据它来删除不完整和完整的表项。 <code>arp</code> 命令可以显示和修改 <code>ARP</code> 高速缓存中的内容。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="rarp：逆地址解析协议"></a>RARP：逆地址解析协议<a class="hash-link" href="#rarp：逆地址解析协议" title="Direct link to heading">#</a></h2><p><strong>网络上的每个系统都具有唯一的硬件地址</strong></p><p>无盘系统的RARP实现过程是从接口卡上读取唯一的硬件地址，然后发送一份RARP请求（一帧在网络上广播的数据），请求某个主机响应该无盘系统的IP地址（在RARP应答中）。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="rarp的分组格式"></a>RARP的分组格式<a class="hash-link" href="#rarp的分组格式" title="Direct link to heading">#</a></h4><p>RARP分组的格式与ARP分组基本一致。它们之间主要的差别是RARP请求或应答的帧类型代码为 0x8035，而且RARP请求的操作代码为 3，应答操作代码为4。</p><p>对应于ARP，RARP请求以广播方式传送，而RARP应答一般是单播(unicast)传送的 。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="rarp服务器的设计"></a>RARP服务器的设计<a class="hash-link" href="#rarp服务器的设计" title="Direct link to heading">#</a></h4><p>RARP服务器的功能由用户进程来提供，原因在于硬件地址和IP地址的映射保存在磁盘文件中，内核一般不读取和分析磁盘文件。</p><p>RARP请求是作为一个特殊类型的以太网数据帧发送的。</p><p>RARP服务器实现的一个复杂因素是 RARP请求是在硬件层上进行广播的，这意味着它们不经过路由器进行转发。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="小结-1"></a>小结<a class="hash-link" href="#小结-1" title="Direct link to heading">#</a></h3><p>RARP协议是许多无盘系统在引导时用来获取 IP地址的。RARP分组格式基本上与 ARP分组一致。一个<code>RARP</code> 请求在网络上进行广播，它在分组中标明发送端的硬件地址，以请求相应IP地址的响应。应答通常是单播传送的。
RARP带来的问题包括使用链路层广播，这样就阻止大多数路由器转发 RARP请求，只返回很少信息：只是系统的 IP地址。 BOOTP在无盘系统引导时会返回更多的信息：IP地址和引导主机的名字等。
虽然RARP在概念上很简单，但是 RARP服务器的实现却与系统相关。因此，并不是所有的TCP / IP实现都提供RARP服务器。</p><h2></h2><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="网际控制报文协议-icmp"></a>网际控制报文协议 ICMP<a class="hash-link" href="#网际控制报文协议-icmp" title="Direct link to heading">#</a></h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。<strong>ICMP报文是在IP数据报内部被传输的。</strong></p><p> <a href="https://camo.githubusercontent.com/598b24c2dbb1cd72db45501ace7efcc7754b40267a96c78299ad2e56b70045bf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65333132343736332d663735652d343663332d626138322d3334316536633938643836322e6a7067" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65333132343736332d663735652d343663332d626138322d3334316536633938643836322e6a7067-7a78a840802db19b86628b6016878a4e.bin"></a> </p><p>ICMP 报文分为差错报告报文和询问报文。</p><p> <a href="https://camo.githubusercontent.com/e32adca8dddfd5414550c58747a21d8ca2bdd6ae0e785258f9cbbcff6c85cefc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61613239636338382d373235362d343339392d386337662d3363663461363438393535392e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61613239636338382d373235362d343339392d386337662d3363663461363438393535392e706e67-684d5b8eef350279a8a68c84f3910907.bin"></a></p><p><a href="https://github.com/lutzchuck/tcpip-note/blob/master/img/chap6/img1.png" target="_blank" rel="noopener noreferrer"><img alt="graphic" src="/assets/images/img1-1633581664464-43f7a688f4ddd73d1d788bb026a9a9c1.png"></a></p><p>检验和字段覆盖整个ICMP报文。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="icmp报文的类型"></a>ICMP报文的类型<a class="hash-link" href="#icmp报文的类型" title="Direct link to heading">#</a></h3><p>不同类型由报文中的类型字段和代码字段来共同决定：查询报文 or 差错报文</p><p>下面各种情况都不会导致产生 ICMP 差错报文：
1) ICMP差错报文（但是，ICMP 查询报文可能会产生 ICMP 差错报文）。
2) 目的地址是广播地址或多播地址（D类地址）的 IP 数据报。
3) 作为链路层广播的数据报。
4) 不是 IP 分片的第一片。
5) 源地址不是单个主机的数据报。这就是说，源地址不能为零地址、环回地址、广播地址或多播地址。</p><p>防止过去允许 ICMP 差错报文对广播分组响应所带来的广播风暴。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="icmp地址掩码请求与应答"></a>ICMP地址掩码请求与应答<a class="hash-link" href="#icmp地址掩码请求与应答" title="Direct link to heading">#</a></h3><p>ICMP地址掩码请求用于无盘系统在引导过程中获取自己的子网掩码。系统广播它的ICMP请求报文。无盘系统获取子网掩码的另一个方法是BOOTP协议</p><p><a href="https://github.com/lutzchuck/tcpip-note/blob/master/img/chap6/img2.png" target="_blank" rel="noopener noreferrer"><img alt="graphic" src="/assets/images/img2-ae22b69a1fa36c79d04d9ee0dc8e2c96.png"></a></p><p>ICMP报文中的标识符和序列号字段由发送端任意选择设定，这些值在应答中将被返回。这样，发送端就可以把应答与请求进行匹配</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="icmp时间戳请求与应答"></a>ICMP时间戳请求与应答<a class="hash-link" href="#icmp时间戳请求与应答" title="Direct link to heading">#</a></h3><p>ICMP时间戳请求允许系统向另一个系统查询当前的时间。返回的建议值是自午夜开始计算的毫秒数。这种ICMP报文的好书是提供了毫秒级的分辨率，但调用者必须通过其方法知道当前的日期。 </p><p><a href="https://github.com/lutzchuck/tcpip-note/blob/master/img/chap6/img3.png" target="_blank" rel="noopener noreferrer"><img alt="graphic" src="/assets/images/img3-428f24f9be487a421c689c2acff0b1f2.png"></a></p><p>几乎所有的主机都把接收时间戳和发送时间戳设置成相同的值。我们仍然可以根据接收到应答时的时间值减去发送请求时的时间值算出往返时间（rtt）。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="icmp端口不可达差错"></a>ICMP端口不可达差错<a class="hash-link" href="#icmp端口不可达差错" title="Direct link to heading">#</a></h3><p>UDP的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文。可以用TFTP来强制生成一个端口不可达报文。</p><p>ICMP报文是在主机之间交换的，而不用目的端口号，而每个20字节的UDP数据报。则是从一个特定端口。发送到另一个特定端口。 </p><p><a href="https://github.com/lutzchuck/tcpip-note/blob/master/img/chap6/img4.png" target="_blank" rel="noopener noreferrer"><img alt="graphic" src="/assets/images/img4-94b06374b51865a36dd67d5db6450277.png"></a></p><p>ICMP差错报文必须包括生成该差错报文的数据报IP首部（包含任何选项），还必须至少包括跟在该 IP首部后面的前8个字节。</p><p>一个重要的事实是包含在UDP首部中的内容是源端口号和目的端口号。就是由于目的端口号才导致产生了 ICMP端口不可达的差错报文。接收 ICMP的系统可以根据源端口号来把差错报文与某个特定的用户进程相关联。</p><p>导致差错的数据报中的IP首部要被送回的原因是因为IP首部中包含了协议字段，使得 ICMP可以知道如何解释后面的 8个字节。</p><p><a href="https://github.com/lutzchuck/tcpip-note/blob/master/img/chap6/img5.png" target="_blank" rel="noopener noreferrer"><img alt="graphic" src="/assets/images/img5-f7a9c573222415e9c62ef4d0a4377029.png"></a></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-ping"></a>1. Ping<a class="hash-link" href="#1-ping" title="Direct link to heading">#</a></h2><p><code>Ping</code> 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。通过应用层直接使用网络层ICMP，没有通过运输层TCP和UDP，是通过发送ICMP报文回显请求实现。<code>ping</code>是直接调用网络层，属于网络层。</p><p><code>ping</code>局域网time应该小于10ms，否则比较拥堵,ttl就是生存周期，防止数据包在网络上循环</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>TTL（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量</p><p><a href="https://blog.csdn.net/fd8559350/article/details/52135571" target="_blank" rel="noopener noreferrer">ping发生了什么</a></p><blockquote><ul><li>A主机构建一个ICMP格式的数据包，通过ICMP协议把该数据包和B主机的IP地址一起交给IP协议；</li><li>IP层构建一个数据包（A主机的IP地址+控制信息+B主机的IP地址），获得B主机的MAC地址，以便构建一个数据帧(IP协议会根据B主机的IP地址和自己的子网掩码判断是不是属于同一层网络,如果是属于同一层网络的话,就会获得B主机的MAC地址，如果以前两机有过通信，在A机的ARP缓存表应该有B机IP与其MAC的映射关系，如果没有，就发一个ARP请求广播，得到B机的MAC)</li><li>主机B接受到主机A的发过来的数据帧以后，先检查该帧中包含的B的IP地址，并和本地的物理地址进行比对，如果符合的话，就接受，否则，就抛弃。同样，需要将该数据帧交由自己的IP层协议，IP层检查以后，再交由ICMP协议，构建一个ICMP的应答包，发送给主机A。</li></ul></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-traceroute"></a>2. Traceroute<a class="hash-link" href="#2-traceroute" title="Direct link to heading">#</a></h2><p><code>traceroute</code>程序可以让我们看到IP数据报从一台主机传到另一台主机所经过的路由。</p><p><code>traceroute</code>程序还可以让我们使用IP源路由选项。</p><p><code>Traceroute </code>是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径，及到达其中每一个路由器的往返时间</p><p><code>Traceroute </code>发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><ul><li>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；</li><li>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2  收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。</li><li>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。</li><li>之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</li></ul><p><strong>traceroute</strong></p><ul><li>通过发送UDP报文，设置目的端口为一个不可能的值</li><li>将IP首部中的TTL分别设置从1到N，每次逐个增加</li><li>每次设置TTL后，重新发送数据报，路由器接收到数据报后，将TTL减1，若当前的路由器接收到数据报，发现TTL为1时，会将TTL减1变为0，然后丢弃数据报，发送ICMP时间超过报文</li><li>如果最后一个数据报刚刚达到主机，数据报的TTL是1，此时主机不把TTL减1</li><li>因IP数据报中封装的是无法交付的UDP数据报，此时目的主机向源主机发送ICMP终点不可达差错报文，表示达到目的主机</li></ul><p>traceroute 程序是不可缺少的工具。其操作很简单：开始时发送一个TTL字段为1的UDP数据报，然后将 TTL字段每次加 1，以确定路径中的每个路由器。
每个路由器在丢弃 UDP数据报时都返回一个 ICMP超时报文 2，而最终目的主机则产生一个 ICMP端口不可达的报文。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="traceroute程序的操作"></a>Traceroute程序的操作<a class="hash-link" href="#traceroute程序的操作" title="Direct link to heading">#</a></h3><p>为什么不使用IP记录路由选项（RR）而另外开发一个新的traceroute？</p><ol><li>原先并不是所有的路由器都支持记录路由选项</li><li>记录路由一般是单向的选项</li><li>IP首部中留给选项的空间有限，不能存放当前大多数的路径</li></ol><p>traceroute程序使用ICMP报文和IP首部中的TTL字段。TTL字段是由发送端初始设置一个8bit字段。推荐的初始值由分配数字RFC指定，当前值为64。</p><p>TTL字段的目的是防止数据报在选路时无休止地在网络中流动。当路由器收到一个IP数据报，TTL是0或1，丢弃该数据报，并给信源发送一份ICMP超时信息。Traceroute的关键在于包含这份ICMP信息的IP报文的信源地址是该路由器的IP地址。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="虚拟专用网-vpn"></a>虚拟专用网 VPN<a class="hash-link" href="#虚拟专用网-vpn" title="Direct link to heading">#</a></h2><p>VPN（Virtual Private Network，虚拟专用网）</p><p>由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块：</p><ul><li>10.0.0.0 ~ 10.255.255.255</li><li>172.16.0.0 ~ 172.31.255.255</li><li>192.168.0.0 ~ 192.168.255.255</li></ul><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。</p><p>下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是  10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1  对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址  194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p> <a href="https://camo.githubusercontent.com/9ceca295b4ddcd4eed95c2ce30c2dcb77a0a63c876fbb5c207231124b50d81c0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353536373730622d386330312d343638312d616631302d3436663164663639323032632e6a7067" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31353536373730622d386330312d343638312d616631302d3436663164663639323032632e6a7067-adff6713490b557061edd78cf4484729.bin"></a> </p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="网络地址转换-nat"></a>网络地址转换 NAT<a class="hash-link" href="#网络地址转换-nat" title="Direct link to heading">#</a></h2><p>NAT（Network Address Translation，网络地址转换）</p><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。</p><p>在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n  台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球  IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p><p> <a href="https://camo.githubusercontent.com/2f364857cd2c2a3659e312997b8f3f1809417aeabf23f20d2f3c2f980597b9c5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373139303637652d623239392d343633392d393036352d6265643637323964626630622e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/2f364857cd2c2a3659e312997b8f3f1809417aeabf23f20d2f3c2f980597b9c5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32373139303637652d623239392d343633392d393036352d6265643637323964626630622e706e67" alt="img"></a> </p><p><img alt="img" src="/assets/images/a2c2efa0b214fcd8_img18-1623741071019-e142b692f297f2c295e68fb684537e53.bin"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ip路由选择"></a>IP路由选择<a class="hash-link" href="#ip路由选择" title="Direct link to heading">#</a></h2><p>如果目的主机与源主机直接相连（如点对点链路）或都在一个共享网络上（以太网或令牌环网），那么I P数据报就直接送到目的主机上。否则，主机把数据报发往一默认的路由器上，由路由器来转发该数据报。大多数的主机都是采用这种简单机制。</p><p><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mi>P</mi></mrow><annotation encoding="application/x-tex">IP</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.13889em">P</span></span></span></span></span> 层既可以配置成路由器的功能，也可以配置成主机的功能。当今的大多数多用户系统，包括几乎所有的 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Unix</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em"></span><span class="mord mathnormal" style="margin-right:0.10903em">U</span><span class="mord mathnormal">n</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span></span></span></span></span>​ 系统，都可以配置成一个路由器。本质上的区别在于主机从不把数据报从一个接口转发到另一个接口，而路由器则要转发数据报。内含路由器功能的主机应该从不转发数据报，除非它被设置成那样。</p><p>IP可以从TCP、UDP、ICMP、IGMP接收数据报（即在本地生成的），或者从一个网络接口接收数据报（待转发的）并进行发送。IP层在内存中有个路由表。当收到一份数据报时，它都检索一次表。当数据报来自某个网络接口时，IP首先检查目的IP地址是否为本机的IP地址之一或者IP广播地址。如果是，数据报就被送到由IP首部协议字段所指定的协议模块进行处理。如果数据报目的地址不是这些地址，那么</p><ol><li>如果IP蹭被设置成路由器的功能，那么就对数据报进行转发</li><li>否则丢弃数据报</li></ol><p>IP路由选择是逐跳地（ h o p - b y - h o p）进行的。所有的I P路由选择只为数据报传输提供下一站路由器的 I P地址。它假定下一站路由器比发送数据报的主机更接近目的，而且下一站路由器与该主机是直接相连的。</p><p>I P路由选择主要完成以下这些功能：</p><ol><li>搜索路由表，寻找能与目的 I P地址完全匹配的表目（网络号和主机号都要匹配）。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。</li><li>搜索路由表，寻找能与目的网络号相匹配的表目。如果找到，则把报文发送给该表目指定的下一站路由器或直接连接的网络接口（取决于标志字段的值）。目的网络上的所有主机都可以通过这个表目来处置。例如，一个以太网上的所有主机都是通过这种表目进行寻径的。
这种搜索网络的匹配方法必须考虑可能的子网掩码。</li><li>搜索路由表，寻找标为“默认（ defaul ）”的表目。如果找到，则把报文发送给该表目指定的下一站路由器。</li><li>如果上面这些步骤都没有成功，那么该数据报就不能被传送。如果不能传送的数据报来自本机，那么一般会向生成数据报的应用程序返回一个“主机不可达”或“网络不可达”的错误。</li></ol><p>IP路由选择机制中功能强大的特性</p><ol><li>默认路由，以及下一站路由器发送的 I C M P间接报文（如果我们为数据报选择了错误的默认路由）</li><li>为一个网络指定一个路由器，而不必为每个主机指定一个路由器，极大地缩小路由表的规模</li></ol><p>Attention：</p><ul><li><p>数据报中的目的IP地址始终不发生任何变化。</p></li><li><p>每个链路层可能具有不同的数据帧首部，而且链路层的目的地址（如果有的话）始终指的是下一站的链路层地址。</p></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="子网寻址"></a>子网寻址<a class="hash-link" href="#子网寻址" title="Direct link to heading">#</a></h3><p>子网编址，是把主机号再分成一个子网号和一个主机号。</p><p>由于全0或全1 的主机号都是无效的。</p><p>子网划分缩减了路由表的规模。</p><p>子网对于子网内部的路由器是不透明的。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="子网掩码"></a>子网掩码<a class="hash-link" href="#子网掩码" title="Direct link to heading">#</a></h3><p>这个掩码是一个 32 bit的值，其中值为1的比特留给网络号和子网号，为 0的比特留给主机号。</p><p><img alt="graphic" src="/assets/images/img1-43f7a688f4ddd73d1d788bb026a9a9c1.png"></p><p>给定I P地址和子网掩码以后，主机就可以确定 I P数据报的目的是：</p><ol><li><p>本子网上的主机</p></li><li><p>本网络中其他子网中的主机；</p></li><li><p>其他网络上的主机。</p></li></ol><p>   如果知道本机的 IP地址，那么就知道它是否为A类、B类或C类地址(从I P地址的高位可以得知)，也就知道网络号和子网号之间的分界线。而根据子网掩码就可知道子网号与主机号之间的分界线。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="特殊情况的ip地址"></a>特殊情况的IP地址<a class="hash-link" href="#特殊情况的ip地址" title="Direct link to heading">#</a></h3><p> <img alt="graphic" src="/assets/images/img2-ae22b69a1fa36c79d04d9ee0dc8e2c96.png"></p><table><thead><tr><th>符号</th><th>比特位含义</th></tr></thead><tbody><tr><td>0</td><td>全0</td></tr><tr><td>-1</td><td>全1</td></tr><tr><td>netid</td><td>网络号不全为0或全1</td></tr><tr><td>subnetid</td><td>子网号不全为0或全1</td></tr><tr><td>hostid</td><td>主机号不全为0或全1</td></tr><tr><td>网号栏为空</td><td>该地址没有进行子网划分</td></tr></tbody></table><table><thead><tr><th>IP地址</th><th></th><th></th><th>可以为</th><th></th><th>描述</th></tr></thead><tbody><tr><td>网络号</td><td>子网号</td><td>主机号</td><td>源端</td><td>目的端</td><td></td></tr><tr><td>0</td><td>未划分</td><td>0</td><td>OK</td><td>不可能</td><td>网络上的主机（参见下面的限制）</td></tr><tr><td>0</td><td>未划分</td><td>主机号</td><td>OK</td><td>不可能</td><td>网络上的特定主机（参见下面的限制）</td></tr><tr><td>127</td><td>未划分</td><td>任何值</td><td>OK</td><td>OK</td><td>环回地址</td></tr><tr><td>-1</td><td>未划分</td><td>-1</td><td>不可能</td><td>OK</td><td>受限的广播（永远不被转发）</td></tr><tr><td>netid</td><td>未划分</td><td>-1</td><td>不可能</td><td>OK</td><td>以网络为目的向 netid 广播</td></tr><tr><td>netid</td><td>subnetid</td><td>-1</td><td>不可能</td><td>OK</td><td>以子网为目的向 netid、subnetid广播</td></tr><tr><td>netid</td><td>-1</td><td>-1</td><td>不可能</td><td>OK</td><td>以所有子网为目的向 netid广播</td></tr></tbody></table><p>我们把这个表分成三个部分。表的头两项是特殊的源地址，中间项是特殊的环回地址，最后四项是广播地址。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="路由器的结构"></a>路由器的结构<a class="hash-link" href="#路由器的结构" title="Direct link to heading">#</a></h2><p><img alt="img" src="/assets/images/a2c2efa0b214fcd8_img6-1623741071019-266465bfdb675a728381a3947790a265.bin"></p><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p> <a href="https://camo.githubusercontent.com/3ceb80818b72ef6e68f511bee3ccf2ead93784a533e317757dab1bbad290f3d4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63333336393037322d633734302d343362302d623237362d3230326264316433393630642e6a7067" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63333336393037322d633734302d343362302d623237362d3230326264316433393630642e6a7067-605ed6b8429b7638ddf68f918e2fb7f2.bin"></a> </p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="路由表包含"></a>路由表包含<a class="hash-link" href="#路由表包含" title="Direct link to heading">#</a></h4><ol><li><p>目的IP地址。它既可以是一个完整的主机地址，也可以是一个网络地址，由该表目中的标志字段来指定（如下所述）。主机地址有一个非0的主机号，以指定某一特定的主机，而网络地址中的主机号为0，以指定网络中的所有主机（如以太网，令牌环网）。</p><ul><li>网络 ID（Network ID, Network number）：就是目标地址的网络 ID。</li><li>子网掩码（subnet mask）：用来判断 IP 所属网络</li></ul></li><li><p>下一跳地址/接口（Next hop / interface）：就是数据在发送到目标地址的旅途中下一站的地址。其中 interface  指向 next hop（即为下一个 route）。一个自治系统（AS, Autonomous system）中的 route  应该包含区域内所有的子网络，而默认网关（Network id: <code>0.0.0.0</code>, Netmask: <code>0.0.0.0</code>）指向自治系统的出口。下一跳路由器是指一个在直接相连网络上的路由器，通过它可以转发数据报。下一站路由器不是最终的目的，但是它可以把传送给它的数据报转发到最终目的。</p></li><li><p>标志。其中一个标志指明目的 I P地址是网络地址还是主机地址，另一个标志指明下一站路由器是否为真正的下一站路由器，还是一个直接相连的接口。</p></li><li><p>为数据报的传输指定一个网络接口。</p></li></ol><p>根据应用和执行的不同，路由表可能含有如下附加信息：</p><ol><li>花费（Cost）：就是数据发送过程中通过路径所需要的花费。</li><li>路由的服务质量</li><li>路由中需要过滤的出/入连接列表</li></ol><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="路由器分组转发流程"></a>路由器分组转发流程<a class="hash-link" href="#路由器分组转发流程" title="Direct link to heading">#</a></h2><ul><li><p>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</p></li><li><p>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；</p></li><li><p>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；</p></li><li><p>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；</p></li><li><p>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；</p></li><li><p>报告转发分组出错。</p><p><a href="https://camo.githubusercontent.com/d51a766109f3ba1cd84594d8a8b4edbea27ce791634f16475949d5017921c5fa/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31616234396533392d303132622d343338332d383238342d3236353730393837653363342e6a7067" target="_blank" rel="noopener noreferrer"><img src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31616234396533392d303132622d343338332d383238342d3236353730393837653363342e6a7067-0e1ccc8367dfe882507164eff68d704e.bin"></a> </p></li></ul><p><img alt="img" src="/assets/images/a2c2efa0b214fcd8_img12-1623741071019-f9d53181109a94a0685ca160f374965f.bin"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ip选路"></a>IP选路<a class="hash-link" href="#ip选路" title="Direct link to heading">#</a></h2><p><img alt="img0" src="/assets/images/img0-8a137114666f1e9760e5ff0a631f203a.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="选路的原理"></a>选路的原理<a class="hash-link" href="#选路的原理" title="Direct link to heading">#</a></h3><p>IP搜索路由表的几个步骤：</p><ol><li>搜索匹配的主机地址；</li><li>搜索匹配的网络地址；</li><li>搜索默认表项</li></ol><p>IP层进行的选路实际上是一种选路机制，它搜索路由表并决定向哪个网络接口发送分组。这区别于选路策略，它只是一组决定把哪些路由放入路由表的规则。IP执行选路机制，而路由守护程序则一般提供选路策略。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly bash"><div tabindex="0" class="prism-code language-bash codeBlock_23N8 thin-scrollbar"><div class="codeBlockLines_39YC" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">yanzhiwei@aliyun ~ % </span><span class="token function" style="color:rgb(130, 170, 255)">netstat</span><span class="token plain"> -rn                                                  </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Kernel IP routing table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">0.0</span><span class="token plain">.0.0         </span><span class="token number" style="color:rgb(247, 140, 108)">172.17</span><span class="token plain">.63.253   </span><span class="token number" style="color:rgb(247, 140, 108)">0.0</span><span class="token plain">.0.0         UG        </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">          </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> eth0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">172.17</span><span class="token plain">.48.0     </span><span class="token number" style="color:rgb(247, 140, 108)">0.0</span><span class="token plain">.0.0         </span><span class="token number" style="color:rgb(247, 140, 108)">255.255</span><span class="token plain">.240.0   U         </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">          </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> eth0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">172.17</span><span class="token plain">.63.253   </span><span class="token number" style="color:rgb(247, 140, 108)">0.0</span><span class="token plain">.0.0         </span><span class="token number" style="color:rgb(247, 140, 108)">255.255</span><span class="token plain">.255.255 UH        </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">          </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> eth0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">yanzhiwei@aliyun ~ % </span><span class="token function" style="color:rgb(130, 170, 255)">netstat</span><span class="token plain"> -r                                                   </span><span class="token punctuation" style="color:rgb(199, 146, 234)">[</span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token punctuation" style="color:rgb(199, 146, 234)">]</span><span class="token plain"></span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Kernel IP routing table</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">default         _gateway        </span><span class="token number" style="color:rgb(247, 140, 108)">0.0</span><span class="token plain">.0.0         UG        </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">          </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> eth0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain"></span><span class="token number" style="color:rgb(247, 140, 108)">172.17</span><span class="token plain">.48.0     </span><span class="token number" style="color:rgb(247, 140, 108)">0.0</span><span class="token plain">.0.0         </span><span class="token number" style="color:rgb(247, 140, 108)">255.255</span><span class="token plain">.240.0   U         </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">          </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> eth0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">_gateway        </span><span class="token number" style="color:rgb(247, 140, 108)">0.0</span><span class="token plain">.0.0         </span><span class="token number" style="color:rgb(247, 140, 108)">255.255</span><span class="token plain">.255.255 UH        </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain">          </span><span class="token number" style="color:rgb(247, 140, 108)">0</span><span class="token plain"> eth0</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></div></div></div><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o">Copy</button></div></div><p>对于一个给定的路由器，可以打印出五种不同的标志（ flag）：</p><ul><li>U 该路由可以使用。</li><li>G 该路由是到一个网关（路由器）。如果没有设置该标志，说明目的地是直接相连的。</li><li>H 该路由是到一个主机，也就是说，目的地址是一个完整的主机地址。如果没有设置该标志，说明该路由是到一个网络，而目的地址是一个网络地址：一个网络号，或者网络号与子网号的组合。</li><li>D 该路由是由重定向报文创建的。</li><li>M 该路由已被重定向报文修改。</li></ul><p><strong>标志G区分了间接路由和直接路由（直接路由不设置标志G）。</strong></p><p>发往直接路由的分组中, </p><ul><li><p>目的端的 I P地址</p></li><li><p>目的地链路层地址。</p></li></ul><p>发往直接路由间接路由的分组中，</p><ul><li>目的端的 I P地址,</li><li>链路层地址指明的是网关（即下一站路由器）。</li></ul><p>设置H标志表明，目的地址是一个完整的主机地址。</p><p>没有设置H标志说明目的地址是一个网络地址（主机号部分为0）。</p><p>当为某个目的 I P地址搜索路由表时，主机地址项必须与目的地址完全匹配，而网络地址项只需要匹配目的地址的网络号和子网号即可</p><p>每当初始化一个接口时（通常用ifconfig设置接口地址），就为接口自动创建一个直接路由。到达不直接相连的主机或网络必须以某种方式添加到路由表中，一个常用方式是：</p><ol><li>在系统引导时显式地在初始化文件中运行route命令 </li><li>运行路由守护程序。或者用较新的路由器发现协议</li></ol><p>如果路由表中没有默认项，又没有找到匹配项，结果取决于该IP数据报是由主机产生还是被转发的。如果是本机产生的，那么久给发送该数据报的应用程序返回一个差错，或者是“主机不可达差错”或者“网络不可达差错”。如果是被转发的数据报，那么就给原始发送端发送一份ICMP主机不可达的差错报文。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="icmp主机与网络不可达差错"></a>ICMP主机与网络不可达差错<a class="hash-link" href="#icmp主机与网络不可达差错" title="Direct link to heading">#</a></h3><p>当路由器收到一份IP数据报但又不能转发时，就要发送一份ICMP“主机不可达”差错报文。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="转发或不转发"></a>转发或不转发<a class="hash-link" href="#转发或不转发" title="Direct link to heading">#</a></h3><p>一般都假定主机不转发IP数据报，除非对它们进行特殊配置而作为路由器使用。</p><p>大多数伯克利派生出来的系统都有一个内核变量ipforwarding，或其他类似的名字。一些系统（如BSD/386和SVR4）只有在该变量值不为0的情况下才转发数据报。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="icmp重定向差错"></a>ICMP重定向差错<a class="hash-link" href="#icmp重定向差错" title="Direct link to heading">#</a></h3><p>当IP数据报应该被发送到另一个路由器时，收到数据报的路由器就要发送ICMP重定向差错报文给IP数据报的发送端。</p><p>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。主机启动时路由表中可以只有一个默认表项。一旦默认路由发生差错，默认路由器将通知它进行重定向，并允许主机对路由表作相应的改动。</p><p>重定向一般用来让具有很少选路信息的主机逐渐建立更完善的路由表。主机启动时路由表中可以只有一个默认表项。一旦默认路由发生差错，默认路由器将通知它进行重定向，并允许主机对路由表作相应的改动。</p><p><a href="https://github.com/lutzchuck/tcpip-note/blob/master/img/chap9/img1.png" target="_blank" rel="noopener noreferrer"><img src="https://github.com/lutzchuck/tcpip-note/raw/master/img/chap9/img1.png" alt="graphic"></a></p><p> 重定向报文有许多规则：</p><ol><li>重定向报文只能由路由器生成，不能由主机生成</li><li>重定向报文是为主机而不是路由器使用的</li><li>路由器发应该发送的是对主机的重定向，而不是对网络的重定向。因为子网的存在使得难于准确指明何时应发送对网络的重定向。</li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="icmp路由器发现报文"></a>ICMP路由器发现报文<a class="hash-link" href="#icmp路由器发现报文" title="Direct link to heading">#</a></h3><p>初始化路由表的方法，</p><ol><li>即在配置文件中指定静态路由（Route命令）。这种方法经常用来设置默认路由。</li><li>利用ICMP路由器通告和请求报文。</li></ol><p>主机在引导后会广播/多播一份路由器请求报文。另外，路由器会定期广播/多播传送他们的路由器通告报文，允许每个正在监听的主机更新它们的路由表。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="路由器操作"></a>路由器操作<a class="hash-link" href="#路由器操作" title="Direct link to heading">#</a></h4><p>当路由器启动时，它定期（一般不是定义，随机传送的，减少冲突）在所有广播或多播传送接口上发送通告报文。路由器还要监听来自主机的请求报文，并发送路由器通告报文以响应这些请求报文。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="主机操作"></a>主机操作<a class="hash-link" href="#主机操作" title="Direct link to heading">#</a></h4><p>主机在引导期间一般发送三份路由器请求报文，每三秒钟发送一次。一旦接收到一个有效的通告报文，就停止发送请求报文。</p><p>主机也监听来自相邻路由器的请求报文。这些通告报文可以改变主机的默认路由器。另外，如果没有接收到来自当前默认路由器的通告报文，那么默认路由器会超时。</p><p>路由器发现报文一般由用户进程（守护程序）创建和处理。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="97-小结"></a>9.7 小结<a class="hash-link" href="#97-小结" title="Direct link to heading">#</a></h3><p>I P路由操作对于运行 TCP/IP的系统来说是最基本的，不管是主机还是路由器。路由表项的内容很简单，包括： 5 bit标志、目的IP地址（主机、网络或默认）、下一站路由器的 IP地址（间接路由）或者本地接口的 IP地址（直接路由）及指向本地接口的指针。主机表项比网络表项具有更高的优先级，而网络表项比默认项具有更高的优先级。</p><p>系统产生的或转发的每份 IP数据报都要搜索路由表，它可以被路由守护程序或 ICMP重定向报文修改。系统在默认情况下不转发数据报，除非进行特殊的配置。用 <code>route</code>命令可以进入静态路由，可以利用新 ICMP路由器发现报文来初始化默认表项，并进行动态修改。主机在启动时只有一个简单的路由表，它可以被来自默认路由器的 ICMP重定向报文动态修改。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="静态选路"></a>静态选路<a class="hash-link" href="#静态选路" title="Direct link to heading">#</a></h2><p>在配置接口时，以默认方式生成路由表项（对于直接连接的接口），并通过route命令增加表项（通常从系统自引导程序文件），或是通过ICMP重定向生成表项（通常是在默认方式出错的情况下）。</p><p>当相邻路由器之间进行通信，以告知对方每个路由器当前所连接的网络，这就出现了动态选路。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="-1"></a><a class="hash-link" href="#-1" title="Direct link to heading">#</a></h3><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="路由选择协议"></a>路由选择协议<a class="hash-link" href="#路由选择协议" title="Direct link to heading">#</a></h2><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。</p><p>可以把路由选择协议划分为两大类：</p><ul><li>自治系统内部的路由选择：RIP 和 OSPF
内部网关协议IGP(Interior Gateway Protocol）</li><li>自治系统间的路由选择：BGP。
外部网关协议EGP(Exterier Gateway Protocol）</li></ul><p>路由器之间必须采用选路协议进行通信，路由器上有个进程为路由守护程序，它运行选路协议，与相邻路由进行通信。</p><p>动态选路并不改变内核在IP层的选路方式。这种选路方式称为选路机制（routingmechanism）。内核搜索路由表，查找主机路由、网络路由以及默认路由的方式并没有改变。仅仅是放置到路由表中的信息改变了----当路由随时间变化时，路由是由路由守护程序动态地增加或删除，而不是来自于自引导程序文件中的route命令。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-内部网关协议-rip"></a>1. 内部网关协议 RIP<a class="hash-link" href="#1-内部网关协议-rip" title="Direct link to heading">#</a></h3><p>RIP（Routing Information Protocol，路由信息协议）</p><p>RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。</p><p>RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。</p><p>距离向量算法：</p><ul><li>对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；</li><li>对修改后的 RIP 报文中的每一个项目，进行以下步骤：</li><li>若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；</li><li>否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。</li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。</li></ul><p>RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-内部网关协议-ospf"></a>2. 内部网关协议 OSPF<a class="hash-link" href="#2-内部网关协议-ospf" title="Direct link to heading">#</a></h3><p>OSPF（Open Sortest Path First，开放最短路径优先）</p><p> OSPF是为了克服 RIP 的缺点而开发出来的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的所有路由器发送信息，这种方法是洪泛法。</li><li>发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li>只有当链路状态发生变化时，路由器才会发送信息。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-外部网关协议-bgp"></a>3. 外部网关协议 BGP<a class="hash-link" href="#3-外部网关协议-bgp" title="Direct link to heading">#</a></h3><p>BGP（Border Gateway Protocol，边界网关协议）</p><p>AS 之间的路由选择很困难，主要是由于：</p><ul><li>互联网规模很大；</li><li>各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；</li><li>AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。</li></ul><p>BGP 只能寻找一条比较好的路由，而不是最佳路由。</p><p>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。</p><p> <a href="https://camo.githubusercontent.com/6e2e739f44205b054234ea2b1f8f9c5102145f27370183bd97e6951cfa0440c4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39636430616532302d346662352d343031372d613030302d6637643361306562333532392e706e67" target="_blank" rel="noopener noreferrer"><img alt="img" src="/assets/images/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39636430616532302d346662352d343031372d613030302d6637643361306562333532392e706e67-2313a49e98004afd3dc30291954eb535.bin"></a> </p><p>网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="ip多播"></a>IP多播<a class="hash-link" href="#ip多播" title="Direct link to heading">#</a></h2><ul><li>IGMP（Internet Group Management Protocol，网际组管理协议）</li><li>多播路由选择协议</li></ul></div></article><div class="margin-vert--xl"><div class="row"><div class="col"><a href="https://github.com/worst0/wiki_note/edit/main/docs/7.Network/A5.网络层.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="1.2em" width="1.2em" preserveAspectRatio="xMidYMid meet" role="img" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-label="Edit page"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div></div></div><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Network/A4.链路层"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« 链路层</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Network/A6.传输层"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">传输层 »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#概述" class="table-of-contents__link">概述</a><ul><li><a href="#引言" class="table-of-contents__link">引言</a></li></ul></li><li><a href="#网络设备" class="table-of-contents__link">网络设备</a><ul><li><a href="#网络设备和osi模型关系" class="table-of-contents__link">网络设备和<code>OSI</code>模型关系</a></li></ul></li><li><a href="#ip-数据报格式" class="table-of-contents__link">IP 数据报格式</a></li><li><a href="#ip-地址编址方式" class="table-of-contents__link">IP 地址编址方式</a><ul><li><a href="#1-分类" class="table-of-contents__link">1. 分类</a></li><li><a href="#2-子网划分" class="table-of-contents__link">2. 子网划分</a></li><li><a href="#3-无分类" class="table-of-contents__link">3. 无分类</a></li></ul></li><li><a href="#地址解析协议-arp" class="table-of-contents__link">地址解析协议 ARP</a><ul><li><a href="#小结" class="table-of-contents__link">小结</a></li></ul></li><li><a href="#rarp：逆地址解析协议" class="table-of-contents__link">RARP：逆地址解析协议</a><ul><li><a href="#小结-1" class="table-of-contents__link">小结</a></li></ul></li><li><a href="#网际控制报文协议-icmp" class="table-of-contents__link">网际控制报文协议 ICMP</a><ul><li><a href="#icmp报文的类型" class="table-of-contents__link">ICMP报文的类型</a></li><li><a href="#icmp地址掩码请求与应答" class="table-of-contents__link">ICMP地址掩码请求与应答</a></li><li><a href="#icmp时间戳请求与应答" class="table-of-contents__link">ICMP时间戳请求与应答</a></li><li><a href="#icmp端口不可达差错" class="table-of-contents__link">ICMP端口不可达差错</a></li></ul></li><li><a href="#1-ping" class="table-of-contents__link">1. Ping</a></li><li><a href="#2-traceroute" class="table-of-contents__link">2. Traceroute</a><ul><li><a href="#traceroute程序的操作" class="table-of-contents__link">Traceroute程序的操作</a></li></ul></li><li><a href="#虚拟专用网-vpn" class="table-of-contents__link">虚拟专用网 VPN</a></li><li><a href="#网络地址转换-nat" class="table-of-contents__link">网络地址转换 NAT</a></li><li><a href="#ip路由选择" class="table-of-contents__link">IP路由选择</a><ul><li><a href="#子网寻址" class="table-of-contents__link">子网寻址</a></li><li><a href="#子网掩码" class="table-of-contents__link">子网掩码</a></li><li><a href="#特殊情况的ip地址" class="table-of-contents__link">特殊情况的IP地址</a></li></ul></li><li><a href="#路由器的结构" class="table-of-contents__link">路由器的结构</a></li><li><a href="#路由器分组转发流程" class="table-of-contents__link">路由器分组转发流程</a></li><li><a href="#ip选路" class="table-of-contents__link">IP选路</a><ul><li><a href="#选路的原理" class="table-of-contents__link">选路的原理</a></li><li><a href="#icmp主机与网络不可达差错" class="table-of-contents__link">ICMP主机与网络不可达差错</a></li><li><a href="#转发或不转发" class="table-of-contents__link">转发或不转发</a></li><li><a href="#icmp重定向差错" class="table-of-contents__link">ICMP重定向差错</a></li><li><a href="#icmp路由器发现报文" class="table-of-contents__link">ICMP路由器发现报文</a></li><li><a href="#97-小结" class="table-of-contents__link">9.7 小结</a></li></ul></li><li><a href="#静态选路" class="table-of-contents__link">静态选路</a></li><li><a href="#路由选择协议" class="table-of-contents__link">路由选择协议</a><ul><li><a href="#1-内部网关协议-rip" class="table-of-contents__link">1. 内部网关协议 RIP</a></li><li><a href="#2-内部网关协议-ospf" class="table-of-contents__link">2. 内部网关协议 OSPF</a></li><li><a href="#3-外部网关协议-bgp" class="table-of-contents__link">3. 外部网关协议 BGP</a></li></ul></li><li><a href="#ip多播" class="table-of-contents__link">IP多播</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.8bd170ed.js"></script>
<script src="/assets/js/main.30834e93.js"></script>
</body>
</html>