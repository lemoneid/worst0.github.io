<!doctype html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.3">
<link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="My Wiki Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="My Wiki Blog Atom Feed">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><title data-react-helmet="true">D9.网络原理面试题 | My Wiki</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:url" content="https://worst0.github.io/Interview/D9.网络原理面试题"><meta data-react-helmet="true" name="docusaurus_locale" content="en"><meta data-react-helmet="true" name="docusaurus_version" content="current"><meta data-react-helmet="true" name="docusaurus_tag" content="docs-default-current"><meta data-react-helmet="true" property="og:title" content="D9.网络原理面试题 | My Wiki"><meta data-react-helmet="true" name="description" content="URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。"><meta data-react-helmet="true" property="og:description" content="URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。"><meta data-react-helmet="true" property="og:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><meta data-react-helmet="true" name="twitter:image" content="https://cos.ap-guangzhou.myqcloud.com/wiki-media-1253965369/doc/logo-zip.png"><link data-react-helmet="true" rel="shortcut icon" href="/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://worst0.github.io/Interview/D9.网络原理面试题"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Interview/D9.网络原理面试题" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://worst0.github.io/Interview/D9.网络原理面试题" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.fcc94c76.css">
<link rel="preload" href="/assets/js/runtime~main.aad5aa0c.js" as="script">
<link rel="preload" href="/assets/js/main.800b3dd8.js" as="script">
</head>
<body>
<script>!function(){function e(e){document.documentElement.setAttribute("data-theme",e)}var t=function(){var e=null;try{e=localStorage.getItem("theme")}catch(e){}return e}();null!==t?e(t):window.matchMedia("(prefers-color-scheme: dark)").matches?e("dark"):window.matchMedia("(prefers-color-scheme: light)").matches?e("light"):e("dark")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_1oUP">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">My Wiki</b></a><a class="navbar__item navbar__link navbar__link--active" href="/intro">Document💻</a><a class="navbar__item navbar__link" href="/blog">Blog🤓</a><a class="navbar__item navbar__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a><a class="navbar__item navbar__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>本站源码<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="react-toggle displayOnlyInLargeViewport_GrZ2 react-toggle--checked react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_71bT" style="margin-left:2px">🌙</span></div><div class="react-toggle-track-x"><span class="toggle_71bT" style="margin-left:1px">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" checked="" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--light_3UqQ navbar__logo"><img src="/img/logo.svg" alt="Wiki logo" class="themedImage_1VuW themedImage--dark_hz6m navbar__logo"><b class="navbar__title">My Wiki</b></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link navbar__link--active" href="/intro">Document💻</a></li><li class="menu__list-item"><a class="menu__link" href="/blog">Blog🤓</a></li><li class="menu__list-item"><a class="menu__link" href="/ReadingNotes/A1.Sentence">Reading-Book📚</a></li><li class="menu__list-item"><a class="menu__link" href="/Xmind_IMG/1.解题思维">Xmind🎮</a></li><li class="menu__list-item"><a href="https://github.com/worst0/" target="_blank" rel="noopener noreferrer" class="menu__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li><li class="menu__list-item"><a href="https://github.com/worst0/wiki_note" target="_blank" rel="noopener noreferrer" class="menu__link"><span>本站源码<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_3J9K"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a></li></ul></div></div></div></nav><div class="main-wrapper docs-wrapper doc-page"><div class="docPage_31aa"><aside class="docSidebarContainer_3Kbt"><div class="sidebar_15mo"><nav class="menu menu--responsive thin-scrollbar menu_Bmed menuWithAnnouncementBar_2WvA" aria-label="Sidebar navigation"><button aria-label="Open menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg class="sidebarMenuIcon_fgN0" width="24" height="24" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">intro</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/intro">intro</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">1.Linux</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Linux命令</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A1.linux基础">A1.linux基础</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A2.Linux命令">A2.Linux命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A3.编译环境">A3.编译环境</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A4.数据提取">A4.数据提取</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/A5.Linux命令补充">A5.Linux命令补充</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">调试相关</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/D1.网络相关">D1.网络相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/D2.C-C++调试工具">D2.C-C++调试工具</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">shell脚本</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/B1.shell脚本语法">B1.shell脚本语法</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">ubuntu</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C1.ubuntu相关">C1.ubuntu相关</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C2.ubuntu常用软件">C2.ubuntu常用软件</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Linux/C3.语言环境">C3.语言环境</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">2.Algorithm</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">数据结构</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A1.DataStructure">A1.DataStructure</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A2.数组和链表">A2.数组和链表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A3.栈和队列">栈,队列</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A4.堆和优先队列">A4.堆和优先队列</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A5.哈夫曼树">A5.哈夫曼树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A6.哈希表">A6.哈希表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.排序">A7.排序</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A7.树">A7.树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A8.字符串匹配">A8.字符串匹配</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.字典树">A10.字典树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A10.树状数组和线段树">A10.树状数组和线段树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.平衡树">A11.平衡树</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A11.并查集">A11.并查集</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A12.图论">A12.图论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A15.位图和跳表">A15.位图和跳表</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/A99.实现ADT">A99.实现ADT</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">算法设计</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B1.算法分析">B1.算法分析</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B10.数论">B10.数论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B11.位运算">B11.位运算</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B12.计算几何">B12.计算几何</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B13.网络流">B13.网络流</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B2.贪心">B2.贪心</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B3.递推到递归">B3.递推到递归</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B4.动态规划">B4.动态规划</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B5.分治">B5.分治</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B6.减治和双指针">B6.减治和双指针</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B7.回溯">B7.回溯</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B8.搜索">B8.搜索</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B9.数学">B9.数学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B97.func实现">B97.func实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B98.字符串">B98.字符串</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/B99.专题">B99.专题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.Algorithm">C1.Algorithm</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C1.算法技巧">C1.算法技巧</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/C2.编程珠玑">C2.编程珠玑</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">Think</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/D1.ACM模板">D1.ACM模板</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E1.concrete">E1.concrete</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/E2.Combinatorics">E2.Combinatorics</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/G1.逻辑思考">G1.逻辑思考</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Algorithm/H1.算法谜题">H1.算法谜题</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">3.Online_Judge</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/A1.Leetcode">A1.Leetcode</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/B1.HZOJ">B1.HZOJ</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/C1.nowcoder">C1.nowcoder</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/C2.CD-nowcoder">C2.CD-nowcoder</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/C3.JZ-nowcoer">C3.JZ-nowcoer</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/D1.EP">D1.EP</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Online_Judge/E1.编程技巧">E1.编程技巧</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">4.Programming_Language</a><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">C</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A1.CBasic">A1.CBasic</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A2.Cimprove">A2.Cimprove</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/A3.C语言技巧">A3.C语言技巧</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">C++</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B1.C++-basic">B1.C++-basic</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B2.C++-improve">B2.C++-improve</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B3.C++-exercise">B3.C++-exercise</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B4.C++-others">B4.C++-others</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B5.C++编译">B5.C++编译</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/B6.C++-question">B6.C++-question</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">STL</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C1.STL">C1.STL</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/C2.STL-question">C2.STL-question</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">python</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/D1.python">D1.python</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Language/E1.conda">E1.conda</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">5.Programming_Stardard</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/A1.C编程规范">A1.C编程规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.编码英文缩写">B1.编码英文缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B1.计算机哲学">B1.计算机哲学</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/B2.英文标准缩写">B2.英文标准缩写</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/C1.重构">C1.重构</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Programming_Stardard/D1.Design_Pattern">D1.Design_Pattern</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">6.Operating_system</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A1.os">A1.os</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A2.OS概述">A2.OS概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A2.操作系统">A2.操作系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A3.进程与线程">A3.进程与线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A4.死锁">A4.死锁</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A5.存储管理">A5.存储管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A6.设备管理">A6.设备管理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A7.文件系统">A7.文件系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A8.输入输出">A8.输入输出</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A9.编译系统">A9.编译系统</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/C1.计算机原理">C1.计算机原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/D1.CSAPP">D1.CSAPP</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#" tabindex="-1">系统编程</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Operating_system/A1.os">A1.os</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">7.Network</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A2.网络概论">A2.网络概论</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A3.物理层">A3.物理层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A4.链路层">A4.链路层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A5.网络层">A5.网络层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A6.传输层">A6.传输层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A7.应用层">A7.应用层</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/A9.疑问">A9.疑问</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Network/B1.HTTP">B1.HTTP</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">8.Server</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/A1.Linux高性能服务器">A1.Linux高性能服务器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/A2.概述">A2.概述</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.Linux多线程muduo">B1.Linux多线程muduo</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B1.系统编程">B1.系统编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B2.文件IO">B2.文件IO</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B3.文件和目录">B3.文件和目录</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B4.标准IO库">B4.标准IO库</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/B9.命令">B9.命令</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络API">C1.网络API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C1.网络编程">C1.网络编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C2.高级IO函数">C2.高级IO函数</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C3.程序规范">C3.程序规范</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C4.IO复用">C4.IO复用</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C5.信号">C5.信号</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C6.定时器">C6.定时器</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C7.高性能服务器框架">C7.高性能服务器框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C8.socket">C8.socket</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/C9.实现">C9.实现</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D1.多进程编程">D1.多进程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D2.进程">D2.进程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D3.进程控制">D3.进程控制</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/D4.进程间通信">D4.进程间通信</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E1.多线程编程">E1.多线程编程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/E2.线程">E2.线程</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Server/H1.网络工具">H1.网络工具</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">9.Database</a><ul class="menu__list"></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">10.Skill</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/A1.Latex数学公式">A1.Latex数学公式</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/B1.Markdown语法">B1.Markdown语法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C1.git">C1.git</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/C2.github">C2.github</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/D1.计算机英语">D1.计算机英语</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Skill/E1.绘图">E1.绘图</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#">11.Interview</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/A1.面试">A1.面试</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/A2.interview">A2.interview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/C1.简历">C1.简历</a></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#" tabindex="0">question</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/D3.算法">D3.算法</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/D4.linux">D4.linux</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/D5.编译原理">D5.编译原理</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/D6.并发面试题">D6.并发面试题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/D7.操作系统面试题">D7.操作系统面试题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/D8.网络编程面试题">D8.网络编程面试题</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/Interview/D9.网络原理面试题">D9.网络原理面试题</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/Interview/D10.语言语法面试题">D10.语言语法面试题</a></li></ul></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">13.Project</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A1.Gtest测试框架">A1.Gtest测试框架</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A2.udp-football">A2.udp-football</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/A3.Hython">A3.Hython</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Project/B1.项目面试">B1.项目面试</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">14.Science</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/E3.数学认识">E3.数学认识</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/Science/F1.物理认识">F1.物理认识</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#">99.other</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/A1.临时">A1.临时</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/B1.临时笔记">B1.临时笔记</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/C1.task">C1.task</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/D1.软件需求">D1.软件需求</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/other/E1.software">E1.software</a></li></ul></li></ul></nav></div></aside><main class="docMainContainer_3ufF"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_3FnS"><div class="docItemContainer_33ec"><article><div class="markdown"><header><h1 class="h1Heading_27L5">1.如何理解 URI？</h1></header><p>URI, 全称为(Uniform Resource Identifier), 也就是统一资源标识符，它的作用很简单，就是区分互联网上不同的资源。但是，它并不是我们常说的网址, 网址指的是URL, 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="uri-的结构"></a>URI 的结构<a class="hash-link" href="#uri-的结构" title="Direct link to heading">#</a></h3><p>URI 真正最完整的结构是这样的</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676451014-0ef9a5e9-3b41-44ff-b124-4c2a5e192368.jpeg" alt="4c2a5e192368"></p><p>好像跟平时见到的不太一样！先别急，来一一拆解。scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。host:port<strong> 表示主机名和端口。path 表示请求路径，标记资源所在位置。query 表示查询参数，为key=val这种形式，多个键值对之间用&amp;隔开。fragment 表示 URI 所定位的资源内的一个锚点</strong>，浏览器可以根据这个锚点跳转到对应的位置。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">https://www.baidu.com/s?tn=54093922_6_hao_pg&amp;ie=utf-8&amp;wd=%E7%99%BE%E5%BA%A6</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个 URI 中</p><ul><li>https 即scheme部分</li><li><a href="http://www.baidu.com" target="_blank" rel="noopener noreferrer">www.baidu.com</a> 为host:port部分（注意，http 和 https 的默认端口分别为80、443）</li><li>kenguba/upkpls/gisxr2 为path部分</li><li>word=1&amp;name=kenguba 表示query部分</li><li>#UrkH4 就是锚点
<img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621676463820-a398dc8d-4ae1-44b3-9f53-0b6adec55d09.png" alt="0b6adec55d09"></li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="uri-编码"></a>URI 编码<a class="hash-link" href="#uri-编码" title="Direct link to heading">#</a></h3><p>URI 只能使用 ASCII , ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。因此，URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">encodeURI(&quot;https://www.yuque.com/kenguba/upkpls/gisxr2?name=一缕清风&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;https://www.yuque.com/kenguba/upkpls/gisxr2?name=%E4%B8%80%E7%BC%95%E6%B8%85%E9%A3%8E&quot;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">decodeURI(&quot;https://www.yuque.com/kenguba/upkpls/gisxr2?name=%E4%B8%80%E7%BC%95%E6%B8%85%E9%A3%8E&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">encodeURIComponent(&quot;https://www.yuque.com/kenguba/upkpls/gisxr2?name=一缕清风&quot;)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;https://www.yuque.com/kenguba/upkpls/gisxr2?name=%E4%B8%80%E7%BC%95%E6%B8%85%E9%A3%8E&quot;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">decodeURIComponent(&quot;https://www.yuque.com/kenguba/upkpls/gisxr2?name=%E4%B8%80%E7%BC%95%E6%B8%85%E9%A3%8E&quot;)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><header><h1 class="h1Heading_27L5">2.解释一下HTTP的超文本传输协议</h1></header><p>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。它可以拆成三个部分：</p><ul><li>超文本</li><li>传输</li><li>协议</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676474919-5394cabd-1f5c-4e9e-90ef-f1d5d611ab7f.jpeg" alt="f1d5d611ab7f"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="协议"></a>协议<a class="hash-link" href="#协议" title="Direct link to heading">#</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676483730-662e1818-f645-47ae-90cc-84841859f15a.jpeg" alt="84841859f15a"></p><p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:</p><ul><li>协 字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个：你、公司、学校三个；租房协议里的参与者有两个：你和房东。</li><li>议 字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定试用期期限、毁约金等；租房协议里规定租期期限、每月租金金额、违约如何处理等。
针对 HTTP 协议，我们可以这么理解。HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="传输"></a>传输<a class="hash-link" href="#传输" title="Direct link to heading">#</a></h3><p>所谓的「传输」，很好理解，就是把一堆东西从 A 点搬到 B 点，或者从 B 点 搬到 A 点。别轻视了这个简单的动作，它至少包含两项重要的信息。HTTP 协议是一个双向协议。我们在上网冲浪时，浏览器是请求方 A ，百度网站就是应答方 B。双方约定用 HTTP 协议来通信，于是浏览器把请求数据发送给网站，网站再把一些数据返回给浏览器，最后由浏览器渲染在屏幕，就可以看到图片、视频了。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676496880-d0e78a0c-9c6a-4c4d-affe-b63c9b8403ba.jpeg" alt="b63c9b8403ba"></p><p>数据虽然是在 A 和 B 之间传输，但允许中间有中转或接力。就好像第一排的同学想穿递纸条给最后一排的同学，那么传递的过程中就需要经过好多个同学（中间人），这样的传输方式就从「A &lt; - &gt; B」，变成了「A &lt;-&gt; N &lt;-&gt; M &lt;-&gt; B」。而在 HTTP 里，需要中间人遵从 HTTP 协议，只要不打扰基本的数据传输，就可以添加任意额外的东西。针对传输，我们可以进一步理解了 HTTP。HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="超文本"></a>超文本<a class="hash-link" href="#超文本" title="Direct link to heading">#</a></h3><p>HTTP 传输的内容是「超文本」 我们先来理解「文本」，在互联网早期的时候只是简单的字符文字，但现在「文本」的涵义已经可以扩展为图片、视频、压缩包等，在 HTTP 眼里这些都算做「文本」。再来理解「超文本」，它就是超越了普通文本的文本，它是文字、图片、视频等的混合体最关键有超链接，能从一个超文本跳转到另外一个超文本。HTML 就是最常见的超文本了，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了。OK，经过了对 HTTP 里这三个名词的详细解释，就可以给出比「超文本传输协议」这七个字更准确更有技术含量的答案：HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」 </p><p>⚠️注意: HTTP 不是用于从互联网服务器传输超文本到本地浏览器的协议，也可以是服务器到服务器，所以采用两点之间的描述会更准确</p><header><h1 class="h1Heading_27L5">3.HTTP 的特点？HTTP 有哪些缺点？</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http-的特点概括"></a>HTTP 的特点概括<a class="hash-link" href="#http-的特点概括" title="Direct link to heading">#</a></h3><p>灵活可扩展 主要体现在两个方面。
一个是语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分都没有严格的语法限制
另一个是传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便。
可靠传输 HTTP 基于 TCP/IP，因此把这一特性继承了下来。这属于 TCP 的特性，不具体介绍了。
请求-应答 也就是一发一收、有来有回， 当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。
无状态 这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http-缺点"></a>HTTP 缺点<a class="hash-link" href="#http-缺点" title="Direct link to heading">#</a></h3><p>无状态 所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。
明文传输 即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。
队头阻塞问题 当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。接下来会有一小节讨论这个问题。</p><header><h1 class="h1Heading_27L5">4.HTTP 报文结构是怎样的？</h1></header><p>对于 TCP 而言，在传输的时候分为两个部分: <strong>TCP头 </strong>和 数据部分。而 HTTP 类似，也是 header + body 的结构，具体而言:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">起始行 + 头部 + 空行 + 实体</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>由于 http 请求报文和响应报文是有一定区别，因此分开介绍</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621676512848-cdf66858-9362-46f1-90bf-72237b951628.png?x-oss-process=image%2Fresize%2Cw_752" alt="2Fresize"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="起始行"></a>起始行<a class="hash-link" href="#起始行" title="Direct link to heading">#</a></h3><p>对于请求报文来说，起始行类似下面这样:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">GET /home HTTP/1.1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>也就是方法 + 路径 + http版本。对于响应报文来说，起始行一般张这个样:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">HTTP/1.1 200 OK</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>响应报文的起始行也叫做状态行。由 http版本、状态码和原因 三部分组成。⚠️注意：在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循 ABNF 语法规范</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="头部"></a>头部<a class="hash-link" href="#头部" title="Direct link to heading">#</a></h3><p>展示一下请求头和响应头在报文中的位置:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676524629-a349645e-ee5a-46aa-bdf5-9b63b1346da8.jpeg" alt="9b63b1346da8"></p><p>不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：</p><ul><li>字段名不区分大小写</li><li>字段名不允许出现空格，不可以出现下划线_</li><li>字段名后面必须<strong>紧接着 </strong>:</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="空行"></a>空行<a class="hash-link" href="#空行" title="Direct link to heading">#</a></h3><p>很重要，用来区分开头部和实体。问: 如果说在头部中间故意加一个空行会怎么样？那么空行后的内容全部被视为实体。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="实体"></a>实体<a class="hash-link" href="#实体" title="Direct link to heading">#</a></h3><p>就是具体的数据了，也就是 body 部分。请求报文对应请求体, 响应报文对应响应体。</p><header><h1 class="h1Heading_27L5">5.如何理解 HTTP 的请求方法？</h1></header><p>http/1.1 规定了以下请求方法(注意，都是大写):</p><ul><li>GET 通常用来获取资源</li><li>HEAD 获取资源的元信息</li><li>POST 提交数据，即上传数据</li><li>PUT 修改数据</li><li>DELETE 删除资源(几乎用不到)</li><li>CONNECT 建立连接隧道，用于代理服务器</li><li>OPTIONS 列出可对资源实行的请求方法，预检请求，用来跨域请求</li><li>TRACE 追踪请求-响应的传输路径</li></ul><header><h1 class="h1Heading_27L5">6.http 常见字段有哪些？</h1></header><ul><li>Host</li><li>Content-Length</li><li>Connection</li><li>Content-Encoding</li><li>Content-Type</li></ul><header><h1 class="h1Heading_27L5">7.对于定长和不定长的数据，HTTP 是怎么传输的？</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="定长包体"></a>定长包体<a class="hash-link" href="#定长包体" title="Direct link to heading">#</a></h3><p>对于定长包体而言，发送端在传输的时候一般会带上 Content-Length, 来指明包体的长度。我们用一个nodejs服务器来模拟一下:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const http = require(&#x27;http&#x27;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const server = http.createServer();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">server.on(&#x27;request&#x27;, (req, res) =&gt; {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  if(req.url === &#x27;/&#x27;) {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/plain&#x27;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    res.setHeader(&#x27;Content-Length&#x27;, 10);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    res.write(&quot;helloworld&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">server.listen(8081, () =&gt; {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&quot;成功启动&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>启动后访问: localhost:8081。浏览器中显示如下:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">helloworld</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这是长度正确的情况，那不正确的情况是如何处理的呢？我们试着把这个长度设置的小一些:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">res.setHeader(&#x27;Content-Length&#x27;, 8);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>重启服务，再次访问，现在浏览器中内容如下:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">hellowor</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>那后面的ld哪里去了呢？实际上在 http 的响应体中直接被截去了。然后试着将这个长度设置得大一些:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">res.setHeader(&#x27;Content-Length&#x27;, 12);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>此时浏览器显示如下:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621676699407-b542981c-ab87-48ca-b2c7-60cc8ee927ba.png" alt="60cc8ee927ba"></p><p>直接无法显示了。可以看到 Content-Length 对于 http 传输过程起到了十分关键的作用，如果设置不当可以直接导致传输失败。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="不定长包体"></a>不定长包体<a class="hash-link" href="#不定长包体" title="Direct link to heading">#</a></h3><p>上述是针对于定长包体，那么对于不定长包体而言是如何传输的呢？这里就必须介绍另外一个 http 头部字段了:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Transfer-Encoding: chunked</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Transfer-Encoding: chunked</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Transfer-Encoding: compress</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Transfer-Encoding: deflate</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Transfer-Encoding: gzip</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Transfer-Encoding: identity</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Several values can be listed, separated by a comma</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// Transfer-Encoding: gzip, chunked</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>表示分块传输数据，设置这个字段后会自动产生两个效果:</p><ul><li>Content-Length 字段会被忽略</li><li>基于长连接持续推送动态内容
我们依然以一个实际的例子来模拟分块传输，nodejs 程序如下:</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">const http = require(&#x27;http&#x27;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">const server = http.createServer();</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">server.on(&#x27;request&#x27;, (req, res) =&gt; {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  if(req.url === &#x27;/&#x27;) {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    res.setHeader(&#x27;Content-Type&#x27;, &#x27;text/html; charset=utf8&#x27;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    res.setHeader(&#x27;Content-Length&#x27;, 10);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    res.setHeader(&#x27;Transfer-Encoding&#x27;, &#x27;chunked&#x27;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    res.write(&quot;&lt;p&gt;来啦&lt;/p&gt;&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    setTimeout(() =&gt; {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      res.write(&quot;第一次传输&lt;br/&gt;&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }, 1000);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    setTimeout(() =&gt; {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      res.write(&quot;第二次传输&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">      res.end()</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">    }, 2000);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  }</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">server.listen(8009, () =&gt; {</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">  console.log(&quot;成功启动&quot;);</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">})</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img src="https://cdn.nlark.com/yuque/0/2021/gif/396745/1621676709731-785afed8-9b7a-436c-a6f2-66412b848c5d.gif" alt="66412b848c5d"></p><p>用 telnet 抓到的响应如下:</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676717971-2c48f29e-1281-4c65-9e10-5580cefd2818.jpeg" alt="5580cefd2818"></p><p>注意，Connection: keep-alive 及之前的为响应行和响应头，后面的内容为响应体，这两部分用换行符隔开。响应体的结构比较有意思，如下所示:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">chunk长度(16进制的数)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">第一个chunk的内容</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">chunk长度(16进制的数)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">第二个chunk的内容</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">......</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">0</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>最后是留有有一个空行的，这一点请大家注意。以上便是 http 对于定长数据和不定长数据的传输方式。</p><header><h1 class="h1Heading_27L5">8.HTTP 如何处理大文件的传输？</h1></header><p>对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="如何支持"></a>如何支持<a class="hash-link" href="#如何支持" title="Direct link to heading">#</a></h3><p>当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ curl -I https://www.yuque.com/</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">HTTP/1.1 200 OK</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Accept-Ranges: bytes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Length: 146515</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ curl -I http://download.dcloud.net.cn/HBuilder.9.0.2.macosx_64.dmg</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">$ curl -H  &quot;Range: bytes=0-10&quot; http://download.dcloud.net.cn/HBuilder.9.0.2.macosx_64.dmg -v</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//省略</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">HTTP/1.1 200 OK</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Accept-Ranges: none</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">//详细的</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">HTTP/1.1 200 OK</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Server: Tengine</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Type: application/octet-stream</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Length: 233295878</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Connection: keep-alive</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Date: Mon, 26 Apr 2021 13:12:46 GMT</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">x-oss-request-id: 6086BC4E66D721363972F4A8</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">x-oss-cdn-auth: success</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Accept-Ranges: bytes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">ETag: &quot;6D932737FD8C6058D6AE93BCC4C74AA7-45&quot;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Last-Modified: Tue, 06 Mar 2018 13:20:31 GMT</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">x-oss-object-type: Multipart</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">x-oss-hash-crc64ecma: 7369427768111114923</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">x-oss-storage-class: Standard</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">x-oss-server-time: 156</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Ali-Swift-Global-Savetime: 1617704046</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Via: cache15.l2cn1809[0,200-0,H], cache2.l2cn1809[1,0], cache7.cn682[39,39,200-0,M], cache2.cn682[44,0]</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Age: 778</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">X-Cache: MISS TCP_MISS dirn:-2:-2</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">X-Swift-SaveTime: Mon, 26 Apr 2021 13:25:44 GMT</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">X-Swift-CacheTime: 3600</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Timing-Allow-Origin: *</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">EagleId: af062a4216194435440612604e</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>假如在响应中存在Accept-Ranges首部（并且它的值不为 “none”），那么表示该服务器支持范围请求 在上面的响应中，Accept-Ranges: bytes 表示界定范围的单位是 bytes 。这里 Content-Length也是有效信息，因为它提供了要检索的图片的完整大小</p><p>如果站点未发送Accept-Ranges首部，那么它们有可能不支持范围请求。一些站点会明确将其值设置为 &quot;none&quot;，以此来表明不支持。在这种情况下，某些应用的下载管理器会将暂停按钮禁用。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">curl -I https://www.youtube.com/watch?v=EwTZ2xpQwpA</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">HTTP/1.1 200 OK</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">...</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Accept-Ranges: none</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="range-字段拆解"></a>Range 字段拆解<a class="hash-link" href="#range-字段拆解" title="Direct link to heading">#</a></h3><p>而对于客户端而言，它需要指定请求哪一部分，通过 Range 这个请求头字段确定，格式为bytes=x-y。接下来就来讨论一下这个 Range 的书写格式:</p><p>0-499 表示从开始到第 499 个字节。</p><p>500- 表示从第 500 字节到文件终点。</p><p>-100 表示文件的最后100个字节。</p><p>服务器收到请求之后，首先验证范围是否合法，如果越界了那么返回416错误码，否则读取相应片段，返回206状态码。同时，服务器需要添加 Content-Range 字段，这个字段的格式根据请求头中Range字段的不同而有所差异。具体来说，请求单段数据和请求多段数据，响应头是不一样的。举个例子:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 单段数据</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">curl http://i.imgur.com/z4d4kWk.jpg -i -H &quot;Range: bytes=0-1023&quot;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Range: bytes=0-9</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 多段数据</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">curl http://www.example.com -i -H &quot;Range: bytes=0-50, 100-150&quot;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Range: bytes=0-9, 30-39</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>接下来就分别来讨论着两种情况</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="单段数据"></a>单段数据<a class="hash-link" href="#单段数据" title="Direct link to heading">#</a></h3><p>对于单段数据的请求，返回的响应如下:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">HTTP/1.1 206 Partial Content</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Length: 10</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Accept-Ranges: bytes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Range: bytes 0-9/100</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">i am xxxxx</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>值得注意的是Content-Range字段，0-9表示请求的返回，100表示资源的总大小，很好理解。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="多段数据"></a>多段数据<a class="hash-link" href="#多段数据" title="Direct link to heading">#</a></h3><p>接下来看看多段请求的情况。得到的响应会是下面这个形式:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">HTTP/1.1 206 Partial Content</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Type: multipart/byteranges; boundary=00000010101</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Length: 189</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Connection: keep-alive</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Accept-Ranges: bytes</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">--00000010101</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Type: text/plain</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Range: bytes 0-9/96</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">i am xxxxx</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">--00000010101</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Type: text/plain</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Range: bytes 20-29/96</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">eex jspy e</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">--00000010101--</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这个时候出现了一个非常关键的字段Content-Type: multipart/byteranges;boundary=00000010101，它代表了信息量是这样的:</p><p>请求一定是多段数据请求</p><p>响应体中的分隔符是 00000010101</p><p>因此，在响应体中各段数据之间会由这里指定的分隔符分开，而且在最后的分隔末尾添上--表示结束。以上就是 http 针对大文件传输所采用的手段。</p><p>与分块传输编码的对比</p><p>Transfer-Encoding 首部允许分块编码，这在数据量很大，并且在请求未能完全处理完成之前无法知晓响应的体积大小的情况下非常有用。服务器会直接把数据发送给客户端而无需进行缓冲或确定响应的精确大小——后者会增加延迟。范围请求与分块传输是兼容的，可以单独或搭配使用</p><header><h1 class="h1Heading_27L5">9.HTTP 中如何处理表单数据的提交？</h1></header><p>在 http 中，有两种主要的表单提交的方式，体现在两种不同的Content-Type取值:</p><ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data
由于表单提交一般是POST请求，很少考虑GET，因此这里我们将默认提交的数据放在请求体中</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="applicationx-www-form-urlencoded"></a>application/x-www-form-urlencoded<a class="hash-link" href="#applicationx-www-form-urlencoded" title="Direct link to heading">#</a></h3><p>对于application/x-www-form-urlencoded格式的表单内容，有以下特点:</p><ul><li>其中的数据会被编码成以&amp;分隔的键值对</li><li>字符以URL编码方式编码。如：</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// 转换过程: {a: 1, b: 2} -&gt; a=1&amp;b=2 -&gt; 如下(最终形式)</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">&quot;a%3D1%26b%3D2&quot;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="multipartform-data"></a>multipart/form-data<a class="hash-link" href="#multipartform-data" title="Direct link to heading">#</a></h3><p>对于multipart/form-data而言:</p><p>请求头中的Content-Type字段会包含boundary，且boundary的值有浏览器默认指定。例:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>数据会分为多个部分，每两个部分之间通过分隔符来分隔，每部分表述均有 HTTP 头部描述子包体，如Content-Type，在最后的分隔符会加上--表示结束。</p><p>相应的请求体是下面这样:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Disposition: form-data;name=&quot;data1&quot;;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Type: text/plain</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">data1</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">----WebkitFormBoundaryRRJKeWfHPGrS4LKe</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Disposition: form-data;name=&quot;data2&quot;;</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">Content-Type: text/plain</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">data2</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">----WebkitFormBoundaryRRJKeWfHPGrS4LKe--</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>值得一提的是，multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述。另外，你可能在写业务的过程中，并没有注意到其中还有boundary的存在，如果你打开抓包工具，确实可以看到不同的表单元素被拆分开了，之所以在平时感觉不到，是以为浏览器和 HTTP 给你封装了这一系列操作。而且，在实际的场景中，对于图片等文件的上传，基本采用multipart/form-data而不用application/x-www-form-urlencoded，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。</p><header><h1 class="h1Heading_27L5">10.如何理解 HTTP 代理？</h1></header><p>我们知道在 HTTP 是基于请求-响应模型的协议，一般由客户端发请求，服务器来进行响应。当然，也有特殊情况，就是代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求，具有双重身份。那代理服务器到底是用来做什么的呢？</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="功能"></a>功能<a class="hash-link" href="#功能" title="Direct link to heading">#</a></h3><ul><li>负载均衡 客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP 都是多少，客户端是不知道的。因此，这个代理服务器可以拿到这个请求之后，可以通过特定的算法分发给不同的源服务器，让各台源服务器的负载尽量平均。当然，这样的算法有很多，包括随机算法、轮询、一致性hash、LRU(最近最少使用)等等，不过这些算法并不是本文的重点，大家有兴趣自己可以研究一下。</li><li>保障安全 利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法 IP 限流，这些都是代理服务器的工作。</li><li>缓存代理 将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="相关头部字段"></a>相关头部字段<a class="hash-link" href="#相关头部字段" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="via"></a>Via<a class="hash-link" href="#via" title="Direct link to heading">#</a></h4><p>代理服务器需要标明自己的身份，在 HTTP 传输中留下自己的痕迹，怎么办呢？通过Via字段来记录。举个例子，现在中间有两台代理服务器，在客户端发送请求后会经历这样一个过程:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">客户端 -&gt; 代理1 -&gt; 代理2 -&gt; 源服务器</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在源服务器收到请求后，会在请求头拿到这个字段:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Via: proxy_server1, proxy_server2</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>而源服务器响应时，最终在客户端会拿到这样的响应头:</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Via: proxy_server2, proxy_server1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>可以看到，Via中代理的顺序即为在 HTTP 传输中报文传达的顺序</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="x-forwarded-for"></a>X-Forwarded-For<a class="hash-link" href="#x-forwarded-for" title="Direct link to heading">#</a></h3><p>字面意思就是为谁转发, 它记录的是请求方的IP地址(注意，和Via区分开，X-Forwarded-For记录的是请求方这一个IP)。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="x-real-ip"></a>X-Real-IP<a class="hash-link" href="#x-real-ip" title="Direct link to heading">#</a></h3><p>是一种获取用户真实 IP 的字段，不管中间经过多少代理，这个字段始终记录最初的客户端的IP。相应的，还有X-Forwarded-Host和X-Forwarded-Proto，分别记录客户端(注意哦，不包括代理)的域名和协议名。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="x-forwarded-for产生的问题"></a>X-Forwarded-For产生的问题<a class="hash-link" href="#x-forwarded-for产生的问题" title="Direct link to heading">#</a></h3><p>前面可以看到，X-Forwarded-For这个字段记录的是请求方的 IP，这意味着每经过一个不同的代理，这个字段的名字都要变，从客户端到代理1，这个字段是客户端的 IP，从代理1到代理2，这个字段就变为了代理1的 IP。但是这会产生两个问题:</p><ul><li>意味着代理必须解析 HTTP 请求头，然后修改，比直接转发数据性能下降。</li><li>在 HTTPS 通信加密的过程中，原始报文是不允许修改的。
由此产生了代理协议，一般使用明文版本，只需要在 HTTP 请求行上面加上这样格式的文本即可:</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">// PROXY + TCP4/TCP6 + 请求方地址 + 接收方地址 + 请求端口 + 接收端口</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">PROXY TCP4 0.0.0.1 0.0.0.2 1111 2222</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">GET / HTTP/1.1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>这样就可以解决X-Forwarded-For带来的问题了</p><header><h1 class="h1Heading_27L5">11.说说 HTTP1.1 相比 HTTP1.0 提高了什么性能？</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http11-相比-http10-性能上的改进"></a>HTTP1.1 相比 HTTP1.0 性能上的改进：<a class="hash-link" href="#http11-相比-http10-性能上的改进" title="Direct link to heading">#</a></h3><ul><li>使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持 管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="但-http11-还是有性能瓶颈"></a>但 HTTP1.1 还是有性能瓶颈：<a class="hash-link" href="#但-http11-还是有性能瓶颈" title="Direct link to heading">#</a></h3><ul><li>请求/响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><header><h1 class="h1Heading_27L5">12.那上面的 HTTP1.1 的性能瓶颈，HTTP2 做了什么优化？</h1></header><p>HTTP/2是Web的未来，demo演示！HTTP2 协议是 基于 HTTPS 的，所以 HTTP2 的安全性也是有保障的。那 HTTP2 相比 HTTP1.1 性能上的改进：</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-头部压缩"></a>1. 头部压缩<a class="hash-link" href="#1-头部压缩" title="Direct link to heading">#</a></h3><p>HTTP2 会压缩头（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分。这就是所谓的 HPACK 算法</p><ul><li>索引表</li><li>霍夫曼编码
在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-二进制格式"></a>2. 二进制格式<a class="hash-link" href="#2-二进制格式" title="Direct link to heading">#</a></h3><p>HTTP2 不再像 HTTP1.1 里的纯文本形式的报文，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧(frame)：头信息帧和数据帧。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676788482-f127ef04-34cd-427b-b674-cda770590361.jpeg" alt="cda770590361"></p><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率
3. 数据流
HTTP2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。每个请求或回应的所有数据包，称为一个数据流（Stream）。每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数 客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676803623-149a236e-2b85-452b-bbab-5f8652be4b97.jpeg" alt="5f8652be4b97"></p><ul><li>同域名下所有通信都在单个连接上完成。</li><li>单个连接可以承载任意数量的双向数据流。</li><li>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装。</li></ul><p>这一特性，使性能有了极大提升：</p><ul><li>同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>单个连接上可以并行交错的请求和响应，之间互不干扰。</li><li>在HTTP2中，每个请求都可以带一个 31bit的优先值，0表示最高优先级， 数值越大优先级越低。有了这个优先值，客户端和服务器就可以在处理不同的流时采取不同的策略，以最优的方式发送流、消息和帧。</li></ul><ol start="4"><li>多路复用
HTTP2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。移除了 HTTP1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。
<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676819228-1126e51c-238b-4313-a85d-6eecf4d979e8.jpeg" alt="6eecf4d979e8"></li><li>服务器推送
HTTP2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，减少延时的等待，也就是服务器推送(Server Push，也叫 Cache Push)</li></ol><header><h1 class="h1Heading_27L5">13.HTTP2 有哪些缺陷？HTTP3 做了哪些优化？</h1></header><p>HTTP2 主要的问题在于，多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。</p><p>HTTP1.1 中的管道(pipeline) 传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</p><p>HTTP2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</p><p>这都是基于 TCP 传输层的问题，所以 HTTP3 把 HTTP 下层的 TCP 协议改成了 UDP！UDP 发生是不管顺序，也不管丢包的，所以不会出现 HTTP1.1 的队头阻塞 和 HTTP2 的一个丢包全部重传问题</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621676831299-afc9afd8-c38d-4e12-b22d-a65839883203.png?x-oss-process=image%2Fresize%2Cw_752" alt="2Fresize"></p><p>大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响。</p><p>TL3 升级成了最新的1.3版本，头部压缩算法也升级成了 QPack</p><p>HTTPS 要建立一个连接，要花费 6 次交互，先是建立三次握手，然后是 TLS/1.3 的三次握手。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互 合并成了 3 次，减少了交互次数</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621676845794-5c3d91d4-ebe1-4d9a-b0ae-ed4cf26e4ecd.png?x-oss-process=image%2Fresize%2Cw_752" alt="oss"></p><p>所以， QUIC 是一个在 UDP 之上的伪 TCP + TLS + HTTP2 的多路复用的协议。QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以 HTTP3 现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭 TCP</p><header><h1 class="h1Heading_27L5">14.HTTP 与 HTTPS 有哪些区别？</h1></header><ul><li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行SSL/TLS 的握手过程，才可进入加密报文传输。</li><li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的</li></ul><header><h1 class="h1Heading_27L5">15.HTTPS 解决了 HTTP 的哪些问题？</h1></header><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p><ul><li>窃听风险，比如通信链路上可以获取通信内容，用户号容易没。</li><li>篡改风险，比如强制入垃圾广告，视觉污染，用户眼容易瞎。</li><li>冒充风险，比如冒充淘宝网站，用户钱容易没。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676862414-e72f0276-7591-45a8-9050-798d233abf89.jpeg" alt="798d233abf89"></p><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL/TLS 协议，可以很好的解决了上述的风险：</p><ul><li>信息加密：交互信息无法被窃取</li><li>校验机制：无法篡改通信内容，篡改了就不能正常显示</li><li>身份证书：证明淘宝是真的淘宝网
可见，只要自身不做「恶」，SSL/TLS 协议是能保证通信是安全的</li></ul><header><h1 class="h1Heading_27L5">16.HTTPS 是如何解决上面的三个风险的？</h1></header><p>混合加密的方式实现信息的机密性，解决了窃听的风险。</p><ul><li>摘要算法的方式来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。</li><li>将服务器公钥放入到数字证书中，解决了冒充的风险</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="混合加密"></a>混合加密<a class="hash-link" href="#混合加密" title="Direct link to heading">#</a></h3><p>通过混合加密的方式可以保证信息的机密性，解决了窃听的风险。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676872729-2bfd9a9e-b22f-47bd-9edf-187fdc2ed7b1.jpeg" alt="187fdc2ed7b1"></p><p>混合加密 HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：</p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。
采用「混合加密」的方式的原因：</li><li>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="摘要算法"></a>摘要算法<a class="hash-link" href="#摘要算法" title="Direct link to heading">#</a></h3><p>摘要算法用来实现完整性，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险</p><p><img src="https://cdn.nlark.com/yuque/0/2021/png/396745/1621676883209-9b3618e3-86e4-420b-ae56-f7d473c47d4b.png" alt="f7d473c47d4b"></p><p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同 加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="数字证书"></a>数字证书<a class="hash-link" href="#数字证书" title="Direct link to heading">#</a></h3><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。这就存在些问题，如何保证公钥不被篡改和信任度？所以这里就需要借助第三方权威机构 CA（数字证书认证机构），将服务器公钥放在数字证书（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676905415-ee6d739a-8651-4a56-9dd7-7fa5236116b9.jpeg" alt="7fa5236116b9"></p><p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险</p><header><h1 class="h1Heading_27L5">17.HTTPS 是如何建立连接的？其间交互了什么？</h1></header><p>SSL/TLS 协议基本流程：
1.TCP 三次同步握手
2.客户端向服务器索要并验证服务器的公钥
3.双方协商生产「会话秘钥」
4.SSL 安全加密隧道协商完成
5.双方采用「会话秘钥」进行加密通信。
2，3步是 SSL/TLS 的建立过程，也就是握手阶段 SSL/TLS 的握手阶段涉及四次通信，可见下图：</p><p><img src="https://cdn.nlark.com/yuque/0/2021/jpeg/396745/1621676916202-07329012-1bc4-4a73-88d4-c82a59d17011.jpeg" alt="c82a59d17011"></p><p>SSL/TLS 协议建立的详细流程：</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="1-clienthello"></a>1. ClientHello<a class="hash-link" href="#1-clienthello" title="Direct link to heading">#</a></h3><p>首先，由客户端向服务器发起加密通信请求，也就是 ClientHello 请求。在这一步，客户端主要向服务器发送以下信息：（1）客户端支持的 SSL/TLS 协议版本，如 TLS 1.2 版本。（2）客户端生产的随机数（Client Random），后面用于生产「会话秘钥」。（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="2-severhello"></a>2. SeverHello<a class="hash-link" href="#2-severhello" title="Direct link to heading">#</a></h3><p>服务器收到客户端请求后，向客户端发出响应，也就是 SeverHello。服务器回应的内容有如下内容：（1）确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信。（2）服务器生产的随机数（Server Random），后面用于生产「会话秘钥」。（3）确认的密码套件列表，如 RSA 加密算法。（4）服务器的数字证书。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-客户端回应"></a>3. 客户端回应<a class="hash-link" href="#3-客户端回应" title="Direct link to heading">#</a></h3><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：
（1）一个随机数（pre-master key）。该随机数会被服务器公钥加密。
（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（3）客户端握手结束通知，表示客户端的握手阶段已经结束。
这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。上面第一项的随机数是整个握手阶段的第三个随机数，这样服务器和客户端就同时有三个随机数，接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="4-服务器的最后回应"></a>4. 服务器的最后回应<a class="hash-link" href="#4-服务器的最后回应" title="Direct link to heading">#</a></h3><p>服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发生最后的信息：
（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。
（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。
至此，整个 SSL/TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><header><h1 class="h1Heading_27L5">HTTP 如何实现长连接？在什么时候会超时？</h1></header><p>​                                                      <a href="https://www.iamshuaidi.com/author/%E5%B8%85%E5%9C%B0" target="_blank" rel="noopener noreferrer"><img src="https://www.iamshuaidi.com/wp-content/themes/ripro-v2/assets/img/avatar.png" alt="img">                </a>                                                        <a href="https://www.iamshuaidi.com/interview-netword" target="_blank" rel="noopener noreferrer">计算机网络面试题</a>                                                                                                  6月前                                                             0                             2.8K                                                   </p><p>通过在头部（请求和响应头）设置 Connection: keep-alive，HTTP1.0协议支持，但是默认关闭，从HTTP1.1协议以后，连接默认都是长连接</p><p>1、HTTP 一般会有 httpd 守护进程，里面可以设置 keep-alive timeout，当 tcp 链接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间</p><p>2、TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置：当 TCP 链接之后，闲置了  tcp_keepalive_time，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl  再发一次，直到发送了 tcp_keepalive_probes，就会丢弃该链接。</p><p>（1）tcp_keepalive_intvl = 15
（2）tcp_keepalive_probes = 5
（3）tcp_keepalive_time = 1800</p><p>实际上 HTTP 没有长短链接，只有 TCP 有，TCP 长连接可以复用一个 TCP 链接来发起多次 HTTP 请求，这样可以减少资源消耗，比如一次请求 HTML，可能还需要请求后续的 JS/CSS/图片等</p><header><h1 class="h1Heading_27L5">18.UDP 和 TCP 的区别</h1></header><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177774-3cc9c8eb-ee53-4db2-9947-a7656ed6e5c6.png?x-oss-process=image%2Fresize%2Cw_752" alt="1605846177774"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp协议的主要特点"></a>TCP协议的主要特点<a class="hash-link" href="#tcp协议的主要特点" title="Direct link to heading">#</a></h3><p>（1）TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。</p><p>（2）每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的；</p><p>（3）TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达；</p><p>（4）TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；</p><p>（5）面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，但就受访的TCP可能只用了4个数据块久保收到的字节流交付给上层的应用程序，但字节流完全一样。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp的可靠性原理"></a>TCP的可靠性原理<a class="hash-link" href="#tcp的可靠性原理" title="Direct link to heading">#</a></h3><p>可靠传输有如下两个特点:</p><p>a.传输信道无差错,保证传输数据正确;</p><p>b.不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;</p><p>（1）首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。</p><p>（2）其次，TCP采用了连续ARQ协议（回退N，Go-back-N；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。</p><p>（3）最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="udp协议特点"></a>UDP协议特点<a class="hash-link" href="#udp协议特点" title="Direct link to heading">#</a></h3><p>（１）UDP是无连接的传输层协议；</p><p>（２）UDP使用尽最大努力交付，不保证可靠交付；</p><p>（３）UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；</p><p>（４）UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率；</p><p>（５）UDP支持一对一　一对多　多对多的交互通信；</p><p>（６）UDP的首部开销小，只有８字节．</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp和udp的区别"></a>TCP和UDP的区别<a class="hash-link" href="#tcp和udp的区别" title="Direct link to heading">#</a></h3><p>(1)TCP是可靠传输,UDP是不可靠传输;</p><p>(2)TCP面向连接,UDP无连接;</p><p>(3)TCP传输数据有序,UDP不保证数据的有序性;</p><p>(4)TCP不保存数据边界,UDP保留数据边界;</p><p>(5)TCP传输速度相对UDP较慢;</p><p>(6)TCP有流量控制和拥塞控制,UDP没有;</p><p>(７)TCP是重量级协议,UDP是轻量级协议;</p><p>(８)TCP首部较长２０字节,UDP首部较短８字节;</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="基于tcp和udp的常用协议"></a>基于TCP和UDP的常用协议<a class="hash-link" href="#基于tcp和udp的常用协议" title="Direct link to heading">#</a></h3><p>HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp-和-udp-应用场景"></a>TCP 和 UDP 应用场景<a class="hash-link" href="#tcp-和-udp-应用场景" title="Direct link to heading">#</a></h3><p>TCP应用场景：</p><p>效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。举几个例子：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</p><p>UDP应用场景：</p><p>效率要求相对高，对准确性要求相对低的场景。举几个例子：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）</p><header><h1 class="h1Heading_27L5">19.TCP 三次握手和四次挥手</h1></header><p>TCP 三次握手和四次挥手也是面试题的热门考点，它们分别对应 TCP 的连接和释放过程。下面就来简单认识一下这两个过程</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp-三次握手"></a>TCP 三次握手<a class="hash-link" href="#tcp-三次握手" title="Direct link to heading">#</a></h3><p>在了解具体的流程前，需要先认识几个概念</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177774-3cc9c8eb-ee53-4db2-9947-a7656ed6e5c6.png?x-oss-process=image%2Fresize%2Cw_752" alt="a7656ed6e5c6"></p><ul><li>SYN：它的全称是 Synchronize Sequence Numbers，同步序列编号。是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立 TCP 连接时，首先会发送的一个信号。客户端在接受到 SYN 消息时，就会在自己的段内生成一个随机值 X。</li><li>SYN-ACK：服务器收到 SYN 后，打开客户端连接，发送一个 SYN-ACK 作为答复。确认号设置为比接收到的序列号多一个，即 X + 1，服务器为数据包选择的序列号是另一个随机数 Y。</li><li>ACK：Acknowledge character, 确认字符，表示发来的数据已确认接收无误。最后，客户端将 ACK 发送给服务器。序列号被设置为所接收的确认值即 Y + 1。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177739-6b49004e-50c5-449f-9528-4fa4fa065ca1.png?x-oss-process=image%2Fresize%2Cw_752" alt="1605846177739"></p><p>如果用现实生活来举例的话就是
小明 - 客户端 小红 - 服务端
小明给小红打电话，接通了后，小明说喂，能听到吗，这就相当于是连接建立。
小红给小明回应，能听到，你能听到我说的话吗，这就相当于是请求响应。
小明听到小红的回应后，好的，这相当于是连接确认。在这之后小明和小红就可以通话/交换信息了。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="tcp-四次挥手"></a>TCP 四次挥手<a class="hash-link" href="#tcp-四次挥手" title="Direct link to heading">#</a></h3><p>在连接终止阶段使用四次挥手，连接的每一端都会独立的终止。下面来描述一下这个过程。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177821-0d8def6c-ae30-492c-bc96-9d7cce1dd97a.png?x-oss-process=image%2Fresize%2Cw_752" alt="1605846177821"></p><p>首先，客户端应用程序决定要终止连接(这里服务端也可以选择断开连接)。这会使客户端将 FIN 发送到服务器，并进入 FIN_WAIT_1 状态。当客户端处于 FIN_WAIT_1 状态时，它会等待来自服务器的 ACK 响应。
然后第二步，当服务器收到 FIN 消息时，服务器会立刻向客户端发送 ACK 确认消息。
当客户端收到服务器发送的 ACK 响应后，客户端就进入 FIN_WAIT_2 状态，然后等待来自服务器的 FIN 消息
服务器发送 ACK 确认消息后，一段时间（可以进行关闭后）会发送 FIN 消息给客户端，告知客户端可以进行关闭。
当客户端收到从服务端发送的 FIN 消息时，客户端就会由 FIN_WAIT_2 状态变为 TIME_WAIT 状态。处于 TIME_WAIT 状态的客户端允许重新发送 ACK 到服务器为了防止信息丢失。客户端在 TIME_WAIT 状态下花费的时间取决于它的实现，在等待一段时间后，连接关闭，客户端上所有的资源（包括端口号和缓冲区数据）都被释放。
还是可以用上面那个通话的例子来进行描述
小明对小红说，我所有的东西都说完了，我要挂电话了。
小红说，收到，我这边还有一些东西没说。
经过若干秒后，小红也说完了，小红说，我说完了，现在可以挂断了
小明收到消息后，又等了若干时间后，挂断了电话。</p><header><h1 class="h1Heading_27L5">20.说说TCP传输的三次握手四次挥手策略</h1></header><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="三次握手"></a>三次握手<a class="hash-link" href="#三次握手" title="Direct link to heading">#</a></h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。
用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK</p><ul><li>发送端首先发送一个带SYN标志的数据包给对方。</li><li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。</li><li>最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">注意：若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="四次挥手"></a>四次挥手<a class="hash-link" href="#四次挥手" title="Direct link to heading">#</a></h3><p>断开一个TCP连接则需要四次挥手
第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据
第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）
第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了
第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</p><header><h1 class="h1Heading_27L5">21.什么是无状态协议，HTTP 是无状态协议吗，怎么解决</h1></header><p>无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。</p><p>HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力。</p><p>如果浏览器允许 cookie 的话，查看方式 chrome://settings/content/cookies</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177788-2976d50d-ab14-44d8-9e78-9f5d81abc58b.png?x-oss-process=image%2Fresize%2Cw_752" alt="1605846177788"></p><p>也就说明记忆芯片通电了…… 当向服务端发送请求时，服务端会发送一个认证信息，服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 sessionId ，并通过响应头的 Set-Cookie：JSESSIONID=XXXXXXX 命令，向客户端发送要求设置 Cookie 的响应；客户端收到响应后，在本机客户端设置了一个 JSESSIONID=XXXXXXX 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束；</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177705-0f30d158-d397-4213-8b4f-c20dc03688c8.png?x-oss-process=image%2Fresize%2Cw_752" alt="1605846177705"></p><p>接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。这样浏览器才具有了记忆能力。</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177744-a67ffd83-6a1e-46e9-87da-e4e860afabc1.png?x-oss-process=image%2Fresize%2Cw_752" alt="1605846177744"></p><p>还有一种方式是使用 JWT 机制，它也是能够让浏览器具有记忆能力的一种机制。与 Cookie 不同，JWT 是保存在客户端的信息，它广泛的应用于单点登录的情况。JWT 具有两个特点</p><ul><li>JWT 的 Cookie 信息存储在客户端，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。</li><li>JWT 支持跨域认证，Cookies 只能用在单个节点的域或者它的子域中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过多个节点进行用户认证，也就是常说的跨域认证。</li></ul><header><h1 class="h1Heading_27L5">22.OSI与TCP/IP各层的结构与功能,都有哪些协议?</h1></header><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1593078727023-8630bcab-5912-49f0-a81f-8833bfb0cfde.png?x-oss-process=image%2Fresize%2Cw_527" alt="1593078727023"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="应用层"></a>应用层<a class="hash-link" href="#应用层" title="Direct link to heading">#</a></h3><p>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的 HTTP协议，支持电子邮件的 SMTP协议等等。把应用层交互的数据单元称为报文。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="域名系统"></a>域名系统<a class="hash-link" href="#域名系统" title="Direct link to heading">#</a></h4><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.com%E3%80%81Oracle" target="_blank" rel="noopener noreferrer">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.com%E3%80%81Cisco%E5%85%AC%E5%8F%B8%E7%9A%84%E5%9F%9F%E5%90%8D%E6%98%AF" target="_blank" rel="noopener noreferrer">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com" target="_blank" rel="noopener noreferrer">www.cisco.com</a> 等。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="http协议"></a>HTTP协议<a class="hash-link" href="#http协议" title="Direct link to heading">#</a></h4><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="运输层"></a>运输层<a class="hash-link" href="#运输层" title="Direct link to heading">#</a></h3><p>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p>运输层主要使用以下两种协议:</p><ul><li>传输控制协议 TCP（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议 UDP（User Datagram Protocol）--提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ul><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="网络层"></a>网络层<a class="hash-link" href="#网络层" title="Direct link to heading">#</a></h3><p>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的</p><p>报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。</p><p>这里要注意：不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做网际层或IP层。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="数据链路层"></a>数据链路层<a class="hash-link" href="#数据链路层" title="Direct link to heading">#</a></h3><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="物理层"></a>物理层<a class="hash-link" href="#物理层" title="Direct link to heading">#</a></h3><p>在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。
<img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1593078986177-146b6237-b55d-4f92-9d8b-51daa816a935.png?x-oss-process=image%2Fresize%2Cw_752" alt="146b6237"></p><header><h1 class="h1Heading_27L5">23.TCP协议如何保证可靠传输</h1></header><p>1.应用数据被分割成 TCP 认为最适合发送的数据块。
2.TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3.校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4.流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
5.拥塞控制： 当网络拥塞时，减少数据的发送。
6.ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
7.超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
8.TCP 的接收端会丢弃重复的数据。</p><header><h1 class="h1Heading_27L5">24.说说ARQ协议</h1></header><p>自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><header><h1 class="h1Heading_27L5">25.什么是滑动窗口和流量控制</h1></header><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding  window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p><p>TCP  中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0  时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p><header><h1 class="h1Heading_27L5">26.什么是拥塞控制</h1></header><p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 慢开始 、 拥塞避免 、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><p>慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</p><p>拥塞避免： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</p><p>快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 </p><p>当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p><p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p><p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong></li></ul><p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p><ul><li><strong>拥塞避免：</strong></li></ul><p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</p><ul><li><strong>快重传与快恢复：</strong></li></ul><p>在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。</p><p>没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了  FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。</p><p>有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p><header><h1 class="h1Heading_27L5">27.在浏览器中输入url地址 -&gt;&gt; 显示主页的过程？</h1></header><p>总体来说分为以下几个过程:
1.DNS解析
2.TCP连接
3.发送HTTP请求
4.服务器处理请求并返回HTTP报文
5.浏览器解析渲染页面
6.连接结束</p><p><img src="https://img13.360buyimg.com/ddimg/jfs/t1/194370/24/11335/28269/60e00785E96723fe9/9ff5bb79624e811c.png" alt="360buyimg.png"></p><header><h1 class="h1Heading_27L5">28.HTTP长连接,短连接</h1></header><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。
而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Connection:keep-alive</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><header><h1 class="h1Heading_27L5">29.Cookie的作用是什么?和Session有什么区别？</h1></header><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。
Cookie 一般用来保存用户信息 比如
①在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；
②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；
③登录一次网站后访问网站其他页面不需要重新登录。
Session 的主要作用就是通过服务端记录用户的状态。 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。
Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。
Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><header><h1 class="h1Heading_27L5">30.URI和URL的区别是什么?</h1></header><p>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</p><p>URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><header><h1 class="h1Heading_27L5">31.HTTP常见的状态码有哪些？</h1></header><ul><li>1xx：指示信息--表示请求已接收，继续处理</li><li>2xx：成功--表示请求已被成功接收、理解、接受</li><li>3xx：重定向--要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误--请求有语法错误或请求无法实现</li><li>5xx：服务器端错误--服务器未能实现合法的请求</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="常见的状态码"></a>常见的状态码：<a class="hash-link" href="#常见的状态码" title="Direct link to heading">#</a></h4><ul><li>200：请求被正常处理</li><li>204：请求被受理但没有资源可以返回</li><li>206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。</li><li>301：永久性重定向</li><li>302：临时重定向</li><li>303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上</li><li>304：发送附带条件的请求时，条件不满足时返回，与重定向无关</li><li>307：临时重定向，与302类似，只是强制要求使用POST方法</li><li>400：请求报文语法有误，服务器无法识别</li><li>401：请求需要认证</li><li>403：请求的对应资源禁止被访问</li><li>404：服务器无法找到对应资源</li><li>500：服务器内部错误</li><li>503：服务器正忙</li></ul><header><h1 class="h1Heading_27L5">简单说下 HTTPS 和 HTTP 的区别</h1></header><p>Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：</p><p>1、端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；</p><p>2、资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；</p><p>3、开销：Https通信需要证书，而证书一般需要向认证机构购买；</p><p> Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制</p><header><h1 class="h1Heading_27L5">对称加密与非对称加密的区别</h1></header><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</p><p>而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><header><h1 class="h1Heading_27L5">32.说说常见的常见HTTP首部字段？</h1></header><p>通用首部字段（请求报文与响应报文都会使用的首部字段）
Date：创建报文时间Connection：连接的管理Cache-Control：缓存的控制Transfer-Encoding：报文主体的传输编码方式
请求首部字段（请求报文会使用的首部字段）
Host：请求资源所在服务器Accept：可处理的媒体类型Accept-Charset：可接收的字符集Accept-Encoding：可接受的内容编码Accept-Language：可接受的自然语言
响应首部字段（响应报文会使用的首部字段）
Accept-Ranges：可接受的字节范围Location：令客户端重新定向到的URIServer：HTTP服务器的安装信息
实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）
Allow：资源可支持的HTTP方法Content-Type：实体主类的类型Content-Encoding：实体主体适用的编码方式Content-Language：实体主体的自然语言Content-Length：实体主体的的字节数Content-Range：实体主体的位置范围，一般用于发出部分请求时使用</p><header><h1 class="h1Heading_27L5">33.HTTPS方式与web服务器通信的步骤？</h1></header><p>1、客户使用HTTPS的URL访问web服务器，要求与web服务器建立SSL连接
2、web服务器收到客户端请求后，将网站的证书信息（证书中包含公钥）传送一份给客户端
3、客户端的浏览器与web服务器开始协商SSL连接的安全等级，也就是信息的加密等级
4、客户端的浏览器根据双方同意的安全等级，建立会话秘钥，然后利用网站的公钥将会话秘钥加密，并传送给网站
5、web服务器利用自己的私钥解密出会话秘钥
6、web服务器利用会话秘钥加密与客户端之间的通信</p><header><h1 class="h1Heading_27L5">34.HTTP请求报文与响应报文格式？</h1></header><p>请求报文：
a、请求行：包含请求方法、URI、HTTP版本信息
b、请求首部字段
c、请求内容实体
响应报文：
a、状态行：包含HTTP版本、状态码、状态码的原因短语
b、响应首部字段
c、响应内容实体</p><header><h1 class="h1Heading_27L5">35.地址栏输入 URL 发生了什么？</h1></header><p>输入 URL 后到响应，都经历了哪些过程。</p><ul><li>首先，需要在浏览器中的 URL 地址上，输入要访问的地址，如下</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/396745/1605846177941-f76bb7ea-0f84-49d6-87de-03c2a85f1bf7.webp?x-oss-process=image%2Fresize%2Cw_752" alt="396745"></p><ul><li>然后，浏览器会根据输入的 URL 地址，去查找域名是否被本地 DNS 缓存，不同浏览器对 DNS 的设置不同，如果浏览器缓存了访问的 URL 地址，那就直接返回 ip。如果没有缓存 URL 地址，浏览器就会发起系统调用来查询本机 hosts 文件是否有配置 ip 地址，如果找到，直接返回。如果找不到，就向网络中发起一个 DNS 查询。</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">首先来看一下 DNS 是啥，互联网中识别主机的方式有两种，通过主机名和 IP 地址。人们喜欢用名字的方式进行记忆，但是通信链路中的路由却喜欢定长、有层次结构的 IP 地址。所以就需要一种能够把主机名到 IP 地址的转换服务，这种服务就是由 DNS 提供的。DNS 的全称是 Domain Name System 域名系统。DNS 是一种由分层的 DNS 服务器实现的分布式数据库。DNS 运行在 UDP 上，使用 53 端口。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/396745/1605846177879-93e58ff3-4eed-4900-a519-8658fbb1c870.webp?x-oss-process=image%2Fresize%2Cw_739" alt="1605846177879"></p><p>DNS 是一种分层数据库，它的主要层次结构如下</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/396745/1605846177891-dea3dd09-48b5-4a17-93ee-83270a2e035e.png?x-oss-process=image%2Fresize%2Cw_752" alt="2Cw_752"></p><p>一般域名服务器的层次结构主要是以上三种，除此之外，还有另一类重要的 DNS 服务器，它是 本地 DNS 服务器(local DNS server)。严格来说，本地 DNS 服务器并不属于上述层次结构，但是本地 DNS 服务器又是至关重要的。每个 ISP(Internet Service Provider) 比如居民区的 ISP 或者一个机构的 ISP 都有一台本地 DNS 服务器。当主机和 ISP 进行连接时，该 ISP 会提供一台主机的 IP 地址，该主机会具有一台或多台其本地 DNS 服务器的 IP地址。通过访问网络连接，用户能够容易的确定 DNS 服务器的 IP地址。当主机发出 DNS 请求后，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 服务器层次系统中。</p><p>首先，查询请求会先找到本地 DNS 服务器来查询是否包含 IP 地址，如果本地 DNS 无法查询到目标 IP 地址，就会向根域名服务器发起一个 DNS 查询。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">注意：DNS 涉及两种查询方式：一种是递归查询(Recursive query) ，一种是迭代查询(Iteration query)。《计算机网络：自顶向下方法》竟然没有给出递归查询和迭代查询的区别，找了一下网上的资料大概明白了下。</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">如果根域名服务器无法告知本地 DNS 服务器下一步需要访问哪个顶级域名服务器，就会使用递归查询；</span></span><span class="token-line" style="color:#bfc7d5"><span class="token plain">如果根域名服务器能够告知 DNS 服务器下一步需要访问的顶级域名服务器，就会使用迭代查询。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>在由根域名服务器 -&gt; 顶级域名服务器 -&gt; 权威 DNS 服务器后，由权威服务器告诉本地服务器目标 IP 地址，再有本地 DNS 服务器告诉用户需要访问的 IP 地址。</p><ul><li>第三步，浏览器需要和目标服务器建立 TCP 连接，需要经过三次握手的过程，具体的握手过程请参考上面的回答。</li><li>在建立连接后，浏览器会向目标服务器发起 HTTP-GET 请求，包括其中的 URL，HTTP 1.1 后默认使用长连接，只需要一次握手即可多次传输数据。</li><li>如果目标服务器只是一个简单的页面，就会直接返回。但是对于某些大型网站的站点，往往不会直接返回主机名所在的页面，而会直接重定向。返回的状态码就不是 200 ，而是 301,302 以 3 开头的重定向码，浏览器在获取了重定向响应后，在响应报文中 Location 项找到重定向地址，浏览器重新第一步访问即可。</li><li>然后浏览器重新发送请求，携带新的 URL，返回状态码 200 OK，表示服务器可以响应请求，返回报文。</li></ul><header><h1 class="h1Heading_27L5">在浏览器中输入 URL 地址到显示主页的过程？</h1></header><ol><li>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS  缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS  服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地  DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP  地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；</li><li>服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li><li>连接结束。</li></ol><header><h1 class="h1Heading_27L5">36.HTTPS的工作原理</h1></header><p>上面描述了一下 HTTP 的工作原理，下面来讲述一下 HTTPS 的工作原理。因为 HTTPS 不是一种新出现的协议，而是</p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/396745/1605846177900-178e80d0-b81f-490c-b1e0-badf6fe07d23.webp?x-oss-process=image%2Fresize%2Cw_752" alt="396745"></p><p>所以探讨 HTTPS 的握手过程，其实就是 SSL/TLS 的握手过程。</p><p>TLS 旨在为 Internet 提供通信安全的加密协议。TLS 握手是启动和使用 TLS 加密的通信会话的过程。在 TLS 握手期间，Internet 中的通信双方会彼此交换信息，验证密码套件，交换会话密钥。
每当用户通过 HTTPS 导航到具体的网站并发送请求时，就会进行 TLS 握手。除此之外，每当其他任何通信使用HTTPS（包括 API 调用和在 HTTPS 上查询 DNS）时，也会发生 TLS 握手。</p><p>TLS 具体的握手过程会根据所使用的密钥交换算法的类型和双方支持的密码套件而不同。以RSA 非对称加密来讨论这个过程。整个 TLS 通信流程图如下</p><p><img src="https://cdn.nlark.com/yuque/0/2020/webp/396745/1605846178032-7edb45c5-a049-4a22-a6d5-556eeb069f7f.webp?x-oss-process=image%2Fresize%2Cw_752" alt="7edb45c5"></p><ul><li>在进行通信前，首先会进行 HTTP 的三次握手，握手完成后，再进行 TLS 的握手过程</li><li>ClientHello：客户端通过向服务器发送 hello 消息来发起握手过程。这个消息中会夹带着客户端支持的 TLS 版本号(TLS1.0 、TLS1.2、TLS1.3) 、客户端支持的密码套件、以及一串 客户端随机数。</li><li>ServerHello：在客户端发送 hello 消息后，服务器会发送一条消息，这条消息包含了服务器的 SSL 证书、服务器选择的密码套件和服务器生成的随机数。</li><li>认证(Authentication)：客户端的证书颁发机构会认证 SSL 证书，然后发送 Certificate 报文，报文中包含公开密钥证书。最后服务器发送 ServerHelloDone 作为 hello 请求的响应。第一部分握手阶段结束。</li><li>加密阶段：在第一个阶段握手完成后，客户端会发送 ClientKeyExchange 作为响应，这个响应中包含了一种称为 The premaster secret 的密钥字符串，这个字符串就是使用上面公开密钥证书进行加密的字符串。随后客户端会发送 ChangeCipherSpec，告诉服务端使用私钥解密这个 premaster secret 的字符串，然后客户端发送 Finished 告诉服务端自己发送完成了。</li></ul><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">Session key 其实就是用公钥证书加密的公钥。</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><ul><li>实现了安全的非对称加密：然后，服务器再发送 ChangeCipherSpec 和 Finished 告诉客户端解密完成，至此实现了 RSA 的非对称加密。</li></ul><p>三、TCP是底层通讯协议，定义的是数据传输和连接方式的规范
HTTP是应用层协议，定义的是传输数据的内容的规范</p><p>HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP</p><p> TCP即传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通讯协议。</p><p>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p><p>应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受计算连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传输给IP层，有它来通过网络将包传送给接收端实体的TCP层。</p><p>二、主要特点</p><p>当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文。之后TCP把数据包传递给IP层，由它来通过网络将包传送给接收端实体的TCP层。</p><p>TCP是一种面向广域网的通信协议，目的是在跨越多个网络通信时，为两个通信端点之间提供一条具有一下特点的通信方式：</p><p>（1）基于流的方式；</p><p>（2）面向连接；</p><p>（3）可靠通信方式；</p><p>（4）在网络情况不佳的时候尽量降低系统由于重传带来的带宽开销；</p><p>（5）通信连接维护是面向的两个端点的，而不考虑中间网段和节点。</p><p>为满足TCP协议的这些特点，TCP协议做了以下规定：</p><p>①数据分片：在发送端对用户数据进行分片，在接收端进行重组，由TCP确定分片的大小并控制分片和重组；</p><p>②到达确认：接收端接收到分片数据时，根据分片数据序号向发送端发送一个确认；</p><p>③超时重发：发送方在发送分片时启动超时定时器，如果在定时器超时之后没有接收到对应的确认，重发分片；</p><p>④滑动窗口：TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出；</p><p>⑤失序处理：作为IP数据报来传输的TCP分片到达时可能会失序，TCP将对接收的数据进行重新排序，将接收到的数据以正确的顺序交给应用层；</p><p>⑥重复处理：作为IP数据报来传输的TCP分片会发生重复，TCP的接收端必须丢弃重复的数据；</p><p>⑦数据校验：TCP将保持它首部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到分片的校验和由差错，TCP将丢弃这个分片，并确认接收到此报文段导致对端超时并重发。</p><p>HTTP和TCP的关系</p><p>创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。</p><p>socket则是对TCP/IP协议的封装和应用（程序员层面上）。也可以说，TPC/IP协议是传输层协议，主要解决数据 如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：</p><p>“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如 果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也 可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。</p><p>我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口
（API），通过Socket，我们才能使用TCP/IP协议。 实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现 只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等。网络有一段关于socket和TCP/IP协议关系的说法比较容易理解：</p><p>“TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。” </p><p>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些.</p><p>Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p><p>Http连接：http连接就是所谓的短连接，及客户端向服务器发送一次请求，服务器端相应后连接即会断掉。</p><p>socket连接：socket连接及时所谓的长连接，理论上客户端和服务端一旦建立连接，则不会主动断掉；但是由于各种环境因素可能会是连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有数据传输，网络防火墙可能会断开该链接已释放网络资源。所以当一个socket连接中没有数据的传输，那么为了位置连续的连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。</p><header><h1 class="h1Heading_27L5">ARP 协议的工作原理？</h1></header><p>网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP  列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP  地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP  请求的广播包，查询此目的主机对应的 MAC 地址。</p><p>此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP  请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP  响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC  地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败</p><header><h1 class="h1Heading_27L5">什么是数字签名？</h1></header><p>为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。</p><header><h1 class="h1Heading_27L5">什么是数字证书？</h1></header><p>对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。</p><header><h1 class="h1Heading_27L5">DNS 为什么用 UDP</h1></header><p>其实 DNS 的整个过程是既使用 TCP 又使用 UDP。</p><p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的 TCP。</p><p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP  传输时，不需要经过 TCP 三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。</p><header><h1 class="h1Heading_27L5">TIME_WAIT 状态会导致什么问题，怎么解决</h1></header><p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP  服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个  socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p><p>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p><p><strong>下面是读者提供的具体操作</strong></p><p>修改配置文件：/etc/sysctl.conf</p><p>net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p><p>net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭</p><header><h1 class="h1Heading_27L5">有很多 TIME-WAIT 状态如何解决</h1></header><p>服务器可以设置 SO_REUSEADDR 套接字选项来通知内核，如果端口被占用，但 TCP 连接位于 TIME_WAIT  状态时可以重用端口。如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时 SO_REUSEADDR 选项就可以避免  TIME-WAIT 状态。</p><p>也可以采用长连接的方式减少 TCP 的连接与断开，在长连接的业务中往往不需要考虑 TIME-WAIT 状态，但其实在长连接的业务中并发量一般不会太高。</p><header><h1 class="h1Heading_27L5">CP 最大连接数限制</h1></header><p><strong>如何标识一个TCP连接</strong></p><p>在确定最大连接数之前，先来看看系统如何标识一个tcp连接。系统用一个4四元组来唯一标识一个TCP连接：{local ip, local port,remote ip,remote port}。</p><p><strong>client最大tcp连接数</strong></p><p>client每次发起tcp连接请求时，除非绑定端口，通常会让系统选取一个空闲的本地端口（local  port），该端口是独占的，不能和其他tcp连接共享。tcp端口的数据类型是unsigned  short，因此本地端口个数最大只有65536，端口0有特殊含义，不能使用，这样可用端口最多只有65535，所以在全部作为client端的情况下，最大tcp连接数为65535，这些连接可以连到不同的server ip。</p><p><strong>server最大tcp连接数</strong></p><p>server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（unix的SO_REUSEADDR选项）的情况下，即使server端有多个ip，本地监听端口也是独占的，因此server端tcp连接4元组中只有remote ip（也就是client ip）和remote  port（客户端port）是可变的，因此最大tcp连接为客户端ip数×客户端port数，对IPV4，不考虑ip地址分类等因素，最大tcp连接数约为2的32次方（ip数）×2的16次方（port数），也就是server端单机最大tcp连接数约为2的48次方。</p><p><strong>实际的tcp连接数</strong></p><p>上面给出的是理论上的单机最大连接数，在实际环境中，受到机器资源、操作系统等的限制，特别是sever端，其最大并发tcp连接数远不能达到理论上限。在unix/linux下限制连接数的主要因素是内存和允许的文件描述符个数（每个tcp连接都要占用一定内存，每个socket就是一个文件描述符），另外1024以下的端口通常为保留端口。在默认2.6内核配置下，经过试验，每个socket占用内存在15~20k之间。</p><p>影响一个socket占用内存的参数包括：</p><p>rmem_max</p><p>wmem_max</p><p>tcp_rmem</p><p>tcp_wmem</p><p>tcp_mem</p><p>grep skbuff /proc/slabinfo</p><p>对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP连接数超过10万 是没问题的，国外 Urban Airship 公司在产品环境中已做到 50 万并发 。在实际应用中，对大规模网络应用，还需要考虑C10K 问题。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="3-tcp和http有什么联系"></a><strong>3 tcp和http有什么联系</strong><a class="hash-link" href="#3-tcp和http有什么联系" title="Direct link to heading">#</a></h3><p>HTTP是应用层协议，定义的是传输数据的内容的规范</p><p>不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。</p><p>TCP即传输控制协议（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通讯协议。
HTTP协议中的数据是利用TCP协议传输的，所以支持HTTP也就一定支持TCP
应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受计算连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传输给IP层，有它来通过网络将包传送给接收端实体的TCP层。</p><p>当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文。之后TCP把数据包传递给IP层，由它来通过网络将包传送给接收端实体的TCP层。
Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP/IP协议。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="5-线程如何结束"></a><strong>5 线程如何结束</strong><a class="hash-link" href="#5-线程如何结束" title="Direct link to heading">#</a></h3><p> <a href="https://blog.csdn.net/weixin_41563161/article/details/104942044" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_41563161/article/details/104942044</a>
1使用标志位
这种方法是我尝试终止线程时最初采用的方法，使用起来很方便，原理也很简单，只要在while循环里持续判断一个Boolean变量的值就可以了，一旦满足离开循环的条件，那么就可以离开线程的方法体，结束线程。
2 使用Interrupt方法（中断）</p><p>1.线程处于阻塞状态，如使用了sleep,同步锁的wait,socket中的receiver,accept等方法时，会使线程处于阻塞状态。当调用线程的interrupt()方法时，会抛出InterruptException异常。阻塞中的那个方法抛出这个异常，通过代码捕获该异常，然后break跳出循环状态，从而让我们有机会结束这个线程的执行。通常很多人认为只要调用interrupt方法线程就会结束，实际上是错的， 一定要先捕获InterruptedException异常之后通过break来跳出循环，才能正常结束run方法。
2.线程未处于阻塞状态，使用isInterrupted()判断线程的中断标志来退出循环。当使用interrupt()方法时，中断标志就会置true，和使用自定义的标志来控制循环是一样的道理。</p><p>3为什么要区分进入阻塞状态和和非阻塞状态两种情况了，是因为当阻塞状态时，如果有interrupt()发生，系统除了会抛出InterruptedException异常外，还会调用interrupted()函数，调用时能获取到中断状态是true的状态，调用完之后会复位中断状态为false，所以异常抛出之后通过isInterrupted()是获取不到中断状态是true的状态，从而不能退出循环，</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="7-深拷贝浅拷贝"></a><strong>7 深拷贝浅拷贝</strong><a class="hash-link" href="#7-深拷贝浅拷贝" title="Direct link to heading">#</a></h3><p> <a href="https://blog.csdn.net/weixin_41563161/article/details/101628243" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_41563161/article/details/101628243</a>
1哪些地方用到深拷贝 浅拷贝
深拷贝和浅拷贝相当于是对象拷贝，引用拷贝的话是共用同一个对象，地址是相同的，对象拷贝的是创建了新的对象。又分为深拷贝和浅拷贝。</p><p>浅拷贝 （浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象）
被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。&quot;里面的对象“会在原来的对象和它的副本之间共享。</p><p>深拷贝 对引用类型的成员变量也进行引用对象的复制 clone（） </p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="8-线程池"></a><strong>8 线程池</strong><a class="hash-link" href="#8-线程池" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="17-socket如何解决丢包"></a>17 Socket如何解决丢包<a class="hash-link" href="#17-socket如何解决丢包" title="Direct link to heading">#</a></h3><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="18-其它-网络通信的方式"></a>18 其它 网络通信的方式<a class="hash-link" href="#18-其它-网络通信的方式" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="旋转数组"></a><strong>旋转数组</strong><a class="hash-link" href="#旋转数组" title="Direct link to heading">#</a></h4><p><strong>1 题目</strong>
：运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。</p><div class="codeBlockContainer_K1bP"><div class="codeBlockContent_hGly"><pre tabindex="0" class="prism-code language-undefined codeBlock_23N8 thin-scrollbar" style="color:#bfc7d5;background-color:#292d3e"><code class="codeBlockLines_39YC"><span class="token-line" style="color:#bfc7d5"><span class="token plain">                          Tcp三次握手中细节</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_Ue-o clean-btn">Copy</button></div></div><p>TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接，如下图所示。
主机A为客户机，主机B为服务器</p><p>说明：（1）第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
（2）第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
（3）第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</p><p> 第一次握手A发送SYN传输失败，A,B都不会申请资源，连接失败。如果一段时间内发出多个SYN连接请求，那么A只会接受它最后发送的那个SYN的SYN+ACK回应，忽略其他回应全部回应，B中多申请的资源也会释放
第二次握手B发送SYN+ACK传输失败，A不会申请资源，B申请了资源，但收不到A的ACK，过一段时间释放资源。如果是收到了多个A的SYN请求，B都会回复SYN+ACK，但A只会承认其中它最早发送的那个SYN的回应，并回复最后一次握手的ACK
第三次握手ACK传输失败，B没有收到ACK，释放资源，对于后序的A的传输数据返回RST。实际上B会因为没有收到A的ACK会多次发送SYN+ACK，次数是可以设置的，如果最后还是没有收到A的ACK，则释放资源，对A的数据传输返回RST</p><p>问题1初始化序列号X、Y是可以是写死固定的吗，为什么不能呢？</p><p>如果初始化序列号（缩写为ISN：Inital Sequence Number）可以固定，我们来看看会出现什么问题。假设ISN固定是1，Client和Server建立好一条TCP连接后，Client连续给Server发了10个包，这10个包不知怎么被链路上的路由器缓存了(路由器会毫无先兆地缓存或者丢弃任何的数据包)，这个时候碰巧Client挂掉了，然后Client用同样的端口号重新连上Server，Client又连续给Server发了几个包，假设这个时候Client的序列号变成了5。接着，之前被路由器缓存的10个数据包全部被路由到Server端了，Server给Client回复确认号10，这个时候，Client整个都不好了，这是什么情况？我的序列号才到5，你怎么给我的确认号是10了，整个都乱了。
RFC793中，建议ISN和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始，这需要4小时才会产生ISN的回绕问题，这几乎可以保证每个新连接的ISN不会和旧的连接的ISN产生冲突。这种递增方式的ISN，很容易让攻击者猜测到TCP连接的ISN，现在的实现大多是在一个基准值的基础上进行随机的。
问题2 假如Client发送一个SYN包给Server后就挂了或是不管了，这个时候这个连接处于什么状态呢？会超时吗？为什么呢？</p><p>Client发送SYN包给Server后挂了，Server回给Client的SYN-ACK一直没收到Client的ACK确认，这个时候这个连接既没建立起来，也不能算失败。这就需要一个超时时间让Server将这个连接断开，否则这个连接就会一直占用Server的SYN连接队列中的一个位置，大量这样的连接就会将Server的SYN连接队列耗尽，让正常的连接无法得到处理。目前，Linux下默认会进行5次重发SYN-ACK包，重试的间隔时间从1s开始，下次的重试间隔时间是前一次的双倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会把断开这个连接。由于，SYN超时需要63秒，那么就给攻击者一个攻击服务器的机会，攻击者在短时间内发送大量的SYN包给Server(俗称 SYN flood 攻击)，用于耗尽Server的SYN队列。对于应对SYN 过多的问题，linux提供了几个TCP参数：tcp_syncookies、tcp_synack_retries、tcp_max_syn_backlog、tcp_abort_on_overflow 来调整应对。
问题3 Client和Server同时发起断开连接的FIN包会怎么样呢，TCP状态是怎么转移的?</p><p>由上面的”TCP协议状态机 “图可以看出，TCP的Peer端在收到对端的FIN包前发出了FIN包，那么该Peer的状态就变成了FIN_WAIT1，Peer在FIN_WAIT1状态下收到对端Peer对自己FIN包的ACK包的话，那么Peer状态就变成FIN_WAIT2，Peer在FIN_WAIT2下收到对端Peer的FIN包，在确认已经收到了对端Peer全部的Data数据包后，就响应一个ACK给对端Peer，然后自己进入TIME_WAIT状态；但是如果Peer在FIN_WAIT1状态下首先收到对端Peer的FIN包的话，那么该Peer在确认已经收到了对端Peer全部的Data数据包后，就响应一个ACK给对端Peer，然后自己进入CLOSEING状态，Peer在CLOSEING状态下收到自己的FIN包的ACK包的话，那么就进入TIME WAIT 状态。于是，TCP的Peer两端同时发起FIN包进行断开连接，那么两端Peer可能出现完全一样的状态转移 FIN_WAIT1——&gt;CLOSEING——-&gt;TIME_WAIT，也就会Client和Server最后同时进入TIME_WAIT状态。同时关闭连接的状态转移如下图所示：
问题4 左侧图中的四次挥手过程中，Server端的ACK确认包能不能和接下来的FIN包合并成一个包呢，这样四次挥手就变成三次挥手了。</p><p>答案是可能的。TCP是全双工通信，Cliet在自己已经不会在有新的数据要发送给Server后，可以发送FIN信号告知Server，这边已经终止Client到对端Server那边的数据传输。但是，这个时候对端Server可以继续往Client这边发送数据包。于是，两端数据传输的终止在时序上是独立并且可能会相隔比较长的时间，这个时候就必须最少需要2+2 = 4 次挥手来完全终止这个连接。但是，如果Server在收到Client的FIN包后，在也没数据需要发送给Client了，那么对Client的ACK包和Server自己的FIN包就可以合并成为一个包发送过去，这样四次挥手就可以变成三次了(似乎linux协议栈就是这样实现的)
问题 5四次挥手过程中，首先断开连接的一端，在回复最后一个ACK后，为什么要进行TIME_WAIT呢(超时设置是 2*MSL，RFC793定义了MSL为2分钟，Linux设置成了30s)，在TIME_WAIT的时候又不能释放资源，白白让资源占用那么长时间，能不能省了TIME_WAIT呢，为什么？</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="问题6-三次挥手可以吗"></a>问题6 三次挥手可以吗<a class="hash-link" href="#问题6-三次挥手可以吗" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="问题7-建立连接的第二个syn是干什么的"></a>问题7 建立连接的第二个syn是干什么的<a class="hash-link" href="#问题7-建立连接的第二个syn是干什么的" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="问题8-time_wait产生的原因以及time_wait2msl的原因"></a>问题8 Time_wait产生的原因以及Time_wait（2MSL）的原因<a class="hash-link" href="#问题8-time_wait产生的原因以及time_wait2msl的原因" title="Direct link to heading">#</a></h4><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2LWZ" id="问题9-关闭连接时最后一个ack丢失了怎么办"></a>问题9 关闭连接时最后一个ACK丢失了怎么办<a class="hash-link" href="#问题9-关闭连接时最后一个ack丢失了怎么办" title="Direct link to heading">#</a></h4><header><h1 class="h1Heading_27L5">什么是 NAT 网络地址转换协议？</h1></header><p>​                                                      <a href="https://www.iamshuaidi.com/author/%E5%B8%85%E5%9C%B0" target="_blank" rel="noopener noreferrer"><img src="https://www.iamshuaidi.com/wp-content/themes/ripro-v2/assets/img/avatar.png" alt="img">                </a>                                                        <a href="https://www.iamshuaidi.com/computer-netword" target="_blank" rel="noopener noreferrer">计算机网络</a>                                                                                                  1月前                                                             0                             198                                                   </p><p>可能你们会经常听到<strong>全球 IP(外网)</strong>和<strong>私有 IP(内网)</strong>，他们的区别是什么呢？今天这篇文章来简单讲讲这到底是怎么回事。</p><p>我们都知道，IPv4中的IP地址的数量是有限的，每次把一部分地址分配出去，那么就意味着能够用来分配的IP地址就更少了，而且随着现在手机，电脑等的快速发展，如果每个手机或者电脑都要求一个IP地址，那么显然IP地址是不够用的。</p><p>为了解决这个问题，我们可以采取这样的<strong>策略</strong>：例如对于一个公司来说，每个公司都会有一个属于自己公司的内网(也可以称之为局域网)。</p><p>假如我们给这个公司A分配了一个IP=192.168.1.1。我们把这个IP作为这个公司内网的<strong>网关</strong>吧。</p><p><img src="https://gitee.com/iamshuaidi/picture/raw/master/picture/640-20210910201402911.png" alt="图片"></p><p>在公司A的内网里面有3台电脑，如果这三台电脑要上网的话，我们需要给他分配一个IP，那么我们一定需要去申请3个IP地址来使用吗？</p><p>答否。我们不一定需要去申请3个IP的，在我们这个内网里，我们可以指定自己的规则，例如，我们可以给这三台电脑随便分配三个IP(请注意，这三个IP不是去申请的，而且我自己随意给它分配的)。分别分配电脑A = 192.168.1.2  电脑B = 192.168.1.3 电脑C = 192.168.1.4</p><p><img src="https://gitee.com/iamshuaidi/picture/raw/master/picture/640-20210910201420835.png" alt="图片"></p><p>假如电脑A想要访问百度，百度的IP我们假设为：172.168.30.3</p><p><img src="https://gitee.com/iamshuaidi/picture/raw/master/picture/640-20210910201434288.png" alt="图片"></p><p>我们都知道，电脑A的IP是我们<strong>虚构</strong>的，实际上可能并不存在这样一个IP，如果用电脑A的IP去访问百度，那肯定行不通。</p><p>我们也知道，由于百度和电脑A不在一个<strong>局域网内</strong>，所以A要访问百度，那么必须得经过网关。而网关的这个IP地址，是<strong>真实存在</strong>的，是可以访问百度的。</p><p>为了让 A 可以访问百度，那么我们可以采取这样的方法：让网关去帮助 A 访问，然后百度把结果传递给网关，而网关再把结果传递给 A，这样不就可以解决了？</p><p><img src="https://gitee.com/iamshuaidi/picture/raw/master/picture/640-20210910201504599.png" alt="图片"></p><p>不过电脑A, B, C都可能拜托网关去帮忙访问百度，而百度返回的结果 的<strong>目的IP</strong>都是网关的IP=192.168.1.1。那么网关该如何进行区分这结果是A的，B的还是C的呢？</p><p>我们去访问百度的时候，不是需要指定一个端口吗？只要我们把 A的IP + 端口 映射成 网关的IP+端口，不就可以唯一确定身份了？</p><p>例如A用端口60去访问百度，网关把  A的IP+端口60   映射成   网关的IP+端口80 不就可以了？</p><p><img src="https://gitee.com/iamshuaidi/picture/raw/master/picture/640-20210910201528524.png" alt="图片"></p><p>百度把结果返回给网关的80端口之后，网关再通过映射表，就可以把结果返回给 A的60端口 了。</p><p>如果B也是用60端口去访问百度的话，也是一样，可以把它映射到90端口。</p><p><img src="https://gitee.com/iamshuaidi/picture/raw/master/picture/640-20210910201543272.jpeg" alt="图片"></p><p>这种方法地址的映射转换，我们也称之为<strong>网络地址转换</strong>。英文为 Network Address Translation，简称<strong>NAT</strong>。</p><p>而像A, B, C这样的IP地址我们也称之为<strong>内网IP</strong>，即<strong>私有IP</strong>；而像网关，百度这样的IP我们称之为<strong>外网IP</strong>，即<strong>全球IP</strong>。现在知道外网IP和内网IP了吧？</p><p><strong>几点需要注意的地方</strong></p><p>1、对于全球IP，显然每个IP都是唯一的，而对于私有IP，同一个局域网内，也得是唯一的，但在两个不同的局域网中，是可以有相同的私有IP的。</p><p>2、局域网内主机之间的通信，是不需要进行地址转换的，而如果需要访问外网，才需要进行地址转换。</p><p>实际上，我们也可以把这种地址转换称之为一种<strong>代理</strong>。网关就相当于一个代理，把局域网内的主机的一些信息都给隐藏了起来。百度并不知道是主机A访问它，他只知道是网关访问了它。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><a href="https://github.com/worst0/wiki_note/edit/main/docs/11.Interview/D9.网络原理面试题.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_2_ui" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_3DPF"></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/Interview/D8.网络编程面试题"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« D8.网络编程面试题</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/Interview/D10.语言语法面试题"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">D10.语言语法面试题 »</div></a></div></nav></div></div><div class="col col--3"><div class="tableOfContents_35-E thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#uri-的结构" class="table-of-contents__link">URI 的结构</a></li><li><a href="#uri-编码" class="table-of-contents__link">URI 编码</a></li><li><a href="#协议" class="table-of-contents__link">协议</a></li><li><a href="#传输" class="table-of-contents__link">传输</a></li><li><a href="#超文本" class="table-of-contents__link">超文本</a></li><li><a href="#http-的特点概括" class="table-of-contents__link">HTTP 的特点概括</a></li><li><a href="#http-缺点" class="table-of-contents__link">HTTP 缺点</a></li><li><a href="#起始行" class="table-of-contents__link">起始行</a></li><li><a href="#头部" class="table-of-contents__link">头部</a></li><li><a href="#空行" class="table-of-contents__link">空行</a></li><li><a href="#实体" class="table-of-contents__link">实体</a></li><li><a href="#定长包体" class="table-of-contents__link">定长包体</a></li><li><a href="#不定长包体" class="table-of-contents__link">不定长包体</a></li><li><a href="#如何支持" class="table-of-contents__link">如何支持</a></li><li><a href="#range-字段拆解" class="table-of-contents__link">Range 字段拆解</a></li><li><a href="#单段数据" class="table-of-contents__link">单段数据</a></li><li><a href="#多段数据" class="table-of-contents__link">多段数据</a></li><li><a href="#applicationx-www-form-urlencoded" class="table-of-contents__link">application/x-www-form-urlencoded</a></li><li><a href="#multipartform-data" class="table-of-contents__link">multipart/form-data</a></li><li><a href="#功能" class="table-of-contents__link">功能</a></li><li><a href="#相关头部字段" class="table-of-contents__link">相关头部字段</a></li><li><a href="#x-forwarded-for" class="table-of-contents__link">X-Forwarded-For</a></li><li><a href="#x-real-ip" class="table-of-contents__link">X-Real-IP</a></li><li><a href="#x-forwarded-for产生的问题" class="table-of-contents__link">X-Forwarded-For产生的问题</a></li><li><a href="#http11-相比-http10-性能上的改进" class="table-of-contents__link">HTTP1.1 相比 HTTP1.0 性能上的改进：</a></li><li><a href="#但-http11-还是有性能瓶颈" class="table-of-contents__link">但 HTTP1.1 还是有性能瓶颈：</a></li><li><a href="#1-头部压缩" class="table-of-contents__link">1. 头部压缩</a></li><li><a href="#2-二进制格式" class="table-of-contents__link">2. 二进制格式</a></li><li><a href="#混合加密" class="table-of-contents__link">混合加密</a></li><li><a href="#摘要算法" class="table-of-contents__link">摘要算法</a></li><li><a href="#数字证书" class="table-of-contents__link">数字证书</a></li><li><a href="#1-clienthello" class="table-of-contents__link">1. ClientHello</a></li><li><a href="#2-severhello" class="table-of-contents__link">2. SeverHello</a></li><li><a href="#3-客户端回应" class="table-of-contents__link">3. 客户端回应</a></li><li><a href="#4-服务器的最后回应" class="table-of-contents__link">4. 服务器的最后回应</a></li><li><a href="#tcp协议的主要特点" class="table-of-contents__link">TCP协议的主要特点</a></li><li><a href="#tcp的可靠性原理" class="table-of-contents__link">TCP的可靠性原理</a></li><li><a href="#udp协议特点" class="table-of-contents__link">UDP协议特点</a></li><li><a href="#tcp和udp的区别" class="table-of-contents__link">TCP和UDP的区别</a></li><li><a href="#基于tcp和udp的常用协议" class="table-of-contents__link">基于TCP和UDP的常用协议</a></li><li><a href="#tcp-和-udp-应用场景" class="table-of-contents__link">TCP 和 UDP 应用场景</a></li><li><a href="#tcp-三次握手" class="table-of-contents__link">TCP 三次握手</a></li><li><a href="#tcp-四次挥手" class="table-of-contents__link">TCP 四次挥手</a></li><li><a href="#三次握手" class="table-of-contents__link">三次握手</a></li><li><a href="#四次挥手" class="table-of-contents__link">四次挥手</a></li><li><a href="#应用层" class="table-of-contents__link">应用层</a></li><li><a href="#运输层" class="table-of-contents__link">运输层</a></li><li><a href="#网络层" class="table-of-contents__link">网络层</a></li><li><a href="#数据链路层" class="table-of-contents__link">数据链路层</a></li><li><a href="#物理层" class="table-of-contents__link">物理层</a></li><li><a href="#3-tcp和http有什么联系" class="table-of-contents__link"><strong>3 tcp和http有什么联系</strong></a></li><li><a href="#5-线程如何结束" class="table-of-contents__link"><strong>5 线程如何结束</strong></a></li><li><a href="#7-深拷贝浅拷贝" class="table-of-contents__link"><strong>7 深拷贝浅拷贝</strong></a></li><li><a href="#8-线程池" class="table-of-contents__link"><strong>8 线程池</strong></a></li><li><a href="#17-socket如何解决丢包" class="table-of-contents__link">17 Socket如何解决丢包</a></li><li><a href="#18-其它-网络通信的方式" class="table-of-contents__link">18 其它 网络通信的方式</a></li></ul></div></div></div></div></main></div></div><footer class="footer"><div class="container"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2021 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.aad5aa0c.js"></script>
<script src="/assets/js/main.800b3dd8.js"></script>
</body>
</html>